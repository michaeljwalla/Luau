local quests = require(game:GetService("ReplicatedStorage").Quests)
local stats = require(game:GetService"ReplicatedStorage".ClientStatCache)
local upd = game:GetService"ReplicatedStorage".Events.RetrievePlayerStat

local function clearweird(txt)
    return tostring(txt):gsub("[^%a%s:%-]", ""):gsub("%-", "%%-")
end
local questdata = {
    Repeatables = {}
}
local reps = questdata.Repeatables
for i,v in next, quests.GetAllQuests() do
    if v.Hidden or not v.Repeatable then continue end
    local giver = v.NPC
    reps[giver] = (reps[giver] or {})
    table.insert(reps[giver], v)
end
function questdata:GetPool(npc)
    npc = tostring(npc)
    return assert(reps[npc], ("Invalid pool: %s"):format(tostring(npc))) and reps[npc]
end
function questdata:GetQuest(qname, pool)
    qname = clearweird(qname)
    local quest
    if pool then
        for i,v in next, self:GetPool(pool) do if v.Name:match(qname) or (v.DisplayName and v.DisplayName:match(qname)) then quest = v break end end
    else
        for a,x in next, reps do
            for i,v in next, x do if v.Name:match(qname) or (v.DisplayName and v.DisplayName:match(qname)) then quest = v break end end
            if quest then break end
        end
    end
    return quest
end
function questdata:IsActive(qname, noupdate)
    qname = clearweird(qname)
    if not noupdate then stats:Update"Quests" end --yields
    for i,v in pairs(stats:Get"Quests".Active) do if v.Name:match(qname) then return v.StartValues end end
    return
end
function questdata:GetActiveForPool(pool)
    pool = clearweird(pool)
    
end
print()
for i,v in pairs(stats:Get"Quests".Active[7]) do print(i,v) end