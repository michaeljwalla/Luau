--final form of my polar farm
--known (only hopefully) bugs

local url = '' --for syn.request
if getgenv().kicker then getgenv().kicker:Disconnect() end
local vu = game:GetService("VirtualUser")
game.Players.LocalPlayer.Idled:connect(function()
	vu:CaptureController ()vu:ClickButton2(Vector2.new())
end)
self = readfile('bot/loader')
if game.CoreGui:FindFirstChild("countdown") then game.CoreGui.countdown:Destroy() end
--[[
    how to run quest functions
    1. require quest module
    2. call function with params:
        - self (or :)
        - quest name (can use IDToName)
        - player stats
    3. thats it (DONT FORGET)
]]
local lp = game.Players.LocalPlayer
local character = lp.Character
local monsters ={}
for i,v in pairs(game:GetService("Workspace").MonsterSpawners:GetChildren()) do
    if not v.MonsterLevel:IsA("IntValue") then continue end
    monsters[v.MonsterType.Value] = monsters[v.MonsterType.Value] or {}
    table.insert(monsters[v.MonsterType.Value], {
        Position = (v.MonsterType.Value == "Werewolf" and Vector3.new(-188.875,70.00000762939453,-144.375)) or (v.Territory.Value.Name == "MushroomZone" and v.Territory.Value.Part.Position) or v.Territory.Value.Position,
        OnCooldown = function()
            return v:FindFirstChildWhichIsA('Attachment').TimerGui.TimerLabel.Visible, v:FindFirstChildWhichIsA('Attachment').TimerGui.TimerLabel.Text:match("%d+:%d%d$")
        end,
        Name = v.MonsterType.Value.." (Lvl "..v.MonsterLevel.Value..")"
    })
end
function addcomma(amount)
  local formatted = amount
  while true do  
    formatted, k = string.gsub(formatted, "^(-?%d+)(%d%d%d)", '%1,%2')
    if (k==0) then
      break
    end
  end
  return formatted
end
--[[gotopoint(monsters.Spider[1].Position)
if true then return end]]

local quests = require(game:GetService("ReplicatedStorage").Quests)
local polar = {}
for i,v in pairs(quests.GetAllQuests()) do if v.NPC == "Polar Bear" and v.Repeatable then polar[v.Name] = v end end --able to look for item without searching whole table
local stats = require(game.ReplicatedStorage.ClientStatCache)
local http = game:GetService("HttpService")
for i = 1,6 do
    game:GetService("ReplicatedStorage").Events.ClaimHive:FireServer(i)
end
function json(tbl) return http:JSONEncode(tbl) end
function unjson(str) return http:JSONDecode(str) end
local ticktable = {
    webhook = tick()-5,
    --newquest = tick()-7
    refstats = tick()-5
}
function findclosestactivespawner()
    local closest = {part = nil, mag = math.huge}
    for i,v in pairs(game:GetService("Workspace").MonsterSpawners:GetChildren()) do
        if (character.HumanoidRootPart.Position - v.Position).Magnitude < closest.mag then
            closest.part = v closest.mag = (character.HumanoidRootPart.Position - v.Position).Magnitude
        end
    end
    return closest.part
end
game.ReplicatedStorage.Events.RetrievePlayerStat:InvokeServer("Quests")
local cachedstats = stats:Get()

function getpp()
    return cachedstats.Modifiers.MaxBeeEnergy._.Mods[1].Combo
end

local aqname, aqtable
function getactivequest()--returns name, progress, then task desc/requirements
    --for i,v in pairs(cachedstats.Quests) do print(i,v) end
    for i,v in pairs(cachedstats.Quests.Active) do
        if not polar[v.Name] then continue end
        return v.Name, quests:Progress(v.Name, cachedstats), polar[v.Name].Tasks
    end
    return false
end

function nexttask(unused, progress, tasks, which)
    if which then
        if progress[which][1] ~= 1 then return {Get = tasks[which].Type, OfType = tasks[which].MonsterType or tasks[which].Zone, Amount = tasks[which].Amount, Index = which} else do return false end end
    end
    for i,v in pairs(progress) do
        if v[1] ~= 1 then
            return {Get = tasks[i].Type, OfType = tasks[i].MonsterType or tasks[i].Zone, Amount = tasks[i].Amount, Index = i}
        end
    end
    return false
end

function iscompleted()
    --[[local quest = getactivequest()
    if not quest then return true end
    local prog = quests:Progress(quest, cachedstats)
    for i,v in pairs(prog) do
        if v[1] ~= 1 then return false end
    end
    return true]]
    return not nexttask(getactivequest())
end
--print(iscompleted())
--if true then return end
--print(iscompleted())
--for i,v in pairs(quests:Get('Polar Bear: High Protein Bug Bar').Tasks[1]) do print(i,v) end

if getgenv().sock then pcall(function() getgenv().sock:Close() end) end
local socketed, message = xpcall(function()
    getgenv().sock = syn.websocket.connect('ws://localhost:3000')
    return 'using websocket for webhook calls'
end, function()
    return 'using syn.request aka syn.crash xdxdxdx'
end)
warn(message)
local socket = getgenv().sock
function edit(message, ...)
    if not socketed then
        local g = syn.request{
            Url = url,
            Method = "PATCH",
            Body = json{content = message, embeds = {...}},
            Headers ={['Content-Type'] = "application/json"}
        }
        return g
    end
    socket:Send(json{content = message, embeds = {...}})
end
local thumbnailurl
if socketed then
    socket:Send(('av %d'):format(game.Players.LocalPlayer.UserId))
    thumbnailurl = socket.OnMessage:Wait()
else 
    do
        local json = syn.request{
            Url = ('https://thumbnails.roblox.com/v1/users/avatar-headshot?userIds=%d&size=48x48&format=Png&isCircular=false'):format(game.Players.LocalPlayer.UserId),
            Method = "GET",
        }.Body
        thumbnailurl = unjson(json).data[1].imageUrl
    end
end
local nospam = tick()
getgenv().kicker = game.ReplicatedStorage.DefaultChatSystemChatEvents.OnMessageDoneFiltering.OnClientEvent:Connect(function(data, to)
    if data.Message == '.leave' then
        ended = true
        syn.queue_on_teleport('print(\'running in 60s\')wait(60)\nprint(\'running from TELEPORT\')\n'..self)
        game:GetService("TeleportService"):Teleport(game.PlaceId, game.Players.LocalPlayer)
        --game.Players.LocalPlayer:Kick(("%s disconnected you"):format(data.FromSpeaker))
        --if socketed then socket:Close() end
    end
end)
local questqueued
function newquest()
    --ticktable.refstats = tick()
    local queue = game.ReplicatedStorage.Events.RetrievePlayerStat:InvokeServer("Quests")
    cachedstats.Quests = queue
    if not iscompleted() then return end
    wait()
    game.ReplicatedStorage.Events.CompleteQuestFromPool:FireServer("Polar Bear")
    wait()
    game.ReplicatedStorage.Events.GiveQuestFromPool:FireServer("Polar Bear")
    wait()
    queuenew = false
end
local status = "Awaiting instruction"
local ended
function updatewebhook(onshutdown)
    if ended then return end
    local name, progress = getactivequest()
    local descs = quests:Get(name).Tasks
    if not progress or not descs then edit('error at'..tostring(os.date())'! couldn\'t find active quest') return end
    local msg = ""
    local average = 0
    for i,v in pairs(progress) do
        msg=msg.. string.format("%s - %s\n", descs[i].Description, (v[1] == 1 and "âœ…") or (tostring(v[2]).." / "..tostring(v[3])))
        average = average + v[1]
    end
    average = tostring((average/#progress)*100):match("^%d*.?%d").."%"
    edit("",
    {title = 'Current polar power: '..tostring(getpp()),
      author = {name = game.Players.LocalPlayer.Name, icon_url = thumbnailurl},
      description = os.date(),
      color = (not onshutdown and 0x00ff00) or 0xff0000,
      fields = {
            {
              name = 'Current quest',
              value = name.." - "..average,
            },
            {
              name = '\nQuest items',
              value = msg
            },
            {
                name = "Status",
                value = status
            }
        }
    })
end
function findclosestrare()
    if not character or (character and not (character:FindFirstChild("Humanoid") and character:FindFirstChild("HumanoidRootPart")))then return end 
    local closestrare = {Part = nil, Magnitude = math.huge}
    for i,v in pairs(game.Workspace.Collectibles:GetChildren()) do
        local mag = (character.HumanoidRootPart.Position - v.Position).Magnitude
        if v.Color == Color3.fromRGB(110, 244, 240) and math.round(v.Transparency*10)/10  ~= 0.7 and v.Orientation.Z == 0 and mag < 50 and mag < closestrare.Magnitude then
            closestrare.Part = v
            closestrare.Magnitude = mag
        end
    end
    if not closestrare.Part then return false end
    return closestrare.Part
end

local menu = Instance.new("ScreenGui", game.CoreGui)
menu.Name = "countdown"
local webcountdown = Instance.new("TextLabel", menu)
webcountdown.Position = UDim2.new(0,100,1,-100)
webcountdown.Text = "countdown"
webcountdown.Size = UDim2.new(0,150,0,25)
webcountdown.BackgroundTransparency = 1
webcountdown.TextSize = 18
webcountdown.TextColor3 = Color3.new(1,1,1)
local questcountdown = webcountdown:Clone()
questcountdown.Parent = menu
questcountdown.Position = questcountdown.Position - UDim2.new(0,0,0,25)
questcountdown.Visible = false
local statscountdown = questcountdown:Clone()
statscountdown.Parent = menu
statscountdown.Position = statscountdown.Position - UDim2.new(0,0,0,150)
statscountdown.Visible = true


local queuenew

local tickhook
tickhook = hookfunction(Instance.new("RemoteFunction").InvokeServer,function(event)
    if event == game.ReplicatedStorage.Events.RetrievePlayerStat then ticktable.refstats = tick() end
    return tickhook(event)
end)
local isdoingtask
local lastpos = character.HumanoidRootPart.Position
local ishealing = false
local isconverting = false
local queuedpos = Vector3.new(0,0,0)

local bv = Instance.new("BodyVelocity")
bv.Velocity = Vector3.new(0,-0.1,0)
function gotopoint(pos, nosprinkler)
    if typeof(pos) == "CFrame" then pos = pos.Position end
    if pos == queuedpos then return end
    queuedpos = pos
    if character and character:FindFirstChild("HumanoidRootPart") then
        local ended
        bv.Parent = character.HumanoidRootPart
        game:GetService("TweenService"):Create(character.HumanoidRootPart, TweenInfo.new(1), {CFrame = CFrame.new(-5.5,78,56.2)}):Play()
        task.wait(1)
        local difference = (character.HumanoidRootPart.Position - pos).Magnitude/50
        game:GetService("TweenService"):Create(character.HumanoidRootPart, TweenInfo.new(difference), {CFrame = CFrame.new(pos)}):Play()
        queuedpos = Vector3.new(0,0,0) 
        task.wait(difference+2) 
        if not nosprinkler then game:GetService("ReplicatedStorage").Events.PlayerActivesCommand:FireServer({Name = "Sprinkler Builder"}) end 
        bv.Parent = nil
    end
end
--[[function dotask(task, questname)
    if not task then isdoingtask = false return end
    if task.Get == "Collect Pollen" then
        while quests:Progress(questname, cachedstats)[task.Index][1] ~= 1 do 
            wait(1/3)
            if isconverting then status = string.format("Converting bag...\n%s / %s", addcomma(math.floor(lp.CoreStats.Pollen.Value)), addcomma(math.floor(lp.CoreStats.Capacity.Value))) if lp.CoreStats.Pollen.Value/lp.CoreStats.Capacity.Value <= 0.05 then isconverting = false end continue end
            if lp.CoreStats.Pollen.Value/lp.CoreStats.Capacity.Value > 0.95 then
                isconverting = true
                lastpos = lp.SpawnPos.Value.Position
                gotopoint(lastpos)
                while (character.HumanoidRootPart.Position - lastpos).Magnitude > 5 do wait() end
                game:GetService("ReplicatedStorage").Events.PlayerHiveCommand:FireServer("ToggleHoneyMaking")
                continue
            end
            if ishealing then status = string.format("Healing to 80hp (at %d)", character.Humanoid.Health) if character.Humanoid.Health > 80 then ishealing = false end  continue end
            if character.Humanoid.Health < 30 then
                ishealing = true
                lastpos = Vector3.new(-8, 78, 53)
                gotopoint(lastpos)
                continue
            end
            character:FindFirstChildWhichIsA("Tool").ClickEvent:FireServer()
            if (lastpos - game.Workspace.FlowerZones[task.OfType].Position).Magnitude > 50 or (character.HumanoidRootPart.Position - game.Workspace.FlowerZones[task.OfType].Position).Magnitude > 50 then lastpos = game.Workspace.FlowerZones[task.OfType].Position gotopoint(game.Workspace.FlowerZones[task.OfType].Position) end
            
            if math.random(1,4) >= 3 then character.Humanoid.WalkToPoint = lastpos + Vector3.new(math.sin(math.rad(math.random(1,360)))*25, 0, math.cos(math.rad(math.random(1,360)))*25) end
            status = string.format("Collecting pollen at %s", task.OfType)
        end
    else if task.Get == "Defeat Monsters" then
        while quests:Progress(questname, cachedstats)[task.Index][1] ~= 1 do
            wait(1/3)
            if isconverting then status = string.format("Converting bag...\n%s / %s", addcomma(math.floor(lp.CoreStats.Pollen.Value)), addcomma(math.floor(lp.CoreStats.Capacity.Value))) if lp.CoreStats.Pollen.Value/lp.CoreStats.Capacity.Value <= 0.05 then isconverting = false end continue end
            if lp.CoreStats.Pollen.Value/lp.CoreStats.Capacity.Value > 0.95 then
                isconverting = true
                lastpos = lp.SpawnPos.Value.Position
                gotopoint(lastpos)
                while (character.HumanoidRootPart.Position - lastpos).Magnitude > 5 do wait() end
                game:GetService("ReplicatedStorage").Events.PlayerHiveCommand:FireServer("ToggleHoneyMaking")
                continue
            end
            if ishealing then status = string.format("Healing to 80hp (at %d)", character.Humanoid.Health) if character.Humanoid.Health >= 80 then ishealing = false end if (character.HumanoidRootPart.Position - lastpos).Magnitude > 50 then gotopoint(lastpos) end continue end
            if character.Humanoid.Health < 30 then
                ishealing = true
                lastpos = Vector3.new(-8, 78, 53)
                gotopoint(lastpos)
                continue
            end
            local notoncd = false
            local times = ""
            for i,v in pairs(monsters[task.OfType]) do
                local cd, timer = v.OnCooldown()
                times..="\n"..(timer or "")
                if not cd then notoncd = true lastpos = v.Position if (character.HumanoidRootPart.Position - v.Position).Magnitude > 50 then gotopoint(v.Position) end status = string.format("Killing a %s",task.OfType) break end
            end
            if notoncd and (character.HumanoidRootPart.Position - lastpos).Magnitude > 50 then gotopoint(lastpos) end
            if notoncd and math.random(1,4) >= 3 then character.Humanoid.WalkToPoint = lastpos + Vector3.new(math.sin(math.rad(math.random(1,360)))*25, 0, math.cos(math.rad(math.random(1,360)))*25) end
            if not notoncd then status = string.format("Waiting for %s%s",task.OfType, times) end
        end
    end
    end
    isdoingtask = false
end]]

--#progress = # of quests
--progress table
--1 = %
--2 = current
--3 = required

--instructions table
--Type (collect or kill)
--Description (what players sees)
--Amount
-- \/ ONLY ONE OF THESE WILL BE PRESENT AT A TIME
--Zone (field)
--MonsterType (mob)
function startconvert(character)
    if game:GetService("Players").LocalPlayer.PlayerGui.ScreenGui.ActivateButton.BackgroundColor3 == Color3.fromRGB(201, 39, 28) then return end
    while (character.HumanoidRootPart.Position - lastpos).Magnitude > 5 do wait() end
    game:GetService("ReplicatedStorage").Events.PlayerHiveCommand:FireServer("ToggleHoneyMaking")
    while game:GetService("Players").LocalPlayer.PlayerGui.ScreenGui.ActivateButton.BackgroundColor3 ~= Color3.fromRGB(201, 39, 28) do
    game:GetService("ReplicatedStorage").Events.PlayerHiveCommand:FireServer("ToggleHoneyMaking")
        wait(5)
    end
end
local questinprogress
local doquest = function(name, progress, instructions)
    print('quested')
    local args = {name,progress,instructions}
    local fieldtasks = {}
    local bugtasks = {}
    for i,v in pairs(instructions) do
        if v.Type == "Collect Pollen" then fieldtasks[i] = v continue end
        bugtasks[i] = v
    end
    local function bugged()
        for i,v in pairs(bugtasks) do if quests:Progress(name,cachedstats)[i][1] ~= 1 then return true end end
    end
    for i,v in pairs(fieldtasks) do
        if progress[i][1] == 1 then continue end
        while progress[i][1] ~= 1 and wait(1/3) do
            progress = quests:Progress(name, cachedstats)
            --conversion (highest priority)
            if lp.CoreStats.Pollen.Value / lp.CoreStats.Capacity.Value >= 0.95 then
                lastpos = lp.SpawnPos.Value.Position
                character.Humanoid.WalkToPoint = lastpos
                gotopoint(lastpos, true)
                startconvert(character)
                while lp.CoreStats.Pollen.Value / lp.CoreStats.Capacity.Value >= 0.05 do 
                    wait()
                    status = string.format("Converting bag...\n%d/%d",math.floor(lp.CoreStats.Pollen.Value), math.floor(lp.CoreStats.Capacity.Value))
                    if (character.HumanoidRootPart.Position - lastpos).Magnitude > 5 then gotopoint(lastpos, true) end
                    startconvert()
                end
            end
            --health check
            if character.Humanoid.Health < 30 then
                lastpos = Vector3.new(-8, 78, 53)
                character.Humanoid.WalkToPoint = lastpos
                gotopoint(lastpos, true)
                while character.Humanoid.Health < 80 do 
                    wait()
                    status = string.format("Healing...\n%d/100 (min 80)", character.Humanoid.Health)
                    if (character.HumanoidRootPart.Position - lastpos).Magnitude > 5 then gotopoint(lastpos, true) end
                end
            end
            
            --check field
            local rare = findclosestrare()
            if rare then status = "Looting item(s)..." character.Humanoid.WalkToPoint = rare.Position if math.random(1,4) == 4 then character.Humanoid.Jump = true end continue end

            lastpos = game.Workspace.FlowerZones:FindFirstChild(v.Zone).Position
            if (character.HumanoidRootPart.Position - lastpos).Magnitude > 35 then 
                gotopoint(lastpos)
                while (character.HumanoidRootPart.Position - lastpos).Magnitude > 35 do wait() end
            end
            if math.random(1,3) == 3 then
                local angle = math.rad(math.random(1,360))
                character.Humanoid.WalkToPoint = lastpos + Vector3.new(math.sin(angle)*35, 0, math.cos(angle)*35)
            end
            status = string.format("Collecting from %s", v.Zone)
            character:FindFirstChildWhichIsA("Tool").ClickEvent:FireServer()
        end
    end
    --no starting for loop for bugs since multiple will be cooldown-checked (for loops used later)
    while bugged() and task.wait() do
        if lp.CoreStats.Pollen.Value / lp.CoreStats.Capacity.Value >= 0.95 then
            lastpos = lp.SpawnPos.Value.Position
            character.Humanoid.WalkToPoint = lastpos
            gotopoint(lastpos, true)
            while (character.HumanoidRootPart.Position - lastpos).Magnitude > 2 do wait() end
            game:GetService("ReplicatedStorage").Events.PlayerHiveCommand:FireServer("ToggleHoneyMaking")
            while game:GetService("Players").LocalPlayer.PlayerGui.ScreenGui.ActivateButton.BackgroundColor3 ~= Color3.fromRGB(201, 39, 28) do
                game:GetService("ReplicatedStorage").Events.PlayerHiveCommand:FireServer("ToggleHoneyMaking")
                wait(5)
            end
            while wait() and lp.CoreStats.Pollen.Value / lp.CoreStats.Capacity.Value >= 0.05 do 
                status = string.format("Converting bag...\n%d/%d",math.floor(lp.CoreStats.Pollen.Value), math.floor(lp.CoreStats.Capacity.Value))
                if (character.HumanoidRootPart.Position - lastpos).Magnitude > 5 then gotopoint(lastpos, true) end
            end
        end
        --health check
        if character.Humanoid.Health < 30 then
            lastpos = Vector3.new(-8, 78, 53)
            character.Humanoid.WalkToPoint = lastpos
            gotopoint(lastpos, true)
            while character.Humanoid.Health < 80 do 
                wait()
                status = string.format("Healing...\n%d/100 (min 80)", character.Humanoid.Health)
                if (character.HumanoidRootPart.Position - lastpos).Magnitude > 5 then gotopoint(lastpos, true) end
            end
        end
        --check field
        local rare = findclosestrare()
        if rare then status = "Looting item(s)..." character.Humanoid.WalkToPoint = rare.Position if math.random(1,4) == 4 then character.Humanoid.Jump = true end continue end
        
        progress = quests:Progress(name, cachedstats)
        for i,v in pairs(bugtasks) do
            if not bugged() then break end
            if progress[i][1] == 1 then continue end
            for a,x in pairs(monsters[v.MonsterType]) do
                lastpos = x.Position
                if (character.HumanoidRootPart.Position - lastpos).Magnitude > 35 then 
                    gotopoint(lastpos)
                    while (character.HumanoidRootPart.Position - lastpos).Magnitude > 35 do wait() end
                end
                local t = tick()
                local bug = game.Workspace.Monsters:FindFirstChild(x.Name)
                while not bug and tick()-t < 10 do wait()
                    local rare = findclosestrare()
                    if rare then status = "Looting item(s)..." character.Humanoid.WalkToPoint = rare.Position if math.random(1,4) == 4 then character.Humanoid.Jump = true end continue end
                    status = "Searching for mobs" bug = game.Workspace.Monsters:FindFirstChild(x.Name) 
                end
                if not bug then gotopoint(lastpos) continue end
                t = tick()
                while (bug:IsDescendantOf(game.Workspace) or findclosestrare()) and tick()-t < 30 and wait() do
                    local rare = findclosestrare()
                    if rare then status = "Looting item(s)..." character.Humanoid.WalkToPoint = rare.Position if math.random(1,4) == 4 then character.Humanoid.Jump = true end continue end
                    if not bug:FindFirstChild("Head") then continue elseif (character.HumanoidRootPart.Position-bug.Head.Position).Magnitude > 100 then break end
                    status = "Killing "..bug.Name
                    character.Humanoid.WalkToPoint = bug.Head.Position + bug.Head.CFrame.LookVector*10
                end
                task.wait(2)
                local rare = findclosestrare()
                while wait() and rare and rare:IsDescendantOf(game) do status = "Looting item(s)..." character.Humanoid.WalkToPoint = rare.Position if math.random(1,4) == 4 then character.Humanoid.Jump = true end rare = findclosestrare() end
            end
        end
    end
    print('done!')
    wait(1)
    newquest()
    questinprogress = false
end
if socketed then
    game.CoreGui:FindFirstChild("promptOverlay", true).ChildAdded:Connect(function(v)
        if v.Name == 'ErrorPrompt' then
            ended = true
            socket:Send(("dc %s"):format(game.Players.LocalPlayer.Name))
            socket:Close()
        end
    end)
end


while task.wait() do
    character = lp.Character
    cachedstats = stats:Get()
    statscountdown.Text = status
    if character:FindFirstChild("Humanoid") then character.Humanoid.JumpPower = 80 character.Humanoid.WalkSpeed = 40 end
    webcountdown.Text = string.format("Updating webhook in %ss", tostring(10-(tick()-ticktable.webhook)):match("^%d*.?%d"))
    if tick() - ticktable.webhook > 10 and not ended then 
        ticktable.webhook = tick()
        updatewebhook() 
    end
    --print(not ended and not queuenew and iscompleted())
    if (not questinprogress) and getactivequest() then questinprogress = true coroutine.wrap(doquest)(getactivequest())  end
end
