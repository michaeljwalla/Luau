--[[

add checks to show tracers or not for the Undetectables page (i forgot xd)

add infinite jump (disabled whyile flung duh)
add unflingable code with aggressive rubberbanding (disable while fluing duh)

]]

while not game:IsLoaded() do task.wait() end
game.ReplicatedStorage.Remotes.Ready:FireServer()
shared.sdata = shared.sdata or {Connections = {}, Guis = {}, Data = {}}
local sdata = shared.sdata
local function require(d, recache)
    shared.requirecache = shared.requirecache or {}
    if (typeof(d) ~= 'string') then return getfenv().require(d) end
    if d:find"^http" then return loadstring(game:HttpGet(d))()
    else
        if not recache and shared.requirecache[d] then return shared.requirecache[d] end
        local n, a = pcall(readfile, d..".lua") --loadfile lol
        assert(n, "No local module '"..d.."'")
        local chunk = loadstring(a)
        assert(chunk, "Error in local: "..d)
        shared.requirecache[d] = chunk()
        return shared.requirecache[d]
    end
end
local function hasprop(inst, prop, pcd)
    return pcd and inst[prop] or pcall(hasprop, inst, prop, true)
end
local function apply(inst, props)
    local parent = props.Parent
    props.Parent = nil
    for i,v in next, props do
        if hasprop(inst, i) then
            inst[i] = v
        end
    end
    if parent then inst.Parent = parent end
    return inst
end
local function notify(options) --Title, Text, Duration, Icon
    game.StarterGui:SetCore("SendNotification", options)
end
local gui = require("bell/gui", true) --make a new instance of it
local minimap = require("bell/sd2/minimap", true) --setmetatable({}, {__index = function(self, index) return function() end end})
minimap:Track("All")

local stepper = require"bell/stepper"
local tracer = require("bell/tracers", true)
local defer, foreachin = task.defer, table.foreach
local pi, log = math.pi, math.log
local cos, sin = math.cos, math.sin
local cancel, status, running, wrap = task.cancel, coroutine.status, coroutine.running, coroutine.wrap
local request, insert, spawn, delay = syn.request, table.insert, task.spawn, task.delay
local random, intdiv, floor, clamp, round, min, max = math.random, math.modf, math.floor, math.clamp,math.round, math.min, math.max
local lp, rs = game.Players.LocalPlayer, game.ReplicatedStorage
local cc = workspace.CurrentCamera
local mouse = lp:GetMouse()
local players = game:GetService"Players"
local lighting, textservice, tweenservice, inputservice = game:GetService"Lighting", game:GetService"TextService", game:GetService"TweenService", game:GetService"UserInputService"
local disasters, map, lobby = workspace:WaitForChild"Disaster", workspace:WaitForChild"Map", workspace:WaitForChild"Lobby"
if sdata.Guis.sd2 then sdata.Guis.sd2:cleanup() end
sdata.Guis.sd2 = gui
if sdata.Data.sd2 then
    local d = sdata.Data.sd2
    for i,v in next, d.Functions do if not (v[1] and typeof(v[1]) == 'string' and v[1]:find"|") then continue end stepper:Remove(unpack(v))end
    for i,v in next, d.Tracers do for section, entry in next, v do entry:Destroy() end end
end

local data = {
    Tracers = {},
    Options = sdata.Data.sd2 and sdata.Data.sd2.Options or {},
    Functions = {},
    Keybinds = sdata.Data.sd2 and sdata.Data.sd2.Keybinds or {},
    CodeFuncs = {},
    Hooked = sdata.Data.sd2 and sdata.Data.sd2.Hooked or {},
    Settings = sdata.Data.sd2 and sdata.Data.sd2.Settings or {
        Tracers = {Method = "3D", Color = Color3.new(1)},
        Looks = { PopupTransparency = 0 }
    },
    Shared = sdata.Data.sd2 and sdata.Data.sd2.Shared or {}
}
sdata.Data.sd2 = data
local shareddata = data.Shared
local char, random = string.char, math.random
local function rand(len)
    local result = ""
    for i = 1, len do result = result..char(random(0,255)) end
    return result
end
local function randomvector(magnitude)
    return Vector3.new(
        cos(2 * pi * random()),
        random() < 0.5 and sin(2 * pi * random()) or cos(2 * pi * random()),
        sin(2 * pi * random())).Unit * magnitude
end

local rbxsettings = settings()
local settings = data.Settings
local options = data.Options

local trsettings = settings.Tracers
local tracers = data.Tracers
local tracerfolder3d = settings.TracerFolder3D and settings.TracerFolder3D.Parent == workspace and settings.TracerFolder3D or apply(Instance.new"Folder", {Parent = workspace, Name = rand(13)})
settings.TracerFolder3D = tracerfolder3d

--togglefuncs is just the gendata func table
--keybinddata for customizing activations
--[[
    {
        Name = "hi",
        Button = keycode,
        Ctrl = true,
        Alt = false,
        SuccessionClicks = val or 1
    }
]]
local keybinds = data.Keybinds

local function registerkeybind(keybinddata, func, overwrite)
    local btn, ctrl, alt = Enum.KeyCode[keybinddata.Key], keybinddata.Ctrl, keybinddata.Alt
    local format = (ctrl and "Ctrl + " or "")..(alt and "Alt + " or "")..btn.Name
    if (keybinds[format] or keybinds[keybinddata.Info]) and not overwrite then
        return false, keybinds[format]
    end
    local numreps = keybinddata.Repetitions or 1
    local new = {
        Info = keybinddata.Info,
        Format = format..(numreps ~= 1 and " ( x"..numreps.." )" or ""),
        Key = btn,
        Ctrl = ctrl,
        Alt = alt,
        Repetitions = numreps,
        Fire = func,
        LastCall = 0,
        CurRep = 0
    }
    keybinds[format] = new --for controller to index
    keybinds[keybinddata.Info] = new --for others to index
    return true, new
end
local function removekeybind(keybinddata)
    local format = (keybinddata.Ctrl and "Ctrl + " or "")..(keybinddata.Alt and "Alt + " or "")..keybinddata.Key --should be str
    local keybind = keybinds[format]
    if keybind then rawset(keybinds, format, nil) rawset(keybinds, keybind.Info, nil) return true, keybind end
    return false
end
--registerkeybind({Info = "LoL", Key = "Space", Ctrl = true, Alt = true, Repetitions = 3}, print, true)
local lctrl, rctrl, lalt, ralt = Enum.KeyCode.LeftControl,Enum.KeyCode.RightControl,Enum.KeyCode.LeftAlt,Enum.KeyCode.RightAlt
local function isctrling()
    return inputservice:IsKeyDown(lctrl) or inputservice:IsKeyDown(rctrl)
end
local function isalting()
    return inputservice:IsKeyDown(lalt) or inputservice:IsKeyDown(ralt)
end
insert(data.Functions, { stepper:Add(inputservice, "InputBegan", "KeybindController", function(input, wasfocused)
    local name = input.KeyCode.Name
    if (name ~= "Semicolon" and wasfocused) or name == 'Unknown' then return end
    local format = (isctrling() and "Ctrl + " or "")..(isalting() and "Alt + " or "")..name
    local keybind = keybinds[format]
    
    if not keybind then return end
    local cur = tick()
    keybind.CurRep = ((cur - keybind.LastCall > 0.25 and 0 or keybind.CurRep) + 1) % keybind.Repetitions
    keybind.LastCall = cur
    if keybind.CurRep == 0 then keybind.Fire(cur) end
end) })
local function newtracer(towhat, text, section, skipwarn, visibility, overrides)
    section = section or "Unspecified"
    overrides = overrides or {}
    local sect = tracers[section] or {}
    tracers[section] = sect
    if sect[towhat] then  return (not skipwarn and warn("Attempted to create a tracer which already exists to '"..tostring(towhat).."' (returning old tracer...)")) or sect[towhat] end
    local new = tracer.new(towhat)
    new:SetMethod(overrides.Method or trsettings.Method)
    new:SetColor(overrides.Color or trsettings.Color)
    new:SetText(text or tostring(towhat))
    new:SetVisible((visibility == nil and true) or visibility)
    
    if new.Method == '3D' then new.Components.Line.Parent = tracerfolder3d end
    tracers[section][towhat] = new
    return new
end
local function deltracer(section, obj)
    section = tracers[section]
    if not section then
        return
    elseif not obj then
        for i,v in next, section do
            rawset(section, i, nil)
            v:Destroy()
        end
        return
    end
    for i,v in next, section do
        if v == obj then
            rawset(section, i, nil)
            v:Destroy()
        end
    end
end

local fcounter = 0 --used later in Home menu
insert(data.Functions, { stepper:Add(game.RunService, "RenderStepped", "TracerDraw", function()
    fcounter = fcounter + 1
    for i,v in next, tracers do
        for a,x in next, v do
            if typeof(a) == 'Instance' and not a:IsDescendantOf(game) then
                rawset(v, a, nil)
                x:Destroy()
                continue
            end
            x:Render()
        end
    end
end) })
--maybe change to findfirstchild else childadded
spawn(pcall, function() --no physics kick
    rs:WaitForChild("Remotes", 15):WaitForChild("Test", 5).OnClientInvoke = function() return true end
    lp:WaitForChild("PlayerScripts", 15):WaitForChild("...", 5).Disabled = true
    lp.PlayerScripts:WaitForChild("AntiFreeze", 5).Disabled = true--no freeze kick
end) 
insert(data.Functions, { stepper:Add(lp:WaitForChild("PlayerGui", 60) or error"no ui?", "ChildAdded", "BuiltInAntiAntiAFK",
    function(v) --no server afk kick
        if v.Name == 'QuestionGui' then
            local x = v:WaitForChild"Notice":WaitForChild"Question".Text
            v.Notice.Visible = false
            local y = v.Notice:WaitForChild"TextBox"
            local z = v.Notice:WaitForChild"Close"
            local numbers = x:match"%d %+ %d":split" + "
            local sum = tonumber(numbers[1]) + tonumber(numbers[2])
            y.Text = tostring(sum)
            wait(6)
            firesignal(z.MouseButton1Down)
        end
    end)
})
local vu = game:GetService("VirtualUser")
insert(data.Functions, { stepper:Add(lp, "Idled", "Anti20MinKick",
    function()
    	vu:CaptureController ()
    	vu:ClickButton2(Vector2.new())
    end)
})
--ez gc grab winking tongue face money face flushed face exploding head
local fontmodule = require(rs:WaitForChild"Modules":WaitForChild"Font")
local setnotice, locktimer = fontmodule.generateText

local timergui = lp:WaitForChild("PlayerGui", 15) and lp.PlayerGui:WaitForChild("TimerGui", 15) or error(notify{Title = "Fatal Error", Text = "Missing component: TimerGui"} or "Fatal error. Script aborted.")
getfenv().tframe = timergui:WaitForChild"TimerFrame"
if not data.Hooked.generateText then
    
    tnotice, tshadow = tframe:WaitForChild"Notice", tframe:WaitForChild"Shadow"
    
    local tscript = timergui:WaitForChild"LocalScript (TimerGui)"
    local timerenv = getsenv(tscript)
    local forceupd = timerenv.update
    
    local colortable --add functionality for any color to top text
    for i,v in next, getgc(true) do
        if not (type(v) == 'table' and rawget(v, 'cyan')) then continue end
        setmetatable(v, {
            __index = function(self, index)
                local t = typeof(index)
                return (t == 'Color3' and index) or (t == 'string' and BrickColor.new(index).Color) 
            end
        })
        colortable = v
        break
    end
    -- now i can set the notice
    local fontentry = {
        Original = nil,  --no entry
        TextForce = "",
        ColorForce = "cyan"
    }
    oldfont = hookfunction(fontmodule.generateText, function(self, frame, text, color, whichfont, waittime, soundid, param8, param9, param10)
        local forcetext, forcecolor = fontentry.TextForce, fontentry.ColorForce
        if checkcaller() and (not self or typeof(self) == 'string') then
            if not self or (forcetext == self) then return forcetext, forcecolor end
            fontentry.TextForce = self and self:upper() or forcetext
            fontentry.ColorForce = frame and (typeof(frame) == 'string' and frame:lower()) or frame or forcecolor -- setnotice(text, color) from syn
            --tick.Volume = 0
            forceupd() --cause of typeof==string
            --tick:Stop()
            --tick.Volume = 0.5 --i kind of like the extra ticking actually, sounds kinda cool
            return forcetext, forcecolor
        end
        if (frame == tshadow or frame == tnotice) and forcetext ~= "" then --local call
            return oldfont(self, frame, forcetext, frame == tshadow and "black" or forcecolor, whichfont, waittime, soundid, param8, param9, param10)
        end
        return oldfont(self, frame, text, color, whichfont, waittime, soundid, param8, param9, param10)
    end)
    fontentry.Original = oldfont
    fontentry.Call = fontmodule.generateText
    data.Hooked.generateText = fontentry
    
    --bring down timer whenever i want
    local timerentry = {
        Original = nil,
        ForcedDown = false
    }
    local oldtimer
    local hidetimerval = rs:WaitForChild"Info":WaitForChild"HideTimer"
    local timersenv = getsenv(timergui:WaitForChild("LocalScript (TimerGui)", 15))
    do 
        local t = tick()
        while tick() - t < 15 do
            for i,v in next, getconnections(hidetimerval.Changed) do
                if not v.Function then continue end
                local success, const = pcall(getconstant, v.Function, 2)
                if success and const == 'tweened' then
                    oldtimer = v.Function
                    --v:Disable()
                    break --found
                end
            end
            if oldtimer then break else wait(0.1) end
        end
    end
    
    if not oldtimer then--assert not working w functions lol?
        notify{Title = "Fatal Error", Text = "Missing timer toggle function"}
        error"Fatal Error. Script aborted"
    end
    
    timersenv.tweened = false
    tframe.Visible = true
    local nothing = function() end
    local tupd = timersenv.update
    local last, ot
    ot = hookfunction(oldtimer, function()
        timersenv.tweened = false
        if timerentry.ForcedDown then
            return
        elseif checkcaller() then
            timersenv.spawn = nothing --disable xp bar popup 
        else
            timersenv.spawn = timersenv.fillExpBar
        end
        tupd()
        wrap(ot)()
    end)
    setfenv(ot, timersenv)
    
    timerentry.Call = oldtimer
    timerentry.Original = ot
    timerentry._env = timersenv
    timerentry._signal = hidetimerval.Changed
    
    data.Hooked.HideTimerChanged = timerentry
end
do
    local timerentry = data.Hooked.HideTimerChanged
    locktimer = function(t)
        timerentry.ForcedDown = t
        firesignal(timerentry._signal)
        if t then
            tframe:TweenPosition(UDim2.new(tframe.Position.X, UDim.new()), "InOut", "Quad", 0.4)
            tframe.Visible = true
        end
    end
end
locktimer(false)
--gui:MakeResizable(gui._main, nil, Vector2.new(150,150), Vector2.new(400,400)).ZIndex = 50
local menu_home = gui:AddMenu"Home"
local menu_undetectables, menu_gameplay
gui:SwitchTo"Home"

local inf = 1/0
local function getmassof(part, ignorelist)
    ignorelist = ignorelist or {}
    ignorelist[part] = true
    local mass = part:GetMass()
    for i,v in next, part:GetConnectedParts() do
        --if anchored then return
        if mass == inf then break elseif ignorelist[v] then continue end
        mass = mass + getmassof(v, ignorelist)
    end
    return mass
end

local function gethum(p)
    p = p or lp
    if p:IsA"Player" then
        return p.Character and p.Character:FindFirstChildWhichIsA"Humanoid"
    end
    return p:FindFirstChildWhichIsA"Humanoid"
end
local function getroot(p)
    local hum = gethum(p)
    return hum and hum.RootPart
end
local function getclosestplayerfrompoint(vec3, nolp)
    local closest, closestmag = Vector3.one * inf, inf
    local me
    for i,v in next, players:GetPlayers() do
        local root = getroot(v)
        if not root then
            continue
        else
            if (v == lp) then me = root.Position continue end
            local magnitude = (root.Position - vec3).Magnitude
            if magnitude < closestmag then
                closest, closestmag = root.Position, magnitude
            end
        end
    end
    return closest, me
end
local function getclosestplayer(plr)
    plr = plr or lp
    local me = getroot(plr)
    local closest, closestmag = me, 1/0
    if not me then return false end
    for i,v in next, players:GetPlayers() do
        if v == plr then continue end
        local root = getroot(v)
        if not root then
            continue
        else
            local magnitude = (root.Position - me.Position).Magnitude
            if magnitude < closestmag then
                closest, closestmag = root, magnitude
            end
        end
    end
    return closest, me
end
local function touch(part, optreciever)
    optreciever = (optreciever and optreciever:IsA"BasePart") or getroot(optreciever)
    if not (optreciever and optreciever:IsA"BasePart") then return end
    firetouchinterest(optreciever, part, 0)
    firetouchinterest(optreciever, part, 1)
end
local function formattime(n) --hours minutes seconds
    local format = ""
    local hours, minutes, seconds
    hours, n = intdiv(n/3600)
    minutes, n = intdiv(n*60)
    seconds = round(n*60)
    return ((hours < 10 and "0" or "")..hours)..":"..((minutes < 10 and "0" or "")..minutes)..":"..((seconds < 10 and "0" or "")..seconds)
end
local function plrfromstr(str)
    if #str == 0 then return end
    str = "^"..str:lower():gsub("[^%w_]*", "")
    for i,v in next, players:GetPlayers() do
        if tostring(v):lower():find(str) then return v end
    end
    return
end
local function torichcolor(c3, offset)
    offset = tonumber(offset) or 0
    return ('"rgb(%d,%d,%d)"'):format(clamp(floor(c3.R*255)+offset,0,255), clamp(floor(c3.G*255)+offset,0,255), clamp(floor(c3.B*255)+offset,0,255))
end

local blue = torichcolor(gui:GetThemeColor"Accent", 40)
local red = torichcolor(Color3.fromRGB(245, 66, 66))
local green = torichcolor(Color3.fromRGB(50, 168, 82))
local dark, medium, light = gui:GetThemeColor"Dark", gui:GetThemeColor"Medium", gui:GetThemeColor"Light"
local defuill = apply(Instance.new"UIListLayout", {
    SortOrder = "LayoutOrder",
})
--home
do
    local welcomer = gui:ApplyProps(gui:AddBasic("Frame", UDim2.new(0,380,0,95), UDim2.new(0,10,0,10), menu_home.Frame), {
        AutomaticSize = "X",
        Name = "Welcomer",
        ClipsDescendants = true
    })
    local name = lp.Name
    local activeruntime = apply(gui:AddBasic("TextLabel", UDim2.new(1,0,0,60), UDim2.new(0,0,0,0), welcomer), {
            Text = "Welcome, y/n.\n<font size=\"12\">You've been in this server for 00:00:00</font>",
            BorderSizePixel = 0
    })
    
    apply(gui:AddBasic("Frame", UDim2.new(0.5), UDim2.new(0.25,0,1), activeruntime), {
        Name = "Bar",
        BorderColor3 = Color3.new(1,1,1)
    })
    
    insert(data.Functions, { stepper:Add(game.RunService, "Heartbeat", "RuntimeUpdater", function(t)
        activeruntime.Text = "Welcome, <font color="..blue..">"..name.."</font>.\n<font size=\"12\">You've been in this server for <font color="..blue..">"..formattime(workspace.DistributedGameTime).."</font>\n<font color="..blue.."><b>"..fcounter.."</b></font> fps</font> "
        fcounter = 0 -- defined before tracer render loop
    end, 1)})
    local link, roprolink, linksize = ""
    spawn(function()
        link = request{
            Url = "https://api.ropro.io/createInvite.php?universeid=" .. game.GameId .. "&serverid=" .. game.JobId,
            Method = "GET",
            Headers = {}
        }.Body
        apply(gui:AddBasic("TextLabel", UDim2.new(1,-25,1), nil, roprolink), {
            BorderSizePixel = 0,
            TextSize = 12,
            Text = link
        })
        linksize = textservice:GetTextSize(link, 12, 18, Vector2.new(1920, 1080)).X
        roprolink.Size = UDim2.new(0,linksize+25,0,25)
        roprolink.Position = UDim2.new(0.5,-(linksize+25)/2,0,65)
    end)
    linksize = textservice:GetTextSize(link, 12, 18, Vector2.new(1920, 1080)).X
    roprolink = apply(gui:AddBasic("Frame", UDim2.new(0,linksize+25,0,25), UDim2.new(0.5,-(linksize+25)/2,0,65), welcomer), {
        Name = "RoPro Link",
        BorderSizePixel = 0
    })
    --[[apply(gui:AddBasic("TextLabel", UDim2.new(1,-25,1), nil, roprolink), {
        BorderSizePixel = 0,
        TextSize = 12,
        Text = link
    })]]
    apply(gui:AddBasic("TextButton", UDim2.new(0,25,0,25), UDim2.new(1,-25), roprolink), {
        Text = "üìã",
        BorderSizePixel = 0
    }).MouseButton1Click:Connect(function() setclipboard(link) end)
    local guide = apply(gui:AddBasic("Frame", UDim2.new(0,380,0,255), UDim2.new(0,10,0,115), menu_home.Frame), {
        Name = "Guide",
    })
    local guideoptions = gui:AddBasic("ScrollingFrame", UDim2.new(0.35,0,1), nil, guide)
    
    local guideentry = apply(gui:AddBasic("TextButton", UDim2.new(1,0,0,25), nil, nil), {
        Text = "Hello, World!",
    })
    apply(gui:AddBasic("TextLabel", UDim2.new(1,0,0,25), nil, guideoptions), {
        Text = "Guide",
        BackgroundColor3 = dark
    })
    
    local guidetext = apply(gui:AddBasic("TextLabel", UDim2.new(0.65,0,1,0), UDim2.new(0.35), guide), { Text = "" })
    local msgs = {
        Home = ("Hi this is the homepage\nMaybe something useful will be added here...\n\n<font color=%s>Ctrl + Alt + ;</font> to hide this menu. \n<font color=%s>Ctrl + Alt + 1</font> to disable everything. (panic mode)"):format(blue,blue),
        Undetectables = ("This section contains tweaks that only affect your client.\n\nIn other words, <font color=%s><i>you can only be detected by sharing your screen or exposing yourself</i></font> with these options."):format(blue),
        Gameplay = ("<font color=%s><i>THE EXPLOITS IN THIS SECTION CAN RESULT IN A REPORT IF YOU AREN'T CAREFUL</i></font>\n\nThese options affect various factors of the world / disaster rounds."):format(blue)
    }
    gui:AddRadioButtons(
        {Parent = guideoptions, Position = UDim2.new(0,0,0,25), Size = UDim2.new(1,0,1,-25)},
        {Size = UDim2.new(1,0,0,25), StartsFrom = nil, Background = medium, Default = 1, RightSide = false, TextSize = 12},
        {
            "Home",
            "Undetectables",
            "Gameplay"
        },
        function(c) guidetext.Text = msgs[c] or "(no message given)" end)
    --add radio buttons to the list, put way to not include checkboxes so it looks normal!
    --extfunc should use dict to set sibling text to xyz
end
local defbutton = gui:SquishInto(
    apply(gui:AddBasic("TextLabel", UDim2.new(1,0,0,20), nil, nil), {Text = "Example Text", Name = "Option", TextXAlignment = "Left"}),
    apply(gui:AddBasic"TextButton", { BackgroundColor3 = dark, Text = "", Name = "Button"}),
    false
).Parent
local popupbox = apply(gui:AddBasic("TextLabel", UDim2.new(0,20,0,20), UDim2.new(1,-20), nil), { BorderSizePixel = 0, Text = "?", TextSize = 12 })
local section = apply(Instance.new"Frame", {Size = UDim2.new(0,25), Position = UDim2.new(0,-2.5,1), BorderColor3 = Color3.new(1,1,1),
    Parent = apply(gui:AddBasic("TextLabel", UDim2.new(0.5,0,0,20), UDim2.new(0.05), nil), { BorderSizePixel = 0, TextXAlignment = "Left", Text = "Key" })
}).Parent

local humanoids = shareddata.Humanoids or {} --remembrr me
shareddata.Buttons = buttons

menu_undetectables = gui:AddMenu("Undetectables", Color3.fromRGB(164, 111, 242))
--undet
do
    local maintab = gui:AddBasic("Frame", UDim2.new(0,187.5,0, 285), UDim2.new(0,10,0,10), menu_undetectables.Frame)
    local rightmaintab = gui:AddBasic("Frame", UDim2.new(0,187.5,0,95), UDim2.new(1,-197.5,0,85), menu_undetectables.Frame)
    local accent = menu_undetectables.Accent
    
    local hooked = data.Hooked
    local fdata = {}
    data.Functions.Undetectables = fdata
    
    local colorkey = gui:AddBasic("Frame", UDim2.new(0,187.5,0,70), UDim2.new(1,-197.5,0,10), menu_undetectables.Frame)
    apply(gui:AddBasic("TextLabel", UDim2.new(0.95,0,1, -25), UDim2.new(0.05,0,0,25), colorkey), {TextSize = 12, BorderSizePixel = 0, TextXAlignment = "Left", TextYAlignment = "Top",
        Text = ("<font color=%s> Red</font> - Tracers<font color=%s>\nGreen</font> - Specialized\n<font color=%s>Blue</font> - Other"):format(red, green, blue)
    })
    section:Clone().Parent = colorkey
    
    apply(section:Clone(), {
        Parent = maintab,
        Text = "General"
    })
    local genholder = apply(gui:AddBasic("Frame", UDim2.new(0.9,0,0,80), UDim2.new(0.05,0,0,25), maintab), {
        Name = "General",
        BorderColor3 = Color3.new(1,1,1)
    })
    defuill:Clone().Parent = genholder
    
    local mysttrack = apply(defbutton:Clone(), {
        Parent = genholder
    })
    gui:MakePopup(apply(popupbox:Clone(), { Parent = mysttrack }), apply(gui:DefaultPopup"Changes the 'Mystery Disaster' notifier into the current disaster", { BackgroundTransparency = settings.Looks.PopupTransparency, Size = UDim2.new(0,120,0,40) }), { FollowMouse = true })
    
    apply(mysttrack.RealText, {
        Text = "<font color="..green..">  Track Mysteries</font>",
        Size = UDim2.new(1, -40, 0, 20) --upd for button
    })
    local gendata = {}
    fdata.General = gendata
    local lastenabled = tick() - 5
    local function defaulttrackmyst(state)
        options.TrackMystery = state
        mysttrack.Button.BackgroundColor3 = (state and accent) or dark
        --if tick() - lastenabled > 5 then notify{Title = "Mystery Track "..(state and "Enabled" or "Disabled"), Text = "üëç"} lastenabled = tick() end
    end
    local currentgamemode = rs:WaitForChild"Info":WaitForChild"Gamemode".Value ~= "Normal" and "Hyper " or ""
    local timercounter = rs.Info:WaitForChild"Timer"
    local sfogcolor, ismystery = lighting:WaitForChild"ServerFogColor"

    local function applymysteryeffects(child)
        if not (child and child:IsA"Model" and (ismystery or sfogcolor.Value == Color3.new(1,1,1))) then return end
        setnotice(currentgamemode..tostring(child), accent)
        defer--[[delay(0.5, ]](locktimer, true)
    end
    stepper:Add(disasters, "ChildRemoved", "MystTrack_DisRem", function(c)
        if not options.TrackMystery then return end
        for i,v in next, disasters:GetChildren() do --some mob parts get sent to disaster folder very annoyingly
            if v:IsA"Model" then return end
        end
        if setnotice() ~= "" then
            setnotice""
            locktimer(false)
        end
    end)
    insert(data.Functions, { stepper:Add(sfogcolor, "Changed", "MystTrack_FogChange", function(val)
        local last = ismystery
        ismystery = val == Color3.new(1,1,1)
        if last and not ismystery then
            setnotice""
            defer(locktimer,false)
        elseif ismystery and options.TrackMystery then
            setnotice("waiting for mystery...", accent)
            timercounter.Value = 999
            delay(0.5, locktimer, true)
        end
    end, nil, true) }) --nil and true = no cooldown, defer it
    insert(data.Functions, { stepper:Add(disasters, "ChildAdded", "MystTrack_DisGet", applymysteryeffects) })
    stepper:Disable(disasters, "ChildAdded", "MystTrack_DisGet")
    gendata.TrackMystery = {
        On = newcclosure(function(state)
            applymysteryeffects(disasters:FindFirstChildWhichIsA"Model")
            stepper:Enable(disasters, "ChildAdded", "MystTrack_DisGet")
            
            defaulttrackmyst(state)
        end),
        Off = function(state)
            stepper:Disable(disasters, "ChildAdded", "MystTrack_DisGet")
            setnotice""
            locktimer(false)
            
            defaulttrackmyst(state)
        end
    }
    
    gui:BindToggleClick(mysttrack.Button, gendata.TrackMystery, options.TrackMystery)
    
    local nofog = apply(defbutton:Clone(), {
        Parent = genholder
    })
    nofog.RealText.Text = "<font color="..blue..">  Remove Fog</font>"
    
    local sfogval = lighting:WaitForChild"ServerFogEnd"
    local fogged
    local function updfog(state)
        local tstate = type(state)
        fogged = tstate == 'boolean' and state or tstate ~= 'boolean' and fogged
        lighting.FogEnd = (fogged and 1/0) or sfogval.Value
    end
    gendata.NoFog = {
        On = function()
            options.NoFog = true
            nofog.Button.BackgroundColor3 = accent
            updfog(true)
        end,
        Off = function()
            options.NoFog = false
            nofog.Button.BackgroundColor3 = dark
            updfog(false)
        end
    }
    insert(data.Functions, { stepper:Add(lighting, "!FogEnd", "FogEndUpdate", updfog) })
    gui:BindToggleClick(nofog.Button, gendata.NoFog, options.NoFog)
    
    local noshadows = apply(defbutton:Clone(), {
        Parent = genholder
    })
    noshadows.RealText.Text = "<font color="..blue..">  Remove Shadows</font>"
    
    local function updshadows(state)
        lighting.GlobalShadows = not state --opposite
    end
    gendata.NoShadows = {
        On = function()
            options.NoShadows = true
            noshadows.Button.BackgroundColor3 = accent
            updshadows(true)
        end,
        Off = function()
            options.NoShadows = false
            noshadows.Button.BackgroundColor3 = dark
            updshadows(false)
        end
    }
    gui:BindToggleClick(noshadows.Button, gendata.NoShadows, options.NoShadows)
    
    local discamblock = apply(defbutton:Clone(), {
        Parent = genholder
    })
    gui:MakePopup(apply(popupbox:Clone(), { Parent = discamblock }), apply(gui:DefaultPopup"Re-enables your camera's ability to push past the map's borders", { BackgroundTransparency = settings.Looks.PopupTransparency, Size = UDim2.new(0,120,0,40) }), { FollowMouse = true })
    
    apply(discamblock.RealText, {
        Text = "<font color="..blue..">  No CamBorders</font>",
        Size = UDim2.new(1, -40, 0, 20) --upd for button
    })
    local bricks = lobby:WaitForChild"Bricks"
    local function togglecams(val)
        for i,v in next, bricks:GetChildren() do
            if tostring(v):find"^A" then v.Position = v.Position * Vector3.new(1,(val and -145 or 0.4)/v.Position.Y, 1) end
        end
    end
    gendata.DisableCamLock = {
        On = function()
            options.DisableCamLock = true
            discamblock.Button.BackgroundColor3 = accent
            togglecams(true)
        end,
        Off = function()
            options.DisableCamLock = false
            discamblock.Button.BackgroundColor3 = dark
            togglecams(false)
        end
    }
    gui:BindToggleClick(discamblock.Button, gendata.DisableCamLock, options.DisableCamLock)
    
    -- misc
    apply(section:Clone(), {
        Parent = rightmaintab,
        Text = "Miscellaneous"
    })
    local miscdata = {}
    fdata.Miscellaneous = miscdata
    local mischolder = apply(gui:AddBasic("Frame", UDim2.new(0.9,0,0,20), UDim2.new(0.05,0,0,25), rightmaintab), {
        Name = "Miscellaneous",
        BorderColor3 = Color3.new(1,1,1)
    })
    defuill:Clone().Parent = mischolder
    
    local minimapper = apply(defbutton:Clone(), {
        Parent = mischolder,
        Name = 'Minimap'
    })
    gui:MakePopup(apply(popupbox:Clone(), { Parent = minimapper }), apply(gui:DefaultPopup"Generates a minimap of the world", { BackgroundTransparency = settings.Looks.PopupTransparency, Size = UDim2.new(0,90,0,35) }), { FollowMouse = true })

    apply(minimapper.RealText, {
        Text = "<font color="..blue..">  Minimap</font>",
        Size = UDim2.new(1, -40, 0, 20) --upd for button
    })
    miscdata.Minimapper = {
        On = function()
            options.Minimapper = true
            minimap:Start()
            minimapper.Button.BackgroundColor3 = accent
        end,
        Off = function()
            options.Minimapper = false
            minimap:Stop()
            minimapper.Button.BackgroundColor3 = dark
        end
    }
    gui:BindToggleClick(minimapper.Button, miscdata.Minimapper, options.Minimapper)
    local mmcommandassign = {
        You = "None"
    }
    gui:AddRadioButtons(
        {Parent = minimapper, Position = UDim2.new(0,21,0,21), Size = UDim2.new(1,-21,0,40)},
        {Size = UDim2.new(0.5,0,0,20), StartsFrom = nil, Background = medium, Default = options.MinimapperFilter or 1, RightSide = false, TextSize = 12, SortingOpt = apply(Instance.new"UIGridLayout", { SortOrder = "LayoutOrder", CellSize = UDim2.new(0.5,0,0,20), CellPadding = UDim2.new()})},
        {
            "All",
            "You",
            "Players",
            "NPCs"
        },
        function(type, index) options.MinimapperFilter = index minimap:Track(mmcommandassign[type] or type) end)
    
    --disasters
    local disdata = {}
    fdata.Disasters = disdata
    apply(section:Clone(), {
        Parent = maintab,
        Text = "Disasters",
        Position = UDim2.new(0.05,0,0,110)
    })
    local disholder = apply(gui:AddBasic("Frame", UDim2.new(0.9,0,0,140), UDim2.new(0.05,0,0,135), maintab), {
        Name = "Disaster",
        BorderColor3 = Color3.new(1,1,1)
    })
    defuill:Clone().Parent = disholder
    
    local alltoggler = apply(defbutton:Clone(), {
        Parent = disholder,
        Name = 'SelectAll'
    })
    apply(alltoggler.RealText, {
        Text = "  Enable / Disable All",
        TextSize = 12
    })
    disdata.ToggleAllDis = {
        On = function()
            for i,v in next, disholder:GetChildren() do if not (v:IsA"TextLabel" and tostring(v) ~= "SelectAll") then continue else v.Button.Toggle.Value = true end end
            alltoggler.Button.BackgroundColor3 = accent
        end,
        Off = function()
            for i,v in next, disholder:GetChildren() do if not (v:IsA"TextLabel" and tostring(v) ~= "SelectAll") then continue else v.Button.Toggle.Value = false end end
            alltoggler.Button.BackgroundColor3 = dark
        end
    }
    gui:BindToggleClick(alltoggler.Button, disdata.ToggleAllDis, false)
    
    --ok
    --add green zone and other tracers stuff i have no idea if itll work
    --the render loop is above and SHOULD auto delete tracers once targets are gone
    local function trygz(c, onforeach)
        c = onforeach or c
        if tostring(c) ~= 'Green Zone' then return end
        
        local zone = c:WaitForChild("Zone", 10) and c.Zone:WaitForChild("Part", 10)
        if not zone then return warn"Couldn't find parts for Green Zone Tracer..." end
        
        newtracer(zone, "Zone", "Green Zone", onforeach ~= nil, options.TracerGZ)
    end
    tracers['Green Zone'] = {}
    insert(data.Functions, { stepper:Add(workspace.Disaster, "ChildAdded", "TracerGZ", trygz) })
    local gztracer = apply(defbutton:Clone(), {
        Parent = disholder,
        Name = 'TracerGZ'
    })
    gztracer.RealText.Text = "<font color="..red..">  Green Zone</font>"
    disdata.TracerGZ = {
        On = function()
            options.TracerGZ = true
            gztracer.Button.BackgroundColor3 = accent
            for i,v in next, tracers['Green Zone'] do v:SetVisible(true) end
            foreachin(disasters:GetChildren(), trygz)
        end,
        Off = function()
            options.TracerGZ = false
            gztracer.Button.BackgroundColor3 = dark
            for i,v in next, tracers['Green Zone'] do v:SetVisible(false) end
        end
    }
    gui:BindToggleClick(gztracer.Button, disdata.TracerGZ, options.TracerGZ)
    --local function 
    local function trynuke(c, onforeach)
        c = onforeach or c
        if tostring(c) ~= 'Nuclear Bomb' then return end
        local zone = c:WaitForChild("Point", 10)
        if not zone then return warn"Couldn't find parts for Nuclear Bomb Tracer..." end
        newtracer(zone, "Nuke", "Nuclear Bomb", onforeach ~= nil, options.TracerNuke)
    end
    tracers['Nuclear Bomb'] = {}
    insert(data.Functions, { stepper:Add(workspace.Disaster, "ChildAdded", "TracerNuke", trynuke) })
    local nuketracer = apply(defbutton:Clone(), {
        Parent = disholder,
        Name = 'TracerNuke'
    })
    nuketracer.RealText.Text = "<font color="..red..">  Nuclear Bomb</font>"
    disdata.TracerNuke = {
        On = function()
            options.TracerNuke = true
            nuketracer.Button.BackgroundColor3 = accent
            for i,v in next, tracers['Nuclear Bomb'] do v:SetVisible(true) end
            foreachin(disasters:GetChildren(), trynuke)
        end,
        Off = function()
            options.TracerNuke = false
            nuketracer.Button.BackgroundColor3 = dark
            for i,v in next, tracers['Nuclear Bomb'] do v:SetVisible(false) end
        end
    }
    gui:BindToggleClick(nuketracer.Button, disdata.TracerNuke, options.TracerNuke)
    
    local buttons = shareddata.Buttons or {}
    shareddata.Buttons = buttons
    
    tracers['Press The Button'] = {}
    local function tryptb(inst, onforeach)
        inst = onforeach or inst
        if inst:IsA"MeshPart" and inst.Name == 'Trigger' and inst:FindFirstAncestor('Press The Button') and not buttons[inst] then
            buttons[inst] = inst.AncestryChanged:Connect(function(whatchanged, towhere)
                if not towhere then rawset(buttons, inst, nil) end
            end)
            newtracer(inst, "Button", "Press The Button", onforeach ~= nil, options.TracerPTB) --in descendant loop because button path changes based on normal/hyper/imp
        end
    end
    
    
    local function addhumanoid(inst, onforeach)
        inst = onforeach or inst
        if not (inst:IsA"Humanoid" and inst.Health > 0 and not humanoids[inst]) then return end
        local a,b, dc
        dc = function(ancestor, towhere)
            if (not (ancestor and towhere)) then
                a:Disconnect()
                b:Disconnect()
                rawset(humanoids, inst, nil)
            end
        end
        a = inst.Died:Connect(dc)
        b = inst.AncestryChanged:Connect(dc)
        
        humanoids[inst] = dc --i rlly need to unify what is being assigned as a value
    end
    local function ondisasterdescendant(inst, onforeach)
        tryptb(inst,onforeach)
        addhumanoid(inst, onforeach)
    end
    insert(data.Functions, { stepper:Add(disasters, "DescendantAdded", "DisasterDescendantLogger", ondisasterdescendant) })
    foreachin(disasters:GetDescendants(), ondisasterdescendant)
    --[[local function tryptb(c, onforeach)
        c = onforeach or c
        if tostring(c) ~= 'Press The Button' then return end
        local curthread = running()
        
        c.AncestryChanged:Connect(function(partchanged, where)
            if where then return end
            if status(curthread) == 'suspended' then
                warn("Couldn't find parts for Press The Button tracer...")
                cancel(curthread)
                return
            end
        end)
        local zone = c:FindFirstChild("MeshPart", true)
        while c.Parent and not (tostring(zone) == "MeshPart" and zone:IsA"BasePart") do zone = c.DescendantAdded:Wait() end
        newtracer(zone, "Button", "Press The Button", onforeach ~= nil)
    end]]
    --insert(data.Functions, { stepper:Add(workspace.Disaster, "ChildAdded", "TracerPTB", tryptb) })
    
    local ptbtracer = apply(defbutton:Clone(), {
        Parent = disholder,
        Name = 'TracerPTB'
    })
    ptbtracer.RealText.Text = "<font color="..red..">  Press The Button</font>"
    disdata.TracerPTB = {
        On = function()
            options.TracerPTB = true
            ptbtracer.Button.BackgroundColor3 = accent
            for i,v in next, tracers['Press The Button'] do v:SetVisible(true) end
        end,
        Off = function()
            options.TracerPTB = false
            ptbtracer.Button.BackgroundColor3 = dark
            for i,v in next, tracers['Press The Button'] do v:SetVisible(false) end
        end
    }
    gui:BindToggleClick(ptbtracer.Button, disdata.TracerPTB, options.TracerPTB)
    
    tracers['Volcano'] = {}
    local volcanotracer = apply(defbutton:Clone(), {
        Parent = disholder,
        Name = 'TracerVolc'
    })
    local function tryvolc(c, onforeach)
        c = onforeach or c
        if tostring(c) ~= 'Volcano' then return end 
        local zone = c:WaitForChild("Volcano", 10) and c.Volcano:WaitForChild("Or", 10)
        if not zone then return warn"Couldn't find parts for Volcano Tracer..." end
        newtracer(zone, "Volcano", "Volcano", onforeach ~= nil, options.TracerVolc)
    end
    insert(data.Functions, { stepper:Add(workspace.Disaster, "ChildAdded", "TracerVolc", tryvolc) })
    volcanotracer.RealText.Text = "<font color="..red..">  Volcano</font>"
    disdata.TracerVolc = {
        On = function()
            options.TracerVolc = true
            volcanotracer.Button.BackgroundColor3 = accent
            for i,v in next, tracers['Volcano'] do v:SetVisible(true) end
            foreachin(disasters:GetChildren(), tryvolc)
        end,
        Off = function()
            options.TracerVolc = false
            volcanotracer.Button.BackgroundColor3 = dark
            for i,v in next, tracers['Volcano'] do v:SetVisible(false) end
        end
    }
    gui:BindToggleClick(volcanotracer.Button, disdata.TracerVolc, options.TracerVolc)
    
    local bbalign = apply(defbutton:Clone(), {
        Parent = disholder,
        Name = 'AlignerBB'
    })
    gui:MakePopup(apply(popupbox:Clone(), { Parent = bbalign }), apply(gui:DefaultPopup"Reveals the possible lanes in which a barrel can spawn", { BackgroundTransparency = settings.Looks.PopupTransparency, Size = UDim2.new(0,120,0,40) }), { FollowMouse = true })
    apply(bbalign.RealText, {
        Text = "<font color="..green..">  Barrel Boy</font>",
        Size = UDim2.new(1, -40, 0, 20) --upd for button
    })
    local defbarrellane = {
        Color = Color3.new(1,1,1),
        CanCollide = false,
        Size = Vector3.new(50,45,400),
        Material = "ForceField",
        CastShadow = false,
        Color = accent
        --Transparency = 0.9
    }
    local function applybb(point, onforeach)
        point = onforeach or point
        apply(point, defbarrellane)
        point.Position = point.Position * Vector3.new(1,1) --no z
        point.Transparency = options.AlignerBB and 0.9 or 1
    end
    local barrelpoints = {}
    local function addbb(c, onforeach)
        c = onforeach or c
        if tostring(c) ~= 'Barrel Boy' then return end
        local zone = c:WaitForChild("Points", 20)
        if not zone then return warn"Couldn't find parts for barrel boy aligner..." end
        
        local entry = barrelpoints[zone]
        if entry then
            stepper:Remove(unpack(entry.Con)) 
        else
            local c
            c = zone.AncestryChanged:Connect(function() c:Disconnect() rawset(barrelpoints, zone, nil) end)
        end
        
        local nextcon = { stepper:Add(zone, "ChildAdded", "AlignerBBAdd", applybb) }
        foreachin(zone:GetChildren(), applybb)
        
        entry = {
            Points = zone,
            Cons = nextcon
        }
        barrelpoints[zone] = entry
    end
    insert(data.Functions, { stepper:Add(workspace.Disaster, "ChildAdded", "AlignerBB", addbb) })
    foreachin(disasters:GetChildren(), addbb)
    disdata.AlignerBB = {
        On = function()
            options.AlignerBB = true
            bbalign.Button.BackgroundColor3 = accent
            for i,v in next, barrelpoints do for parent, point in next, v.Points:GetChildren() do point.Transparency = 0.9 end end
        end,
        Off = function()
            options.AlignerBB = false
            bbalign.Button.BackgroundColor3 = dark
            for i,v in next, barrelpoints do for parent, point in next, v.Points:GetChildren() do point.Transparency = 1 end end
        end
    }
    gui:BindToggleClick(bbalign.Button, disdata.AlignerBB, options.AlignerBB)
    
    
    local defcaterball = {
        Material = "ForceField",
        Shape = "Ball",
        Transparency = 0.75,
        CastShadow = false,
        Color = accent,
        Size = Vector3.new(80,80,80)
    }
    local function applycater(point, onforeach)
        point = onforeach or point
        apply(point, defcaterball)
        point.Transparency = options.AlignerCater and 0.75 or 1
    end
    local caterpoints = {}
    local function addcater(c, onforeach)
        c = onforeach or c
        if tostring(c) ~= 'Caterdriller' then return end
        local zone = c:WaitForChild("Nodes", 15)
        if not zone then return warn"Couldn't find parts for caterdriller aligner..." end
        
        local entry = caterpoints[zone]
        if entry then
            stepper:Remove(unpack(entry.Con)) 
        else
            local c
            c = zone.AncestryChanged:Connect(function() c:Disconnect() rawset(caterpoints, zone, nil) end)
        end
        
        local nextcon = { stepper:Add(zone, "ChildAdded", "AlignerCaterAdd", applycater) }
        foreachin(zone:GetChildren(), applycater)
        entry = {
            Points = zone,
            Cons = nextcon
        }
        caterpoints[zone] = entry
    end
    insert(data.Functions, { stepper:Add(workspace.Disaster, "ChildAdded", "AlignerCater", addcater) })
    foreachin(disasters:GetChildren(), addcater)
    local cateralign = apply(defbutton:Clone(), {
        Parent = disholder,
        Name = 'AlignerCater'
    })
    gui:MakePopup(apply(popupbox:Clone(), { Parent = cateralign }), apply(gui:DefaultPopup"Reveals the complete path of the current cater-jump", { BackgroundTransparency = settings.Looks.PopupTransparency, Size = UDim2.new(0,120,0,40) }), { FollowMouse = true })
    apply(cateralign.RealText, {
        Text = "<font color="..green..">  Caterdriller</font>",
        Size = UDim2.new(1, -40, 0, 20) --upd for button
    })
    disdata.AlignerCater = {
        On = function()
            options.AlignerCater = true
            cateralign.Button.BackgroundColor3 = accent
            for i,v in next, caterpoints do for parent, node in next, v.Points:GetChildren() do node.Transparency = 0.75 end end
        end,
        Off = function()
            options.AlignerCater = false
            cateralign.Button.BackgroundColor3 = dark
            for i,v in next, caterpoints do for parent, node in next, v.Points:GetChildren() do node.Transparency = 1 end end
        end
    }
    gui:BindToggleClick(cateralign.Button, disdata.AlignerCater, options.AlignerCater)
    
    --[[local kbalign = apply(defbutton:Clone(), {
        Parent = disholder,
        Name = 'AlignerKB'
    })
    gui:MakePopup(apply(popupbox:Clone(), { Parent = kbalign }), apply(gui:DefaultPopup"Draws the (possible) path of each killbot bullet", { BackgroundTransparency = settings.Looks.PopupTransparency, Size = UDim2.new(0,120,0,40) }), { FollowMouse = true })
    apply(kbalign.RealText, {
        Text = "<font color="..green..">  Killbots</font>",
        Size = UDim2.new(1, -40, 0, 20) --upd for button
    })
    disdata.AlignerKB = {
        On = function()
            options.AlignerKB = true
            kbalign.Button.BackgroundColor3 = accent
        end,
        Off = function()
            options.AlignerKB = false
            kbalign.Button.BackgroundColor3 = dark
        end
    }
    gui:BindToggleClick(kbalign.Button, disdata.AlignerKB, false)]]
    
    --[[local murdertracer = apply(defbutton:Clone(), {
        Parent = disholder,
        Name = 'TracerMurd'
    })
    gui:MakePopup(apply(popupbox:Clone(), { Parent = murdertracer }), apply(gui:DefaultPopup"Draws a tracer to any murderers actively targeting you", { Size = UDim2.new(0,120,0,40) }), { FollowMouse = true })
    apply(murdertracer.RealText, {
        Text = "<font color="..blue..">  Murderers</font>",
        Size = UDim2.new(1, -40, 0, 20) --upd for button
    })
    disdata.TracerMurd = {
        On = function()
            options.TracerMurd = true
            murdertracer.Button.BackgroundColor3 = accent
        end,
        Off = function()
            options.TracerMurd = false
            murdertracer.Button.BackgroundColor3 = dark
        end
    }
    gui:BindToggleClick(murdertracer.Button, disdata.TracerMurd, false)]]
end
menu_gameplay = gui:AddMenu("Gameplay", Color3.fromRGB(252, 132, 3))
do
    local maintab = gui:AddBasic("Frame", UDim2.new(0,187.5,0, 335), UDim2.new(0,10,0,10), menu_gameplay.Frame)
    local righttab = gui:AddBasic("Frame", UDim2.new(0,187.5,0, 275), UDim2.new(1,-197.5,0,85), menu_gameplay.Frame)
    local accent = menu_gameplay.Accent
    
    
    local colorkey = gui:AddBasic("Frame", UDim2.new(0,187.5,0,70), UDim2.new(1,-197.5,0,10), menu_gameplay.Frame)
    apply(gui:AddBasic("TextLabel", UDim2.new(0.95,0,1, -25), UDim2.new(0.05,0,0,25), colorkey), {TextSize = 12, BorderSizePixel = 0, TextXAlignment = "Left", TextYAlignment = "Top",
        Text = ("<font color=%s> Red</font> - Tracers<font color=%s>\nGreen</font> - Specialized\n<font color=%s>Blue</font> - Other"):format(red, green, blue)
    })
    section:Clone().Parent = colorkey
    
    local fdata = {}
    data.Functions.Gameplay = fdata
    apply(section:Clone(), {
        Parent = maintab,
        Text = "General"
    })
    
    local gendata = {}
    fdata.General = gendata
    local genholder = apply(gui:AddBasic("Frame", UDim2.new(0.9,0,0,80), UDim2.new(0.05,0,0,25), maintab), {
        Name = "General",
        BorderColor3 = Color3.new(1,1,1)
    })
    defuill:Clone().Parent = genholder
    
    local godmoder = apply(defbutton:Clone(), {
        Parent = genholder,
        Name = 'Godmode'
    })
    gui:MakePopup(apply(popupbox:Clone(), { Parent = godmoder }), apply(gui:DefaultPopup"Disables touches with the 3d world, preventing hit registers from many parts. Learn about network ownership to understand the extents of this function.", { BackgroundTransparency = settings.Looks.PopupTransparency, Size = UDim2.new(0,160,0,65) }), { FollowMouse = true })
    apply(godmoder.RealText, {
        Text = "<font color="..blue..">  Partial Godmode</font>",
        Size = UDim2.new(1, -40, 0, 20) --upd for button
    })
    local charpartlist = {}
    local function applygod(c, onforeach)
        c = onforeach or c
        if onforeach and not c:IsA"BasePart" then return end
        c.CanTouch = not options.Godmode
    end
    insert(data.Functions, { stepper:Add(lp, "CharacterAdded", "GodmodeAdd", function(char)
        local new = {}
        charpartlist = new
        local a,b
        a = char.ChildAdded:Connect(function(c)
            if c:IsA"BasePart" then insert(new, c) applygod(c) end
        end)
        foreachin(char:GetChildren(), applygod)
        b = char.AncestryChanged:Connect(function(changed, towhere) --just in case
            if towhere then return end
            a:Disconnect()
            b:Disconnect()
        end)
    end) })
    gendata.Godmode = {
        On = function()
            options.Godmode = true
            godmoder.Button.BackgroundColor3 = accent
            foreachin(charpartlist, applygod)
            if lp.Character then foreachin(lp.Character:GetChildren(), applygod) end
        end,
        Off = function()
            options.Godmode = false
            godmoder.Button.BackgroundColor3 = dark
            foreachin(charpartlist, applygod)
        end
    }
    gui:BindToggleClick(godmoder.Button, gendata.Godmode, options.Godmode)
    
    
    local touchparts = shareddata.Touchables or {}
    shareddata.Touchables = touchparts
    
    local function registertouchpart(inst)
        if not (inst:IsA"TouchTransmitter" and not touchparts[inst]) then
            return
        end
        inst = inst.Parent
        local c
        c = inst.AncestryChanged:Connect(function(ancestorchanged, newparent)
            if not newparent then rawset(touchparts, inst, nil) c:Disconnect() end
        end)
        touchparts[inst] = c
    end
    insert(data.Functions, { stepper:Add(workspace, "DescendantAdded", "OnTouchInterest", registertouchpart) })
    local function firetouches(optreciever)
        local ctr = 0
        for part, con in next, touchparts do
            touch(part, optreciever)
            ctr = ctr + 1
        end
        return ctr
    end
    options.TouchReciever = lp --default
    local touchbuttonframe = apply(gui:AddBasic("Frame", UDim2.new(0,150,0,50), UDim2.new(0,0,1,-200), gui.Gui), {
        Name = "TouchButton",
        Visible = false
    })
    local touchbuttonchoice = apply(gui:AddBasic("TextBox", UDim2.new(1,0,0.5), nil, touchbuttonframe), {
        Text = tostring(lp),
        PlaceholderText = tostring(lp),
        BackgroundColor3 = dark
    })
    local touchbutton = apply(gui:AddBasic("TextButton", UDim2.new(1,0,0.5), UDim2.new(0,0,0.5), touchbuttonframe), {
        Text = "Fire",
        TextColor3 = accent
    })
    touchbuttonchoice.FocusLost:Connect(function()
        local plr = plrfromstr(touchbuttonchoice.Text) or options.TouchReciever
        local name = tostring(plr)
        options.TouchReciever = plr
        touchbuttonchoice.Text, touchbuttonchoice.PlaceholderText = name, name
    end)
    local lastrun
    touchbutton.MouseButton1Click:Connect(function()
        local numtouched = firetouches(options.TouchReciever)
        if lastrun and status(lastrun) == 'suspended' then cancel(lastrun) end
        touchbutton.Text = "Fired "..numtouched
        lastrun = delay(5, function()
            touchbutton.Text = "Fire"
        end)
    end)
    
    
    for i,v in next, workspace:GetDescendants() do registertouchpart(v) end --lol before foreachin
    
    local parttoucher = apply(defbutton:Clone(), {
        Parent = genholder,
        Name = 'PartToucher',
        Size = UDim2.new(1,0,0,40)
    })
    apply(parttoucher.RealText, {
        Text = "<font color="..blue..">  Part Toucher</font>",
        Size = UDim2.new(1, -40, 0, 20) --upd for button
    })
    gendata.PartToucher = {
        On = function()
            options.PartToucher = true
            parttoucher.Button.BackgroundColor3 = accent
            touchbuttonframe.Visible = options.PartToucherMode ~= "Keybind"
        end,
        Off = function()
            options.PartToucher = false
            parttoucher.Button.BackgroundColor3 = dark
            
            touchbuttonframe.Visible = false
        end
    }
    registerkeybind({
        Info = "Gameplay >> PartToucher",
        Key = "T",
        Ctrl = true,
        Alt = false,
        Repetitions = 1
    }, function()
        if not options.PartToucher then return end
        firetouches(options.TouchReciever)
    end, true)
    gui:MakePopup(apply(popupbox:Clone(), { Parent = parttoucher }), apply(gui:DefaultPopup("Will fake a touch with every\npart currently in-game. Basically only useful for looting.\n\nCurrent Keybind:\n "..(keybinds["Gameplay >> PartToucher"] and keybinds["Gameplay >> PartToucher"].Format or "NONE")), { BackgroundTransparency = settings.Looks.PopupTransparency, Size = UDim2.new(0,160,0,75) }), { FollowMouse = true })
    gui:BindToggleClick(parttoucher.Button, gendata.PartToucher, options.PartToucher)
    gui:AddRadioButtons(
        {Parent = parttoucher, Position = UDim2.new(0,21,0,21), Size = UDim2.new(1,-21,0,20)},
        {Size = UDim2.new(0.5,0,0,20), StartsFrom = nil, Background = medium, Default = options.PartToucherModeIndex or 1, RightSide = false, TextSize = 11, SortingOpt = apply(Instance.new"UIGridLayout", { SortOrder = "LayoutOrder", CellSize = UDim2.new(0.5,0,0,20), CellPadding = UDim2.new()})},
        {
            "Keybind",
            "Button"
        },
        function(t, index)
            options.PartToucherModeIndex = index
            options.PartToucherMode = t
            touchbuttonframe.Visible = options.PartToucher and t ~= 'Keybind'
        end)
    
    --
    local orbgui = apply(Instance.new"TextButton", {
        Name = "Button",
        Size = UDim2.new(1,0,1,0),
        Text = "",
        Parent = apply(Instance.new"BillboardGui", {
            Size = UDim2.new(0,30,0,30),
            AlwaysOnTop = true,
            Active = true,
            Enabled = false
        })
    }).Parent
    apply(Instance.new"UICorner", {
        Parent = orbgui.Button,
        CornerRadius = UDim.new(1)
    })
    apply(Instance.new"UIStroke", {
        Parent = orbgui.Button,
        ApplyStrokeMode = "Border",
    })
    local orbfolder = apply(Instance.new"Folder", {
        Name = "OtherBillboards",
        Parent = gui.Gui
    })
    local orbs = shareddata.OrbBillboards or {}
    shareddata.OrbBillboards = orbs
    local function addorb(orb, onforeach)
        orb = onforeach or orb
        if not (tostring(orb):find"^Orb_" and orb:IsA"BasePart") then
            return
        elseif not orbs[orb] then
            orb.AncestryChanged:Connect(function(f,where)
                orbs[orb]:Destroy() --because relaunches need to create new orbs but not new reparent connections
            end)
        end
        local new = orbgui:Clone()
        new.Button.MouseButton1Click:Connect(function()
            touch(orb)
        end)
        
        new.Enabled, new.Button.BackgroundColor3 = data.Options.OrbTracker, orb.Color
        new.Adornee, new.Parent = orb, orbfolder
        orbs[orb] = new
        return new
    end
    insert(data.Functions, { stepper:Add(workspace, "ChildAdded", "OrbTracker", addorb, nil, true) }) --nil delay, true to defer (ancestrychanged fires too early w/o)
    foreachin(workspace:GetChildren(), addorb)
    local orbtracker = apply(defbutton:Clone(), {
        Parent = genholder,
        Name = 'OrbTracker'
    })
    gui:MakePopup(apply(popupbox:Clone(), { Parent = orbtracker }), apply(gui:DefaultPopup"Reveals orb drops from bosses through walls.", { BackgroundTransparency = settings.Looks.PopupTransparency, Size = UDim2.new(0,140,0,30) }), { FollowMouse = true })
    apply(orbtracker.RealText, {
        Text = "<font color="..blue..">  Orb-tracking</font>",
        Size = UDim2.new(1, -40, 0, 20) --upd for button
    })
    gendata.OrbTracker = {
        On = function()
            options.OrbTracker = true
            orbtracker.Button.BackgroundColor3 = accent
            for i,v in next, orbs do v.Enabled = true end
        end,
        Off = function()
            options.OrbTracker = false
            orbtracker.Button.BackgroundColor3 = dark
            for i,v in next, orbs do v.Enabled = false end
        end
    }
    gui:BindToggleClick(orbtracker.Button, gendata.OrbTracker, options.OrbTracker)
    
    local physdata = {}
    fdata.Physics = physdata
    apply(section:Clone(), {
        Parent = maintab,
        Text = "Physics Modification",
        Position = UDim2.new(0.05,0,0,110),
        Size = UDim2.new(0.8,0,0,20)
    })
    local physholder = apply(gui:AddBasic("Frame", UDim2.new(0.9,0,0,40), UDim2.new(0.05,0,0,135), maintab), {
        Name = "Physics Modification",
        BorderColor3 = Color3.new(1,1,1)
    })
    defuill:Clone().Parent = physholder
    insert(data.Functions, { stepper:Add(game.RunService, "RenderStepped", "SimulationRadiusChanger", function()
        local radius = options.SimRadiusLockTo or 0
        if radius == 0 then
            return
        elseif gethiddenproperty(lp, "SimulationRadius") ~= radius then
            sethiddenproperty(lp, "SimulationRadius", radius)
        end
        if options.SimRadiusDragOthers then
            for i,v in next, players:GetPlayers() do
                if v ~= lp and gethiddenproperty(v, "SimulationRadius") ~= 0 then
                    sethiddenproperty(v, "SimulationRadius", 0)
                end
            end
        end
    end) })
    local lastsimradshown
    local rbxphyssettings = rbxsettings.Physics
    local function offsimrad() rbxphyssettings.AreRegionsShown = false end
    local firstrundebounce = false
    defer(function() firstrundebounce = true end)
    local simraddragbar = gui:AddDragbar(
      { --main
        Size = UDim2.new(1,0,0,20),
        Parent = physholder,
        Position = nil, --ui ll
        NoCode = false,
        Text = "SimRadius Lock",
        OverlayColor = Color3.new(1,1,1),
        InvertScrolling = true,
        Border = 1
      }, { --number indicator
        Type = "TextLabel",
        RightSide = false,
        Size = UDim2.new(0,30,0,20),
        TextSize = 10
      }, { --range
        Default = options.SimRadiusLockTo or 0,
        Min = 0,
        Max = 1000,
        Step = 25
      }, {
        OnChange = function(newval, self)
            self.Indicator.Text = "<font color="..blue..">"..(newval == 0 and "OFF" or newval == 1000 and "MAX" or newval).."</font>"
            options.SimRadiusLockTo = newval -- 0 = off
            if lastsimradshown and status(lastsimradshown) == 'suspended' then cancel(lastsimradshown) end
            rbxphyssettings.AreRegionsShown = firstrundebounce
            lastsimradshown = delay(1, offsimrad)
        end
    })
    simraddragbar.TextOverlay.TextSize = 12
    gui:MakePopup( simraddragbar.Indicator, apply(gui:DefaultPopup("Affects the area around your character where you control part physics. Having this set higher will help with physics-based exploits, but can cause performance lag.\n\nWhen off, roblox fluctuates this value to avoid frame-drops."), { BackgroundTransparency = settings.Looks.PopupTransparency, Size = UDim2.new(0,200,0,90) }), { FollowMouse = true, MouseOffset = Vector2.new(-205,-95) })
    
    local simraddragothers = apply(defbutton:Clone(), {
        Parent = physholder,
        Name = 'SimRadiusDragOthers',
        Position = UDim2.new(0,30,0,0)
    })
    apply(simraddragothers.RealText, {
        Text = "<font color="..blue..">  Lower Others' Radius</font>",
        TextSize = 13,
        Size = UDim2.new(1, -20, 0, 20) --upd for button
    })
    physdata.SimRadiusDragOthers = {
        On = function()
            options.SimRadiusDragOthers = true
            simraddragothers.Button.BackgroundColor3 = accent
        end,
        Off = function()
            options.SimRadiusDragOthers = false
            simraddragothers.Button.BackgroundColor3 = dark
        end
    }
    gui:BindToggleClick(simraddragothers.Button, physdata.SimRadiusDragOthers, options.SimRadiusDragOthers)
    
    local demobheader = apply(section:Clone(), {
        Parent = maintab,
        Text = "Demobilization",
        Position = UDim2.new(0.05,0,0,180),
        Size = UDim2.new(0.65,0,0,20)
    })

    local demobdata = {}
    fdata.Demobilization = demobdata
    local demobholder = apply(gui:AddBasic("Frame", UDim2.new(0.9,0,0,120), UDim2.new(0.05,0,0,205), maintab), {
        Name = "Demobilization",
        --BorderColor3 = Color3.new(1,1,1)
    })
    defuill:Clone().Parent = demobholder
    gui:MakePopup(apply(popupbox:Clone(), { Parent = demobheader }), apply(gui:DefaultPopup("Demobilizes NPCs/mobs in humanoid disasters. Requires network ownership to work.\n\n*Cloak will follow your mouse if\nthere are no other players in the server."), { BackgroundTransparency = settings.Looks.PopupTransparency, Size = UDim2.new(0,200,0,90) }), { FollowMouse = true })
    
    --put me (below) in my own section
    local demobilizerdata = shareddata.DemobilizerCache or {}
    shareddata.DemobilizerCache = demobilizerdata
    
    local demobilizerfuncs = {}
    demobilizerfuncs.Sit = {
        [true] = function(hum, root) hum.Sit = true end,
        [false] = function(hum, root) hum.Sit = false end
    }
    demobilizerfuncs.Freeze = {
        [true] = function(hum, root) hum.PlatformStand = true root.Anchored = true end,
        [false] = function(hum, root) hum.PlatformStand = false root.Anchored = false end
    }
    demobilizerfuncs.Fling = {
        [true] = function(hum, root)
            hum.PlatformStand = true
            if root.RotVelocity.Magnitude < 50 then
                root.Velocity = randomvector(Vector3.new(400,800,400))
                root.RotVelocity = randomvector(200)
            end
        end,
        [false] = function(hum, root)
            hum.PlatformStand = false
        end
    }
    --local masscache = {} --nvm bc of desync replication (rip processing speed)
    local gravcache = {}
    local gravity = workspace.Gravity
    demobilizerfuncs.AntiGrav = {
        [true] = function(hum, root)
            local cached = gravcache[root]
            if (cached) then
                if cached:IsDescendantOf(workspace) then return end
            else
                hum.AncestryChanged:Connect(function(v)
                    rawset(gravcache, root, nil)
                end)
            end
            hum.PlatformStand = true
            for i,v in next, hum.Parent:GetDescendants() do if v:IsA"BodyForce" then v:Destroy() end end
            local bf = Instance.new"BodyForce"
            bf.Force = Vector3.new(0, getmassof(root) * gravity) --doesnt account for other bodyforces ex coil noobs xd dnc
            gravcache[root] = bf
            bf.Parent = root
            root.Velocity, root.RotVelocity = root.Velocity + randomvector(5), root.RotVelocity +  randomvector(5)
        end,
        [false] = function(hum, root)
            local cached = gravcache[root]
            if cached and cached.Parent then cached:Destroy() end
            hum.PlatformStand = false
        end
    }
    demobilizerfuncs.Cloak = {
        [true] = function(hum, root)
            local closest, me = getclosestplayerfrompoint(root.Position)
            if closest ~= me then
                hum:MoveTo(closest)
            else
                hum:MoveTo(mouse.Hit.p)
            end
        end,
        [false] = function() end
    }
    local function doremove(root)
        root.CFrame = CFrame.new(Vector3.new(0,-125,0), Vector3.new(0,-1000,0))
        root.Velocity = Vector3.new(0,-100,0)
        root.RotVelocity = Vector3.zero
    end
    demobilizerfuncs.Remove = {
        [true] = function(hum, root)
            hum.PlatformStand = true
            if root.Position.Y <= -125 then return end
            defer(doremove, root) 
        end,
        [false] = function(hum, root)
            hum.PlatformStand = false
        end
    }
    local demobtracers = {}
    tracers['Demobilizer'] = demobtracers
    
    local movedirs = {
        [Enum.KeyCode.W] = function(cframe)
            return cframe.LookVector
        end,
        [Enum.KeyCode.A] = function(cframe)
            return -cframe.RightVector
        end,
        [Enum.KeyCode.S] = function(cframe)
            return -cframe.LookVector
        end,
        [Enum.KeyCode.D] = function(cframe)
            return cframe.RightVector
        end
    }
    local spacebar = Enum.KeyCode.Space
    local vzero, vone = Vector3.zero, Vector3.one
    insert(data.Functions, { stepper:Add(game.RunService, "Stepped", "Demobilizer", function()
        local me = gethum()
        if not me then return elseif options.OverrideMovement then
            me.WalkSpeed = options.PreferredWalkSpeed
            me.JumpPower = options.PreferredJumpPower
        end
        local flying = options.Fly
        if options.Fly then
            local lastgyro, lastfly = shareddata.FlyRotateInst, shareddata.FlyInst
            if lastgyro then lastgyro.CFrame = cc.CFrame end
            if lastfly then
                local finalvel, relcframe = vzero, cc.CFrame
                local speed = options.FlySpeed or 50
                for i,v in next, inputservice:GetKeysPressed() do
                    local validmove = movedirs[v.KeyCode]
                    if validmove then finalvel = finalvel + validmove(relcframe) end
                end
                finalvel = finalvel.Magnitude ~= 0 and (finalvel.Unit * speed) or vzero
                if inputservice:IsKeyDown(spacebar) then
                    finalvel = finalvel + Vector3.new(0,speed/2 * (isctrling() and -1 or 1))
                end
                lastfly.Velocity = finalvel
                
            end
            me.PlatformStand = true
        end
        local char = lp.Character
        if char:FindFirstChild"Head" then char.Head.CanCollide = not flying end
        if char:FindFirstChild"Torso" then char.Torso.CanCollide = not flying end
        
        me = me.RootPart
        
        if not (me and options.Demobilizer) then return end
        for humanoid, disable in next, humanoids do
            local rootpart = humanoid.RootPart
            if not rootpart then continue end
            
            local maxdist = options.DemobilizationRadius
            
            
            local tracer = newtracer(rootpart, "", "Demobilizer", true, false, {Color = accent, Method = "2D"}) --will return old cached tracer so this is ok
            if not (isnetworkowner(rootpart) and (maxdist == 200 or (rootpart.Position - me.Position).Magnitude <= maxdist)) then
                tracer:SetVisible(false)
                demobilizerfuncs[options.DemobilizerMode][false](humanoid, rootpart)
                continue
            end
            
            tracer:SetVisible(options.DemobVisualTargets)
            demobilizerfuncs[options.DemobilizerMode][true](humanoid, rootpart)
        end
    end, 0) }) --maybe add a delay? hmm
    
    local lastorb = shareddata.DemobRangeVisualizer --used after this section
    
    
    local simraddragbar = gui:AddDragbar(
      { --main
        Size = UDim2.new(1,0,0,20),
        Parent = demobholder,
        Position = nil, --ui ll
        NoCode = false,
        Text = "Activation Radius",
        OverlayColor = Color3.new(1,1,1),
        InvertScrolling = true,
        Border = 1
      }, { --number indicator
        Type = "TextLabel",
        RightSide = false,
        Size = UDim2.new(0,30,0,20),
        TextSize = 10
      }, { --range
        Default = options.DemobilizationRadius or 0,
        Min = 0,
        Max = 200,
        Step = 5
      }, {
        OnChange = function(newval, self)
            self.Indicator.Text = "<font color="..green..">"..(newval == 0 and "OFF" or newval == 200 and "ALL" or newval).."</font>"
            options.DemobilizationRadius = newval -- 0 = off
            if newval == 0 then
                options.Demobilizer = false
                for i,v in next, demobilizerfuncs do
                    for humanoid, disable in next, humanoids do
                        local rootpart = humanoid.RootPart
                        if not (rootpart and isnetworkowner(rootpart)) then continue end
                        v[false](humanoid, rootpart)
                    end
                end
                if lastorb then lastorb.Size = Vector3.zero end
            else
                options.Demobilizer = true
                if lastorb then
                    lastorb.Size = (options.DemobVisualRange and newval ~= 200) and Vector3.one * (2 * newval) or Vector3.zero
                end
            end
        end
    })
    simraddragbar.TextOverlay.TextSize = 12
    --oops
    apply(gui:AddBasic("Frame", UDim2.new(0,0,0,60), nil, demobholder), {Name = "(oops)", BackgroundTransparency = 1})
    --
    --gui:MakePopup( simraddragbar.Indicator, apply(gui:DefaultPopup("The map is 400x300x400 studs."), { BackgroundTransparency = settings.Looks.PopupTransparency, Size = UDim2.new(0,200,0,90) }), { FollowMouse = true, MouseOffset = Vector2.new(-205,-95) })
    gui:AddRadioButtons(
        {Parent = simraddragbar, Position = UDim2.new(0,21,0,21), Size = UDim2.new(1,-21,0,60)},
        {Size = UDim2.new(0.5,0,0,20), StartsFrom = nil, Background = medium, Default = options.DemobilizerModeIndex or 1, RightSide = false, TextSize = 11, SortingOpt = apply(Instance.new"UIGridLayout", { SortOrder = "LayoutOrder", CellSize = UDim2.new(0.5,0,0,20), CellPadding = UDim2.new()})},
        {
            "Sit",
            "Freeze",
            "Fling",
            "AntiGrav",
            "Cloak",
            "Remove"
        },
        function(t, index)
            options.DemobilizerModeIndex = index
            options.DemobilizerMode = t
            for i,v in next, demobilizerfuncs do
                for humanoid, disable in next, humanoids do
                    local rootpart = humanoid.RootPart
                    if not (rootpart and isnetworkowner(rootpart)) then continue end
                    v[false](humanoid, rootpart)
                end
            end
        end)
    
    local baseorb = apply(Instance.new"Part", {
        Massless = true,
        Material = "ForceField",
        CanCollide = false,
        Transparency = 0.4, --0.4
        Color = accent,
        CastShadow = false,
        Shape = "Ball",
        Name = "RangeBall"
    })
    
    local function orbonnewchar(char)
        if not char then return end
        local root
        while not root and char.Parent do root = char:WaitForChild("HumanoidRootPart", 5) end
        if not char.Parent then
            return
        elseif lastorb and lastorb.Parent then
            lastorb:Destroy()
        end
        
        lastorb = baseorb:Clone()
        lastorb.Size = (options.DemobRangeViusalizer and options.DemobilizationRadius ~= 200) and Vector3.one * (2 * options.DemobilizationRadius) or Vector3.zero
        
        local w = Instance.new"Weld"
        w.Part0 = root
        w.Part1 = lastorb
        w.Parent = lastorb
        
        shareddata.DemobRangeVisualizer = lastorb
        lastorb.Parent = tracerfolder3d
    end
    insert(data.Functions, { stepper:Add(lp, "CharacterAdded", "VisualizeDemobRangeOrb", orbonnewchar) })
    spawn(orbonnewchar,lp.Character)
    local demobvisualizerange = apply(defbutton:Clone(), {
        Parent = demobholder,
        Name = 'DemobVisualRange',
        Position = UDim2.new(0,30,0,0)
    })
      
    apply(demobvisualizerange.RealText, {
        Text = "<font color="..blue..">  Visualize Range</font>",
        TextSize = 13,
        Size = UDim2.new(1, -20, 0, 20) --upd for button
    })
    demobdata.DemobVisualRange = {
        On = function()
            options.DemobVisualRange = true
            demobvisualizerange.Button.BackgroundColor3 = accent
            if lastorb then lastorb.Size = Vector3.one * (2 * options.DemobilizationRadius) end
        end,
        Off = function()
            options.DemobVisualRange = false
            demobvisualizerange.Button.BackgroundColor3 = dark
            if lastorb then lastorb.Size =  Vector3.zero end
        end
    }
    gui:BindToggleClick(demobvisualizerange.Button, demobdata.DemobVisualRange, options.DemobVisualRange)
    
    local demobvisualizetargets = apply(defbutton:Clone(), {
        Parent = demobholder,
        Name = 'DemobVisualTargets',
        Position = UDim2.new(0,30,0,0)
    })
    gui:MakePopup(apply(popupbox:Clone(), { Parent = demobvisualizetargets }), apply(gui:DefaultPopup"May cause lag if many humanoids are present.", { BackgroundTransparency = settings.Looks.PopupTransparency, Size = UDim2.new(0,120,0,40) }), { FollowMouse = true })
      
    apply(demobvisualizetargets.RealText, {
        Text = "<font color="..red..">  Visualize Targets</font>",
        TextSize = 13,
        Size = UDim2.new(1, -20, 0, 20) --upd for button
    })
    demobdata.DemobVisualTargets = {
        On = function()
            options.DemobVisualTargets = true
            demobvisualizetargets.Button.BackgroundColor3 = accent
            for i,v in next, tracers['Demobilizer'] do v:SetVisible(true) end
        end,
        Off = function()
            options.DemobVisualTargets = false
            demobvisualizetargets.Button.BackgroundColor3 = dark
            for i,v in next, tracers['Demobilizer'] do v:SetVisible(false) end
        end
    }
    gui:BindToggleClick(demobvisualizetargets.Button, demobdata.DemobVisualTargets, options.DemobVisualTargets)
    
    
    local movedata = {}
    fdata.Movement = movedata
    apply(section:Clone(), {
        Parent = righttab,
        Text = "Movement"
    })
    
    local moveholder = apply(gui:AddBasic("Frame", UDim2.new(0.9,0,0,120), UDim2.new(0.05,0,0,25), righttab), {
        Name = "Movement",
        BorderColor3 = Color3.new(1,1,1)
    })
    defuill:Clone().Parent = moveholder
    
    local overridemovement = apply(defbutton:Clone(), {
        Parent = moveholder,
        Name = 'OverrideMovement',
        Position = UDim2.new(0,30,0,0)
    })
    apply(overridemovement.RealText, {
        Text = "<font color="..blue..">  Override Movement</font>",
        TextSize = 13,
        Size = UDim2.new(1, -20, 0, 20) --upd for button
    })
    movedata.OverrideMovement = {
        On = function()
            options.OverrideMovement = true
            overridemovement.Button.BackgroundColor3 = accent
            
            local hum = gethum()
            if hum then hum.WalkSpeed, hum.JumpPower = 16, 50 end
        end,
        Off = function()
            options.OverrideMovement = false
            overridemovement.Button.BackgroundColor3 = dark
            
            local hum = gethum()
            if hum then hum.WalkSpeed, hum.JumpPower = 16, 50 end
        end
    }
    gui:BindToggleClick(overridemovement.Button, movedata.OverrideMovement, options.OverrideMovement)
    
    local movespeeddragbar = gui:AddDragbar(
      { --main
        Size = UDim2.new(1,0,0,20),
        Parent = moveholder,
        Position = nil, --ui ll
        NoCode = false,
        Text = "Walkspeed",
        OverlayColor = Color3.new(1,1,1),
        InvertScrolling = true,
        Border = 1
      }, { --number indicator
        Type = "TextBox",
        RightSide = false,
        Size = UDim2.new(0,30,0,20),
        TextSize = 10
      }, { --range
        Default = options.PreferredWalkSpeed or 16,
        Min = 16,
        Max = 220,
        Step = 1
      }, {
        OnChange = function(newval, self)
            options.PreferredWalkSpeed = newval
        end
    })
    movespeeddragbar.Indicator.TextColor3 = gui:GetThemeColor"Accent"
    movespeeddragbar.TextOverlay.TextSize = 12
    local jumppowerdragbar = gui:AddDragbar(
      { --main
        Size = UDim2.new(1,0,0,20),
        Parent = moveholder,
        Position = nil, --ui ll
        NoCode = false,
        Text = "JumpPower",
        OverlayColor = Color3.new(1,1,1),
        InvertScrolling = true,
        Border = 1
      }, { --number indicator
        Type = "TextBox",
        RightSide = false,
        Size = UDim2.new(0,30,0,20),
        TextSize = 10
      }, { --range
        Default = options.PreferredJumpPower or 50,
        Min = 50,
        Max = 160,
        Step = 1
      }, {
        OnChange = function(newval, self)
            options.PreferredJumpPower = newval
        end
    })
    jumppowerdragbar.Indicator.TextColor3 = gui:GetThemeColor"Accent"
    jumppowerdragbar.TextOverlay.TextSize = 12
    
    local basefly, basegyro = apply(Instance.new"BodyVelocity", { MaxForce = Vector3.one * 400000, Velocity = Vector3.zero }), apply(Instance.new"BodyGyro", { MaxTorque = Vector3.one * 4e6, P = 50000 })
    local lastfly = shareddata.FlyInst
    local lastgyro = shareddata.FlyRotateInst
    local function dofly(char)
        if lastfly and lastfly.Parent then lastfly:Destroy() lastfly = nil end
        if lastgyro and lastorb.Parent then lastgyro:Destroy() lastgyro = nil end
        if not (options.Fly and char) then
            local hum = gethum()
            if hum then hum.PlatformStand = false end
            if hum.RootPart then hum.RootPart.CFrame = CFrame.new(hum.RootPart.Position) end --fixes stumble when facing toof ar up/down
            return
        end
        local root
        while not root and char.Parent do root = char:WaitForChild("HumanoidRootPart", 5) end
        if not char.Parent then return end
        lastfly = basefly:Clone()
        lastgyro = basegyro:Clone()
        
        shareddata.FlyInst = lastfly
        shareddata.FlyRotateInst = lastgyro
        
        lastgyro.Parent = root
        lastfly.Parent = root
    end
    insert(data.Functions, { stepper:Add(lp, "CharacterAdded", "NewFlyInstance", dofly) })
    
    local flyspeeddragbar = gui:AddDragbar(
      { --main
        Size = UDim2.new(1,0,0,20),
        Parent = moveholder,
        Position = nil, --ui ll
        NoCode = false,
        Text = "Fly",
        OverlayColor = Color3.new(1,1,1),
        InvertScrolling = true,
        Border = 1
      }, { --number indicator
        Type = "TextLabel",
        RightSide = false,
        Size = UDim2.new(0,30,0,20),
        TextSize = 10
      }, { --range
        Default = options.FlySpeed or 0,
        Min = 50,
        Max = 250,
        Step = 5
      }, {
        OnChange = function(newval, self)
            self.Indicator.Text = "<font color="..green..">"..newval.."</font>"
            options.FlySpeed = newval -- 0 = off
            --options.Fly = newval ~= 0
            --dofly(lp.Character)
        end
    })
    registerkeybind({
        Info = "Gameplay >> Fly",
        Key = "Space",
        Ctrl = false,
        Alt = false,
        Repetitions = 3
    }, function() options.Fly = not options.Fly dofly(lp.Character) end, true) --true overwrites old
    gui:MakePopup( flyspeeddragbar.Indicator, apply(gui:DefaultPopup("Keybind-only.\n\nCurrent Keybind:\n"..(keybinds["Gameplay >> Fly"] and keybinds["Gameplay >> Fly"].Format or "NONE")), { BackgroundTransparency = settings.Looks.PopupTransparency, Size = UDim2.new(0,160,0,50) }), { FollowMouse = true })
        
end
registerkeybind({
    Info = "ToggleMenuVisiblity",
    Key = "Semicolon",
    Ctrl = true,
    Alt = true,
    Repetitions = 1
}, function()
    gui.Gui.Enabled = not gui.Gui.Enabled
    --[[if options.Minimapper then
        if gui.Gui.Enabled then minimap:Start() else minimap:Stop() end
    end]] --later in panic 
end, true)
gui:Enable()