local lp = game.Players.LocalPlayer
local tracer = {}
tracer.__index = tracer
function tracer.new(pos1, pos2)
    local new = setmetatable({
        Target = pos2 or pos1,
        Root = not pos2 and lp or pos1,
        Method = "3D",
        Color = Color3.new(1),
        Components = {},
        Visible = false,
        Name = "Tracer"
    }, tracer)
    new:SetMethod"3D" --recommended
    return new
end
local char, random = string.char, math.random
local function rand(len)
    local result = ""
    for i = 1, len do result = result..char(random(0,255)) end
    return result
end
local function hasprop(inst, prop, pcd)
    return pcd and inst[prop] or pcall(hasprop, inst, prop, true)
end
local function apply(inst, props)
    local parent = props.Parent
    props.Parent = nil
    for i,v in next, props do
        if hasprop(inst, i) then
            inst[i] = v
        end
    end
    if parent then inst.Parent = parent end
    return inst
end
local def3d, def2d = {}, {}
do
    def3d.Line = apply(Instance.new"Part", {
        Anchored = true,
        Size = Vector3.new(0.6,0.6,5),
        Transparency = 1, --0.6,
        Color = Color3.new(1),
        CanCollide = false,
        TopSurface = "Smooth",
        BottomSurface = "Smooth",
        Material = "Neon"
    })
    def3d.Text = apply(Instance.new("TextLabel"), {
        Name = "Container",
        Text = "Tracer",
        BackgroundTransparency = 1,
        TextColor3 = Color3.new(1),
        TextStrokeTransparency = 0,
        TextSize = 32,
        Font = 18,
        Size = UDim2.new(1,0,1),
        Parent = apply(Instance.new"BillboardGui", {
            Enabled = false,
            ExtentsOffsetWorldSpace = Vector3.new(0,0,-1),
            AlwaysOnTop = true,
            Size = UDim2.new(0,150,0,150),
            MaxDistance = 1/0
        })  
    }).Parent
    
    def2d.Node1 = apply(Drawing.new("Circle"), {
        Color = Color3.new(1),
        Thickness = 2,
        Radius = 3,
        Filled = false,
        Position = Vector2.new(450,450)
    })
    def2d.Node2 = def2d.Node1
    def2d.Line = apply(Drawing.new("Line"), {
        Color = Color3.new(1),
        Thickness = 2,
    })
    def2d.Text = apply(Drawing.new"Text", {
        Text = "Tracer",
        Size = 32,
        Center = false,
        Outline = true,
        OutlineColor = Color3.new(),
        Color = Color3.new(1),
        Position = Vector2.new(500,400),
    })
end

--[[
do stuff like turn part red, transparent, gui clear except text etc
]]
function tracer:SetMethod(method)
    method = assert(typeof(method) == 'string', "Expected string for method SetMethod()") and method:upper()
    assert(method == "3D" or method == "2D", "Invalid method given: "..method)
    --if (self.Method == method) then return end
    pcall(tracer.Destroy, self)
    self.Method = method
    if method == "3D" then
        self.Components = {
            Line = apply(def3d.Line:Clone(), {Name = rand(5) }),
            Text = apply(def3d.Text:Clone(), { Name = rand(5) })
        }
        self.Components.Text.Parent = self.Components.Line
    else
        self.Components = {
            Node1 = apply(Drawing.new("Circle"), {
                Color = Color3.new(1),
                Thickness = 2,
                Radius = 3,
                Filled = false,
                Position = Vector2.new(450,450),
                Visible = false
            }),
            Node2 = apply(Drawing.new("Circle"), {
                Color = Color3.new(1),
                Thickness = 2,
                Radius = 3,
                Filled = false,
                Position = Vector2.new(450,450),
                Visible = false
            }),
            Line = apply(Drawing.new("Line"), {
                Color = Color3.new(1),
                Thickness = 2,
            }),
            Text = apply(Drawing.new"Text", {
                Text = "Tracer",
                Size = 32,
                Center = true,
                Outline = true,
                OutlineColor = Color3.new(),
                Color = Color3.new(1),
                Position = Vector2.new(500,400),
            })
        }
    end
end
function tracer:Destroy()
    local comps = self.Components
    if self.Method == '3D' then
        comps.Line:Destroy()
        comps.Text:Destroy()
    else
        comps.Line:Remove()
        comps.Text:Remove()
        comps.Node1:Remove()
        comps.Node2:Remove()
    end
    self.Components = {}
end
function tracer:SetText(n)
    local comps = self.Components
    local msg = tostring(n)
    if self.Method == '3D' then
        comps.Text.Label.Text = msg
    else
        comps.Text.Text = msg
    end
    self.Text = msg
end
function tracer:SetVisible(state)
    local comps = self.Components
    if self.Method == '3D' then
        comps.Line.Transparency = state and 0.6 or 1
        comps.Text.Enabled = state
    else
        for i,v in next, comps do v.Visible = state end 
    end
    self.Visible = state
end
function tracer:SetColor(c3)
    local comps = self.Components
    if self.Method == '3D' and comps.Line and comps.Text then
        comps.Line.Color = c3
        comps.Text.Container.TextColor3 = c3
    else
        for i,v in next, comps do v.Color = c3 end 
    end
    self.Color = c3
end
local function getroot(plr)
    return plr and plr.Character and plr.Character:FindFirstChild"HumanoidRootPart"
end
local cc = workspace.CurrentCamera
local toworld = cc.WorldToViewportPoint
local function lerp(a, b, p)
    return a + (b - a) * p
end

function tracer:Render() --use in renderstep loop in other scr
    if not self.Visible then
        return
    end
    
    local comps = self.Components
    local target, root = self.Target , self.Root
    target = typeof(target) == 'Instance' and (target:IsA"Player" and getroot(target) or Vector3.zero) or target
    root = typeof(root) == 'Instance' and (root:IsA"Player" and getroot(root)) or (root:IsA"BasePart" and root)
    target, root = (typeof(target) == 'Vector3' and target) or target.Position, (typeof(root) == 'Vector3' and root) or (typeof(root) == 'Instance' and root.Position or Vector3.zero)
    if not comps.Text and comps.Line then return end
    if self.Method == '3D' then
        --comps.Text.StudsOffsetWorldSpace = target --no adornee bc can't be assigned to vec3s
        apply(comps.Line, {
            CFrame = CFrame.new(lerp(root, target, 0.5), target),
            Size = Vector3.new(0.5,0.5, (target - root).Magnitude)
        })
    elseif comps.Node1 and comps.Node2 then --alr check text and line
        local rscreenpos, ronscreen
        if (cc.CFrame.Position - cc.Focus.Position).Magnitude <= 5 then
            rscreenpos, ronscreen = Vector2.new(cc.ViewportSize.X/2, 0), true
        else
            rscreenpos, ronscreen = toworld(cc, root)
        end
        local tscreenpos, tonscreen = toworld(cc, target)
        rscreenpos, tscreenpos = Vector2.new(rscreenpos.X, rscreenpos.Y), Vector2.new(tscreenpos.X, tscreenpos.Y)
        
        comps.Node1.Visible = ronscreen
        comps.Node2.Visible = tonscreen
        comps.Text.Visible = tonscreen
        comps.Line.Visible = tonscreen
        
        comps.Node2.Position = tscreenpos
        comps.Text.Position = tscreenpos - Vector2.new(0, comps.Text.TextBounds.Y/2)
        comps.Line.To = tscreenpos
        if not ronscreen then
            rscreenpos = Vector2.new(cc.ViewportSize.X/2, 0)
        end
        comps.Line.From = rscreenpos
        comps.Node1.Position = rscreenpos
    end
end
--[[
local x = {}
for i = 1, 300 do
    local new = tracer.new(
        Vector3.new(
            (math.random()-0.5)*400,
            (math.random()-0.5)*400,
            (math.random()-0.5)*400
        )
    )
    new:SetMethod"2D"
    new:SetVisible(true)new:SetColor(Color3.new(math.random(),math.random(),math.random()))
    table.insert(x, new)
end
local t = tick()
d = game.RunService.RenderStepped:Connect(function()
    if tick() - t >= 10 then d:Disconnect() for i,v in next, x do v:Destroy() end end

    for i, vectest in next, x do 
        vectest:Render()
        
    end
end)]]
return tracer