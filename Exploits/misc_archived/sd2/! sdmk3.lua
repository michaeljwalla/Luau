
local wait = task.wait
while not game:IsLoaded() do wait() end
local http = game:GetService"HttpService"
local rs, uis = game:GetService"ReplicatedStorage", game:GetService"UserInputService"
local debris, plrs, lighting = game:GetService"Debris", game:GetService"Players", game:GetService"Lighting"
local ts = game:GetService"TweenService"
local lp = game.Players.LocalPlayer
local dis = workspace.Disaster
local floor, random, insert = math.floor, math.random, table.insert
local mouse = lp:GetMouse()
local stuff = {
    Hooks = {},
    Shared = {
        Notice = "mystery detected..."
    },
    Tracers = {},
    Selections = {},
    Connections = {},
    Gui = Instance.new"ScreenGui",
    PhysicalStorage = Instance.new"Folder",
    Ticktable = {},
    Misc = {},
    NameFuncs = {},
    Heartbeat = {},
    Step = {},
    RenderStep = {}
}
Instance.new("Folder", stuff.PhysicalStorage).Name = "Selections"
Instance.new("Folder", stuff.PhysicalStorage).Name = "3dTracers"
Instance.new("Folder", stuff.PhysicalStorage).Name = "Billboards"
--assets for notifcation icons/sounds

local sillyids = {'6077283409', '8047010263', '6135361206', '6135105405', '8083943965', '8055428159', '8277901783', '8277783131', '8346910738', '8310373893', '11715985649', '11715986662', '11715988834', '11715984625', '8492870754', '11638605267', '11871487650', '11782097928', '11852576951', '8121791765', '6048373980', '1108982534', '41926984'} --Hi
local sillysounds = {'1525434691', '1637269677', '1677002524', '1874648740', '2590431979', '2596997779', '3175780163', '4523196288','4528092831', '4753354026', '4855252375', '4888805461', '4888846393', '5094928129', '5127588257', '5101909352', '5969790363', '8083860632', '8083826218', '8083704797', '8242918150', '5969706182','4888923450','5127101270','4855252025','4483111565','3861386374','3175779930','2956566739','2652141836','2506581289','2499313611','2313456247','1676100990'}
local function playrandomsound()
    local newsound = Instance.new("Sound").ApplyProperties{
        Parent = stuff.Gui,
        SoundId = 'rbxassetid://'..sillysounds[random(1,#sillysounds)]
    }
    local t = tick()
    while tick() - t < 3 and not newsound.IsLoaded do wait() end
    newsound:Play()
    debris:AddItem(newsound, newsound.TimeLength)
end
local function notify(options) --Title, Text, Duration, Icon
    options.Text, options.Title = tostring(options.Text), tostring(options.Title)
    options.Icon = ('rbxthumb://type=Asset&id=%s&w=150&h=150'):format(tostring(sillyids[random(1, #sillyids)]))
    
    playrandomsound()
    game.StarterGui:SetCore("SendNotification", options)
    
end
--how to use WaitForDescendant (if i dont remember)
-- instance.WaitForDescendant(<string> Name, <number?> timeout, <boolean?> useRegexSearch)(<string?> classType)
-- must use two parentheses ()() to call due to unyieldable metamethod threads
local old, cop
--purpose of cop: 1.815x faster (on my pc) than normal indexing (used when not trying to get mm hook value)
--too late to remake plus it was gonna have to be hooked anyways so
local function hasprop(inst, prop)
    return cop(inst, prop)
end
do --drop vars after because none are used outside of scope
    
    old = shared.sd2
    if old then
        local bye = old^"penis" -- Hi
        stuff.Hooks = old.Hooks
        cop = stuff.Hooks.Index
        stuff.Shared = old.Shared
        stuff.Shared.MystTrack = false
        --stuff.Misc.SharedShopClose = bye()
        task.spawn(notify, {
            Title = "Reloaded!",
            Text = "welcome back."
        })
    else
        --[[local SharedShopClose = {true}
        stuff.Misc.SharedShopClose = SharedShopClose
        local premaghook
        local shophook = newcclosure(function(self, index)
            local scr = getcallingscript()
            if scr and index == 'magnitude' and tostring(scr) == 'CloseDetectors'  then
                return (not SharedShopClose[1] and 0) or premaghook(self, index) 
            end
            return premaghook(self, index)
        end)
        premaghook = hookfunction(getrawmetatable(Vector3.zero).__index, shophook)
        stuff.Hooks.Magnitude = premaghook]]
    local newmethods = {
            WaitForDescendant = function(self, args)
                return function(typeinst) --needs two functions because you can't yield inside of the hook 
                    local name, maxlen, regex, keepparent = unpack(args)
                    local oldParent = cop(self, 'Parent')
                    name = tostring(name)
                    --no findfirstchild(name, true) because it doesn't do regex
                    for i,v in pairs(self:GetDescendants()) do if ((regex and tostring(v):match(name)) or (not regex and tostring(v) == name)) and (not typeinst or v:IsA(typeinst)) then return v end end
                    if possiblematch then return possiblematch end
                    local breakEarly = not maxlen
                    maxlen = math.max(0, maxlen or 5) 
                    local t = tick()
                    local inst, con --another weird workaround to not cause infinite loops
                    con = cop(self, 'DescendantAdded'):Connect(function(new)
                        if ((regex and tostring(new):match(name)) or (not regex and tostring(new) == name)) and (not typeinst or new:IsA(typeinst)) then inst = new end
                    end)
                    --will not be perfectly aligned due to not being able to use connection:Wait()
                    while wait() and (not keepparent or oldParent == cop(self,'Parent')) and (tick() - t < maxlen and not inst) do 
                        if breakEarly and tick() - t >= 5 then
                            error(("Infinite yield possible on '%s.WaitForDescendant(\"%s\")'"):format(tostring(self), name))
                        end
                    end
                    con:Disconnect()
                    return inst
                end
            end,
            ApplyProperties = function(self, args)
                
                local props = args[1]
                local parenting = props.Parent
                if parenting then rawset(props, "Parent", nil) end --skipover til end
                for i,v in pairs(props) do if pcall(hasprop, self, i) then self[i] = v end end --allows to write to nonexistent props without breaking loop (bc i'm lazy and am reusing a table for gui props)
                if parenting then self.Parent = parenting end
                return self
            end,
            GetChildren = function(self, args)
                local name = args[1]
                local original = self:GetChildren()
                if name then
                    assert(type(name) == "string" or tonumber(name), ("Expected string for argument #1, got %s"):format(typeof(args[1])))
                    name = tostring(name)
                    local specifics = {}
                    for i,v in pairs(original) do
                        if tostring(v):match(name) then insert(specifics, v) end
                    end
                    return specifics
                end
                return original
            end,
            once = function(self, args)
                local con, func = args[1], args[2]
                --coroutine.wrap since connections are supposed to be desync and :Wait() yields async
                return coroutine.wrap(function() return func(cop(self, con):Wait()) end)()
            end
        }
        
        local originalindex
        originalindex = hookmetamethod(game, "__index", newcclosure(function(self, index)
            --if not stuff then return originalindex(self, index) end --no way to unhook metamethod (to my knowledge), so always return old when script is unloaded
            local stuff = shared.sd2
            local scr = getcallingscript()
            if not checkcaller() and index == 'Value' then
                if tostring(self) == 'Notice' and stuff.Shared.MystTrack then
                    return stuff.Shared.Notice
                elseif tostring(scr) == 'AntiFreeze' then
                    return false
                end
            elseif newmethods[index] then
                return function(...)
                    return newmethods[index](self, {...})
                end
            end
            return originalindex(self, index)
        end))
        stuff.Hooks.Index = originalindex
        cop = originalindex
        --added everything to __index because namecall slows down the game so much when hooked (whenever a gui is spawned, only god knows why)
        --[[local originalnamecall
        
        originalnamecall = hookmetamethod(game, "__namecall", newcclosure(function(self, ...)
            local method = getnamecallmethod()
            local args = {...}
            
            --if not stuff then return originalnamecall(self, unpack(args)) end
            if not checkcaller() and method == "Kick" then -- doesnt rlly need a caller check
                return error("Blocked a kick from script: "..tostring(getcallingscript()))
            elseif newmethods[method] then
                return newmethods[method](self, args)
            end
            return originalnamecall(self, unpack(args))
        end))
        stuff.Hooks.Namecall = originalnamecall]]
    end
    shared.sd2 = newproxy(true)
    local mt = getmetatable(shared.sd2)
    mt.__index = stuff
    mt.__pow = function()
        for i,v in pairs(stuff.Tracers) do i:Unload() end
        --for i,v in pairs(stuff.Selections) do v:Destroy() end
        stuff.PhysicalStorage:Destroy()
        for i,v in pairs(stuff.Connections) do v:Disconnect() end
        for i,v in pairs(stuff.NameFuncs) do v[false]() end
        stuff.Gui:Destroy()
        return function() stuff = nil script:Destroy() return end --local ssc = stuff.Misc.SharedShopClose stuff = nil return ssc end
    end

    
end
local doowop = Instance.new"Sound".ApplyProperties{
    SoundId = "rbxassetid://4483111565",
    Parent = stuff.Gui
}
local function mousePos()
    return { x = cop(mouse, "X"), y = cop(mouse, "Y") }
end
local function draggable(inst, dragwhat, secolors)
    local start, curPos
    local movewithme
    inst.InputBegan:Connect(function(InputObject)
        if cop(InputObject, "UserInputType") == Enum.UserInputType.MouseButton1 then
            movewithme = cop(mouse,"Button1Down"):Connect(function()
                inst.BackgroundColor3 = secolors[2]
                start = mousePos()
                while wait() and movewithme.Connected do
                    curPos = mousePos()
                    menuLast = cop(inst, "Position")
                    if curPos.x ~= start.x or curPos.y ~= start.y then
                        dragwhat.Position = cop(dragwhat, "Position") + UDim2.new(0,curPos.x - start.x,0, curPos.y - start.y)
                        start = mousePos()
                    end
                end
                inst.BackgroundColor3 = secolors[1]
            end)
        end
    end)
    local mouseConnection
    mouseConnection = cop(mouse, 'Button1Up'):Connect(function()
        if not (inst and cop(inst, 'Parent')) then 
            mouseConnection:Disconnect()
        else
            start = mousePos()
            curPos = start
            if movewithme then movewithme:Disconnect() end
         end
    end)
end
local function leadingzeros(num, min)
    num = tostring(num)
    while #num < min do
        num = "0"..num
    end
    return num
end
local info = rs.Info


if not lp.PlayerGui:FindFirstChild("TimerGui") then
    notify{Title = "Hello!", Text = "Spawning your character..."}
    wait(1) --dramatic effect
    rs.Remotes.Ready:FireServer()
    if lp.PlayerGui:WaitForChild("TimerGui", 5 ) then
        lp.PlayerGui:WaitForChild("LocalScript (TimerGui", 5)
    else
        task.spawn(notify, {Title = "Error?", Text = "Couldn't find TimerGui (this should always be here). If you are lagging, ignore this message."})
    end
end
local htval = info:FindFirstChild"HideTimer"
local function hidetimefunc()
    local cons = getconnections(htval.Changed)
    for i,v in pairs(cons) do
        if not v.Function or #getupvalues(v.Function) ~= 6 or getupvalue(v.Function, 1) ~= htval then continue end
        return v.Function
    end
    return
end
local function formatnum(num)
    local hours = floor(num/3600)
    num = num % 3600
    local minutes = floor(num/60)
    num = num % 60
    return string.format("%s:%s:%s", leadingzeros(hours, 2), leadingzeros(minutes, 2), leadingzeros(num, 2))
end
local default = {
    RichText = true,
    BackgroundColor3 = Color3.new(1/3,1/3,1/3), 
    TextColor3 = Color3.new(1,1,1),
    TextSize = 14,
    TextXAlignment = "Left",
    Font = 17, --10, 18 (17 non bold),
    ScrollBarThickness = 1,
    CanvasSize = UDim2.new(0,0,0,0),
    AutomaticCanvasSize = "Y",
    TextWrapped = true
}
local info = rs:WaitForChild"Info"
local ui = stuff.Gui
--be annoying
local un = true
--only will run once if you dont delete the folder lol
if not isfolder("highvalue") then
    stuff.Shared.Authentic = script:GetDebugId()
    un = not un
    task.spawn(function() --crazy
        task.spawn(notify, {
            Title = "One moment...",
            Text = "Gathering first-time files"
        })
        makefolder"highvalue"
        -- i just felt like making it
        local assets = {"https://cdn.discordapp.com/attachments/1054878469957373965/1058798865593155594/unknown.png","https://cdn.discordapp.com/attachments/1054878469957373965/1058797857362161714/IMG_4967.png","https://cdn.discordapp.com/attachments/1054878469957373965/1058162847756066886/2.png","https://cdn.discordapp.com/attachments/1054878469957373965/1058797470198550658/EAAEF95B-6107-41CF-9C0C-FCEA8E0B74C2.png","https://cdn.discordapp.com/attachments/1054878469957373965/1058796616385044581/F587CA7A-88D0-45FF-9BF7-371E7B1677BF_1_28.png","https://cdn.discordapp.com/attachments/1054878469957373965/1058796034500870164/D34CD93C-BA87-4B07-BA52-AE33E6BFA2DA_23.png","https://cdn.discordapp.com/attachments/1054878469957373965/1058795524389613598/C26DBBD3-4278-4D26-9E23-6EA1E6FCDB94.png","https://cdn.discordapp.com/attachments/1054878469957373965/1058795227147669525/F345C22F-B4E3-404A-A788-147B2C54DB92.png","https://cdn.discordapp.com/attachments/1054878469957373965/1058794898255511744/C39FDE20-BCAB-4766-AC99-1577ECB576FB.png","https://cdn.discordapp.com/attachments/1054878469957373965/1058794456045867169/FD8F1A06-CB4F-4814-807E-2E387CD47D31_12.png","https://cdn.discordapp.com/attachments/1054878469957373965/1058793897649770496/483DACE3-A3BD-4881-8DF6-8AE94AA466EF.png","https://cdn.discordapp.com/attachments/1054878469957373965/1058793519503912980/C92AD44C-1F12-4780-97BC-82D6D2DC7DA1.png","https://cdn.discordapp.com/attachments/1054878469957373965/1058799038293618790/Screenshot_20220708-153555_Discord.png","https://cdn.discordapp.com/attachments/1054878469957373965/1058799131331665940/Screenshot_20220708-153638_Discord.png","https://cdn.discordapp.com/attachments/1054878469957373965/1058793173926826054/npc_20.png","https://cdn.discordapp.com/attachments/1054878469957373965/1058792601848926288/higuys.png","https://cdn.discordapp.com/attachments/1054878469957373965/1058792197056643133/lilg.png","https://cdn.discordapp.com/attachments/1054878469957373965/1058791868932047038/hi.png","https://cdn.discordapp.com/attachments/974489185618624582/981038960249815110/unknown.png","https://cdn.discordapp.com/attachments/1054878469957373965/1058789751370555454/hi.png","https://cdn.discordapp.com/attachments/1054878469957373965/1058787737370632212/lol2028129.png","https://cdn.discordapp.com/attachments/1054878469957373965/1058786888992964708/lol_1.png","https://cdn.discordapp.com/attachments/1054878469957373965/1058786354143703131/lol_1_1_10.png","https://cdn.discordapp.com/attachments/1054878469957373965/1061490443122135050/23747eeac30d7ed51a18fecdd959024a.png", "https://cdn.discordapp.com/attachments/1054878469957373965/1061492851868966942/XQXK2832_31.png"}
        local getter = {Method = "GET", Headers = {['Content-Type'] = ""}}
        getter.Headers['Content-Type'] = "audio/mpeg"
        getter.Url = "https://cdn.discordapp.com/attachments/625181176683954187/1057913539844640788/okok.mp3"
        writefile("highvalue/okok.mp3", syn.request(getter).Body)
        getter.Url = "https://cdn.discordapp.com/attachments/625181176683954187/1057913545670545459/boom.mp3"
        writefile("highvalue/boom.mp3", syn.request(getter).Body)
        local baseframe = Instance.new"ImageLabel".ApplyProperties(default).ApplyProperties{
            BackgroundTransparency = 0,
            Size = UDim2.new(0,ui.AbsoluteSize.X/4,0,ui.AbsoluteSize.X/4),
        }
        local okok = Instance.new"Sound".ApplyProperties{
            Parent = ui,
            SoundId = getsynasset("highvalue/okok.mp3"),
            Volume = 2,
        }
        local boom = okok:Clone().ApplyProperties{
            Parent = ui,
            SoundId = getsynasset"highvalue/boom.mp3"
        }
        for i,v in pairs(assets) do
            local ending = v:match"%.png" and ".png"
            if not ending then continue end
            getter.Headers['Content-Type'] = 'image/'..ending
            getter.Url = v
            local path = 'highvalue/'..i..ending
            writefile(path, syn.request(getter).Body)
            assets[i] = getsynasset(path)
        end
        local loadingframe = Instance.new"TextLabel".ApplyProperties(default).ApplyProperties{
            Size = UDim2.new(0,ui.AbsoluteSize.X/4,0,25),
            Position = UDim2.new(0.5,-ui.AbsoluteSize.X/8,1,-ui.AbsoluteSize.X/8),
            Parent = ui,
            TextXAlignment = "Center",
            Text = "(FIRST TIME SETUP)"
        }
        local greenbar = Instance.new("Frame").ApplyProperties(default).ApplyProperties{
            Size = UDim2.new(0,0,0,25),
            Position = UDim2.new(0,0,0,0),
            BackgroundColor3 = Color3.new(0,1,0),
            Parent = loadingframe
        }
        okok.TimePosition = 0.65
        okok:Play()
        debris:AddItem(okok,94.5)
        local ctr = 0
        local t = tick()
        local lastone, ready
        repeat
            if not ready and tick() - t >= 2.7 then
                ready = true
                ctr = ctr + 1
                task.delay(3, game.Destroy, lastone)
                lastone = baseframe:Clone().ApplyProperties{
                    Image = assets[ctr],
                    Position = UDim2.new(0.5,-250,0.5,-250) + UDim2.fromScale((random() < 0.5 and -1 or 1) * 1 + random(), (random() < 0.5 and -1 or 1) * 1 + random()),
                    Parent = ui,
                    Visible = false
                }
            end
            if tick() - t >= 3.7 then
                t = tick()
                lastone.Visible = true
                ts:Create(lastone, TweenInfo.new(1,Enum.EasingStyle.Elastic), {Position = UDim2.new(0.5,-250,0.5,-250)}):Play()
                debris:AddItem(lastone, 7)
                
                boom:Play()
                ready = false
            end
            greenbar.Size = UDim2.new(okok.TimePosition/94.5, 0, 0, 24)
        until not (wait() and okok.Parent)
        
        stuff.Shared.Authentic = nil
        lastone:Destroy()
        boom:Destroy()
        loadingframe:Destroy()
        ui.Frame.Visible = true
    end)
end
if stuff.Shared.Authentic and stuff.Shared.Authentic ~= script:GetDebugId() then pcall(delfolder, 'highvalue') notify{Title = "", Text = "\87\65\84\67\72\32\84\72\69\32\87\72\79\76\69\32\84\72\73\78\71"} return end

local backplate = Instance.new"Frame".ApplyProperties(default).ApplyProperties{
    Size = UDim2.fromOffset(450,300),
    Position = UDim2.new(0,300,0,300),
    Parent = ui,
    Visible = un
}
local gamemode = info:WaitForChild"Gamemode".Value
local topbar = Instance.new"TextLabel".ApplyProperties(default).ApplyProperties{
    Size = UDim2.new(1,0,0,25),
    BackgroundColor3 = Color3.new(1/6,1/6,1/6),
    Text = ("    Survive the Disasters 2: <font color=\"%s\">%s</font>"):format(gamemode == "Normal" and "#5CD6F5" or "#C93131", gamemode),
    Parent = backplate
}
--draggable(topbar, backplate, {topbar.BackgroundColor3, Color3.new(1/8,1/8,1/8)})
draggable(backplate, backplate, {backplate.BackgroundColor3, backplate.BackgroundColor3})

local menuswitcher = Instance.new("ScrollingFrame").ApplyProperties(default).ApplyProperties{
    Parent = backplate,
    Position = UDim2.new(0,0,0,26),
    Size = UDim2.new(0,100,1,-26),
}
local tabholder = Instance.new("ScrollingFrame").ApplyProperties(default).ApplyProperties{
    Parent = backplate,
    Position = UDim2.new(0,100,0,26),
    Size = UDim2.new(1,-100,1,-26),
}

local menudata = {
    Current = "Home",
    Menus = {}
}
function menudata:SwitchTo(name)
    if self:GetMenu(name) then
        self.Current = name 
        for i,v in pairs(self.Menus) do
            if tostring(i) ~= self.Current then 
                i.BackgroundColor3 = Color3.new(1/4,1/4,1/4)
                v.Object.Visible = false
            else
                i.BackgroundColor3 = Color3.new(1/6,1/6,1/6)
                tabholder.CanvasSize = UDim2.new(0,0,0,v.SizeFix)
                v.Object.Visible = true
            end
        end
    end
end
function menudata:Length()
    local ctr = 0
    for i,v in pairs(self.Menus) do ctr = ctr + 1 end
    return ctr
end
function menudata:GetMenu(name)
    for i,v in pairs(self.Menus) do
        if tostring(i) == name then
            return {Button = i, Frame = v.Object}
        end 
    end
end

Instance.new("UIListLayout", menuswitcher).SortOrder = "LayoutOrder"
local basemenutab = Instance.new("TextButton").ApplyProperties(default).ApplyProperties{
    TextSize = 14,
    BackgroundColor3 = Color3.new(1/4,1/4,1/4),
    Size = UDim2.new(1,0,0,25),
    TextXAlignment = "Center",
}
local basemenuframe = Instance.new("Frame").ApplyProperties(default).ApplyProperties{
    Size = UDim2.new(1,0,1,0),
    Visible = false,
}
function menudata:createMenu(name, size)
    assert(not menudata:GetMenu(name), ("The menu '%s' has already been created."):format(name))
    local newButton = basemenutab:Clone().ApplyProperties{
        Text = name,
        Parent = menuswitcher,
        Name = name,
    }
    local newMenu = basemenuframe:Clone().ApplyProperties{
        Name = name,
        Parent = tabholder,
    }
    cop(newButton, 'MouseButton1Click'):Connect(function() self:SwitchTo(name) end)
    self.Menus[newButton] = {SizeFix = size, Object = newMenu}
end
menudata:createMenu("Home", 350)
menudata:createMenu("World")
menudata:createMenu("Survival")
menudata:createMenu("Tracers")
menudata:createMenu("Detectable")

local mywebhook = '' --decided to not obfuscate, obviously will not be leaving webhook
local json = function(tbl) return http:JSONEncode(tbl) end
local unjson = function(str) return http:JSONDecode(str) end
local function rawthumblink(i)
    if true then return end
    i = tostring(i)
    local x = unjson(syn.request{
        Method = "GET",
        Url = ("https://thumbnails.roblox.com/v1/users/avatar-headshot?userIds=%s&size=48x48&format=Png"):format(i)
    }.Body)
    return x.data and x.data[1] and x.data[1].imageUrl
end
local myLastMessage
local createMessage = function(body)return true or (tick() - body.nonce < 3 and not notify{Title = "Slow down bucko", Text = "Ur gonna be rate limited!!"}) or syn.request{Url = mywebhook,Method = 'POST',Body = json(body),Headers = {['Content-Type'] = "application/json"}} end
local getMyMessage = function() return '...' or unjson(syn.request{Url = mywebhook.."/messages/1057852884944949308",Method = 'GET',Headers = {['Content-Type'] = "application/json",}}.Body).content end
local popups = {}
local defaultpopup = Instance.new"TextLabel".ApplyProperties(default).ApplyProperties{
    Size = UDim2.fromOffset(75,75),
    BackgroundColor3 = Color3.new(),
    BorderSizePixel = 0,
    TextSize = 12,
    BackgroundTransparency = 0.5,
    TextXAlignment = "Center",
    Text = "This is a popup."
}
local popups = {}

local function spawnpopuphover(onHover, toPopup, optfunc)
    pcall(cop(game, 'Destroy'), popups[onHover])
    rawset(popups, onHover, toPopup)
    cop(onHover, 'MouseMoved'):Connect(function(x,y)
        if optfunc then optfunc(x,y) end
        toPopup.Parent = ui
        --local mouse = mousePos()
        toPopup.Position = UDim2.fromOffset(mouse.X + 5, mouse.Y - toPopup.AbsoluteSize.Y - 5)
    end)
    onHover.MouseLeave:Connect(function()
        toPopup:Remove()
    end)
end
local uid = lp.UserId
--get user icon
stuff.Ticktable.CheckMessage = tick()
stuff.Ticktable.SendMessage = tick() - 480
stuff.Ticktable.MessageNoBrain = tick() - 6
local txtformat = "Made by Bell\nContributors: Bell\nSpecial Thanks: Bell\nSpecial Message: %s\n\n--------------------\n\nYou've been in this server for <font color=\"#FFCCFF\">%s</font>\n\n--------------------\n\nKeybinds:\n<font color=\"#AAFFFF\">Semicolon ;</font> - Hide this menu\n<font color=\"#AAFFFF\">Right Ctrl</font> - Hide everything\n\n"
do
    local tab_homepage = menudata:GetMenu"Home".Frame
    
    local main = Instance.new("TextLabel").ApplyProperties(default).ApplyProperties{
        TextXAlignment = "Center",
        Text = txtformat,
        Size = UDim2.new(1,0,1,25),
        Parent = tab_homepage,
        Name = "MainText"
    }
    local talk = Instance.new("TextLabel").ApplyProperties(default).ApplyProperties{
        TextXAlignment = "Center",
        Text = "Want to request an update, or send me a message (idk what you want)?",
        Size = UDim2.new(1,0,0,50),
        Position = UDim2.fromScale(0,1),
        Parent = tab_homepage
    }
    local input = Instance.new"TextBox".ApplyProperties(default).ApplyProperties{
        Text = "",
        TextSize = 10,
        PlaceholderText = "    Note: your username will be included in the message",
        Parent = tab_homepage,
        Size = UDim2.new(1,-50,0,51),
        Position = UDim2.new(0,0,1,51),
        ClearTextOnFocus = false
    }
    local submit = Instance.new"TextButton".ApplyProperties(default).ApplyProperties{
        Text = "Submit",
        Name = "Submit",
        Size = UDim2.new(0,48,0,50),
        Position = UDim2.new(1,-50,1,51),
        Parent = tab_homepage,
        TextXAlignment = "Center",
        TextSize = 14
    }
    _G[uid] = _G[uid] or rawthumblink(uid)
    input.FocusLost:Connect(function()
        input.Text = cop(input, 'Text'):match("^%s*(.-)%s*$")
    end)
    local lastText = cop(input, 'Text')
    input:GetPropertyChangedSignal"Text":Connect(function()
        input.Text = cop(input, 'Text'):sub(1,512)
        if not cop(input, 'TextFits') then
            input.Text = lastText
            return
        end
        lastText = cop(input, 'Text')
    end)
    cop(submit, 'MouseButton1Click'):Connect(function()
        if tick() - stuff.Ticktable.SendMessage < 600 then
            if (tick() - stuff.Ticktable.SendMessage > 5) and (tick() - stuff.Ticktable.MessageNoBrain >= 6) then stuff.Ticktable.MessageNoBrain = tick() notify{Title = "üß†‚ùå", Text = "The timer exists for a reason..."} end
            return 
        end
        local diff = stuff.Ticktable.SendMessage
        stuff.Ticktable.SendMessage = tick()
        if #cop(input,'Text') < 1 then stuff.Ticktable.SendMessage = tick() - 600 return end --just in case if an autoclicker was able to go through the if
        if not createMessage{nonce = diff,content = "https://www.roblox.com/users/"..uid.."/profile",embeds = {{thumbnail = { url = _G[uid] },title = ("%s (%s)"):format(cop(lp,'DisplayName'), cop(lp,'Name')),description = cop(input, 'Text'),color = random(0,16777215)}}} then return end --0x0 to 0xffffff in decimal
        notify{Duration = 8, Title = "Success! (probably)", Text = "Your message has been sent! Or it errored and didn't, i dont really care."}
    end)
end
local syms = setmetatable({}, {
    __index = function(self, ind)
        return (ind and "‚úî") or "‚úñ"
    end
})
local cols = setmetatable({}, {
    __index = function(self, ind)
        return (ind and Color3.new(1/4,1/2,1/4)) or Color3.new(1/2,1/4,1/4)
    end
})
local valid = {"Step", "RenderStep", "Heartbeat"}
local function newtogglefuncs(name, load, disable, rep)
    assert(not rep or table.find(valid, rep), ("'%s' is not a valid repetition stage"):format(tostring(rep)))
    stuff.NameFuncs[name] = {[true] = load, [false] = disable, Rep = rep}
    if rep then stuff[rep][name] = load end
end
local basetoggle = Instance.new"Frame".ApplyProperties(default).ApplyProperties{Size = UDim2.new(1,0,0,25)}
Instance.new"TextButton".ApplyProperties(default).ApplyProperties{
    Size = UDim2.new(0,25,1,0),
    Parent = basetoggle,
    Name = "Toggle",
    TextXAlignment = "Center",
    Text = syms[not 69 and false or nil and {}]
}
Instance.new("TextLabel").ApplyProperties(default).ApplyProperties{
    Size = UDim2.new(1,-25,1,0),
    Text = "    Sample Text",
    Position = UDim2.fromOffset(25),
    Parent = basetoggle,
    BackgroundColor3 = Color3.new(1/4,1/4,1/4),
    Name = "Desc"
}
Instance.new"ObjectValue".ApplyProperties{
    Parent = Instance.new"TextLabel".ApplyProperties(default).ApplyProperties{
        BorderSizePixel = 0,
        Text = "?",
        TextXAlignment = "Center",
        Size = UDim2.new(0,50,1,0),
        Parent = basetoggle,
        Position = UDim2.new(1,-50,0,0),
        BackgroundTransparency = 1,
        Name = "InfoPopup"
    },
    Name = "Popup"
}
local function aligntoggle(toggle, value)
    local toggle = cop(toggle, 'Toggle')
    toggle.Text = syms[value]
    toggle.BackgroundColor3 = cols[value]
end
local touch = function(p1, p2)
    firetouchinterest(p1,p2,0)
    firetouchinterest(p1,p2,1)
end
local function getplayerpart(plr, rootonly)
    return cop(plr, 'Parent') and cop(plr,'Character') and (cop(plr,'Character'):FindFirstChild"HumanoidRootPart" or (not rootonly and (cop(plr,'Character'):FindFirstChild"Head" or cop(plr,'Character'):FindFirstChildWhichIsA"BasePart")))
end

local function plrfromname(str, default)
    str = str:gsub("[^%a_]", ""):lower()
    if #str > 0 then
        for i,v in pairs(plrs:GetPlayers()) do
            if v.Name:lower():find(str) == 1 then return v end
        end
    end
    return default or lp
end
local baseselection = Instance.new("SelectionBox").ApplyProperties{
    Color3 = Color3.new(),
    LineThickness = 0.05
}
local tracerdata = {
    Storage = cop(stuff.PhysicalStorage, '3dTracers'),
    Base = Instance.new"Part".ApplyProperties{
         Transparency = 0.5,
         Material = "Neon",
         Size = Vector3.new(0.3,0.3, 2),
         Position = Vector3.new(0,10,0),
         BrickColor = BrickColor.new("Really red"),
         Anchored = true,
         CanCollide = false
    },
    BaseBillboard = Instance.new"BillboardGui".ApplyProperties{
        AlwaysOnTop = true,
        Size = UDim2.new(1,0,1,0)
    },
    Unload = function(self)
        local t = self.Tracer
        self.Billboard:Destroy()
        t:Destroy()
        stuff.Tracers[self] = nil
    end
}
Instance.new("TextLabel").ApplyProperties(default).ApplyProperties{
    Parent = tracerdata.BaseBillboard,
    BackgroundTransparency = 1,
    TextSize = 48,
    TextColor3 = Color3.new(1),
    Text = "Sample text",
    Size = UDim2.new(1,0,1,0),
    TextWrapped = false,
    TextXAlignment = "Center",
}
function tracerdata:Load(part, optname, optid)
    if not (pcall(hasprop, part, 'Position') and part:IsDescendantOf(game)) then return end
    local newt = {Unload = tracerdata.Unload}
    
    newt.Tracer = self.Base:Clone()
    newt.Adornee = part
    newt.Id = optid
    
    newt.Billboard = self.BaseBillboard:Clone().ApplyProperties{Adornee = part}
    cop(newt.Billboard, 'TextLabel').Text = tostring(optname or part)
    
    task.defer(part.once, "AncestryChanged", function()
        if stuff.Tracers[newt] then newt:Unload()  end
    end)
    stuff.Tracers[newt] = true
    newt.Tracer.Parent = self.Storage
    newt.Billboard.Parent = cop(stuff.PhysicalStorage, 'Billboards')
    return newt
end
do
    local tab_worldpage = menudata:GetMenu"World".Frame
    Instance.new("UIListLayout").ApplyProperties{
        SortOrder = "LayoutOrder",
        Parent = tab_worldpage
    }
    local nofog = basetoggle:Clone().ApplyProperties{
        Parent = tab_worldpage,
        Name = "RFOG"
    }
    cop(nofog, 'Desc').Text = "    Remove Fog"
    local sfe = lighting:FindFirstChild("ServerFogEnd")
    local fogpopup = defaultpopup:Clone().ApplyProperties{
        Text = ("Current Fog Distance: <b>%s</b>"):format(tostring(sfe and cop(sfe, 'Value') or "?"))
    }
    stuff.Connections.FogPopupListener = sfe and sfe.Changed:Connect(function()
        fogpopup.Text = ("Current Fog Distance: <b>%s</b>"):format(tostring(sfe and cop(sfe, 'Value') or "?"))
    end)
    cop(cop(nofog, 'InfoPopup'), 'Popup').Value = fogpopup
    spawnpopuphover(nofog.InfoPopup, fogpopup--[[, function()
        fogpopup.Text = ("<i>Current Fog Distance: %s</i>"):format(tostring(sfe and sfe.Value or "?"))
    end]])
    
    --spawnpopuphover(nofog.InfoPopup, defaultpopup) --test
    --rfog
    local fogenabled, fogcon, fogdb
    local function rfog()
        if fogdb or (fogcon and fogcon.Connected) or not fogenabled then return end
        fogdb = true
        local db = true
        lighting.FogEnd = 1/0
        fogcon = lighting:GetPropertyChangedSignal"FogEnd":Connect(function()
            db = not db
            if db then return end
            lighting.FogEnd = 1/0 
        end)
        stuff.Connections.RFOG = fogcon
        fogdb = false
    end
    local function srfog()
        if fogdb then return end
        fogdb = true
        fogenabled = false
        if fogcon then fogcon:Disconnect() end
        lighting.FogEnd = cop(sfe, 'Value')
        fogdb = false
    end
    newtogglefuncs("RFOG", rfog, srfog--[[, "Heartbeat"]])
    cop(cop(nofog, 'Toggle').ApplyProperties{BackgroundColor3 = cols[fogenabled]}, 'MouseButton1Click'):Connect(function()
        if fogdb then return end
        fogenabled = not fogenabled
        aligntoggle(nofog, fogenabled)
        stuff.NameFuncs.RFOG[fogenabled]()
    end)
    --end rfog
    
    --noshadows
    local ns = basetoggle:Clone().ApplyProperties{
        Parent = tab_worldpage,
        Name = "NOSHADOW"
    }
    cop(ns, 'Desc').Text = "    Disable Shadows"
    cop(ns, 'InfoPopup'):Destroy()
    local noshadows = false
    newtogglefuncs("NOSHADOW", function() if not noshadows then return end game.Lighting.GlobalShadows = false end, function() noshadows = false game.Lighting.GlobalShadows = true end)
    cop(cop(ns, 'Toggle').ApplyProperties{BackgroundColor3 = cols[noshadows]}, 'MouseButton1Click'):Connect(function()
        noshadows = not noshadows
        aligntoggle(ns, noshadows)
        stuff.NameFuncs.NOSHADOW[noshadows]()
    end)
    --end noshadows
    
    --camblockers
    local cb = basetoggle:Clone().ApplyProperties{
        Parent = tab_worldpage,
        Name = "CAMBLOCK"
    }
    cop(cb, 'Desc').Text = "    Omit Camera from Borders"
    local cbpopup = defaultpopup:Clone().ApplyProperties{
        Text = "Prevents your camera from being blocked by the map's borders. Not useful.",
        Size = UDim2.new(0,125,0,75)
    }
    cop(cop(cb, 'InfoPopup'), 'Popup').Value = cbpopup
    spawnpopuphover(cop(cb, 'InfoPopup'), cbpopup)
    local unblockcam = false
    local camblockers = cop(cop(workspace, 'Lobby'), 'Bricks').GetChildren"^Anti"
    newtogglefuncs("CAMBLOCK", function()
        if not unblockcam then return end
        for i,v in pairs(camblockers) do v.Transparency = 1 end
    end, function() 
        unblockcam = false
        for i,v in pairs(camblockers) do v.Transparency = 0 end
    end)
    cop(cop(cb, 'Toggle').ApplyProperties{BackgroundColor3 = cols[unblockcam]}, 'MouseButton1Click'):Connect(function()
        unblockcam = not unblockcam
        aligntoggle(cb, unblockcam)
        stuff.NameFuncs.CAMBLOCK[unblockcam]()
    end)
    --end camblockers
end

do
    local tt = stuff.Ticktable
    local tab_survivalpage = menudata:GetMenu"Survival".Frame
    Instance.new("UIListLayout").ApplyProperties{
        SortOrder = "LayoutOrder",
        Parent = tab_survivalpage
    }
    --mystery 
    local myst = basetoggle:Clone().ApplyProperties{
        Parent = tab_survivalpage,
        Name = "MYSTERY"
    }
    cop(myst, 'Desc').Text = "    Reveal Mystery"
    cop(myst, 'InfoPopup'):Destroy()
    local timecon = hidetimefunc()
    local mysttracking, mystcon, mystdb = false
    local function syncmyst(con)
        return (con and con.Connected and con == mystcon and stuff.Shared.MystTrack and lighting.FogColor == Color3.new(1,1,1))
    end
    local function timerenv()
        return cop(lp, 'PlayerGui'):FindFirstChild("TimerGui") and cop(cop(lp, 'PlayerGui'), 'TimerGui'):FindFirstChild"LocalScript (TimerGui)" --and getsenv(cop(cop(cop(lp, 'PlayerGui'), 'TimerGui'), "LocalScript (TimerGui)"))
    end
    local function onLightingChanged()
        local env = getsenv(timerenv())
        if not env then return end
        local self = mystcon
        if lighting.FogColor ~= Color3.new(1,1,1) then stuff.Shared.MystTrack = false env.update() return end
        stuff.Shared.MystTrack = true
        stuff.Shared.Notice = "mystery detected..."
        local part = dis:FindFirstChildOfClass"Model"
        if part then stuff.Shared.Notice = (gamemode == "Normal" and " " or "Hyper ")..cop(part, 'Name') env.update() return end
        env.update()
        dis.once("ChildAdded", function(c)
            if not syncmyst(self) then return end
            stuff.Shared.Notice = (gamemode == "Normal" and " " or "Hyper ")..cop(c, 'Name')
            env.update()
        end)
    end
    local function mtrack()
        if mystdb or (mystcon and mystcon.Connected) or not mysttracking then return end
        mystdb = true
        local env = getsenv(timerenv())
        if not env then mystdb = false return task.spawn(notify, {Title = "Error: Mystery Reveal", Text = "Couldn't find assets for timer hook."}) end
        
        if not stuff.Hooks.NoExpTitle then
            local old
            old = hookfunction(env.fillExpBar, function()
                local stuff = shared.sd2 --since original stuff is gc'd when script reran
                return not checkcaller() and old() --dont show xp if called by syn
            end)
            stuff.Hooks.NoExpTitle = old
        end
        if not stuff.Hooks.TimerRise then
            timecon = hidetimefunc()
            if not timecon then return end --try again later
            local old
            old = hookfunction(timecon, function()
                if htval.Value and game.Lighting.FogColor == Color3.new(1,1,1) then return end
                return coroutine.wrap(old)()
            end)
            stuff.Hooks.TimerRise = old
        end--
        if not stuff.Hooks.TextGenMystery then
            local old
            old = hookfunction(require(cop(cop(rs, 'Modules'), 'Font')).generateText, function(...)
                local stuff, args = shared.sd2, {...}
                if stuff.Shared.MystTrack and tostring(args[2]) == 'Notice' then rawset(args, 4, 'cyan') end
                return old(unpack(args))
            end)
            stuff.Hooks.TextGenMystery = old
        end
        onLightingChanged(true)
        mystcon = lighting:GetPropertyChangedSignal"FogColor":Connect(onLightingChanged)
        stuff.Connections.MysteryHook = mystcon
        mystdb = false
    end
    local function unmtrack()
        if mystdb then return end
        mystdb = true
        mysttracking = false
        if mystcon then mystcon:Disconnect() end
        stuff.Shared.MystTrack = false
        local env = timerenv()
        if not env then return task.spawn(notify, {Title = "Error: Mystery Reveal", Text = "Couldn't find assets for timer hook."}) end
        getsenv(env).update()
        mystdb = false
    end
    newtogglefuncs("MYSTERY", mtrack, unmtrack)
    cop(cop(myst,'Toggle').ApplyProperties{BackgroundColor3 = cols[mysttracking]}, 'MouseButton1Click'):Connect(function()
        if mystdb then return end
        mysttracking = not mysttracking
        aligntoggle(myst, mysttracking)
        stuff.NameFuncs.MYSTERY[mysttracking]()
    end)
    --END OF PATCHING END OF PATCHING
    local gm = basetoggle:Clone().ApplyProperties{
        Parent = tab_survivalpage,
        Name = "GODMODE"
    }
    gm.Desc.Text = "    Partial Invulnerability"
    local gmpopup = defaultpopup:Clone().ApplyProperties{
        Text = "Learn about network ownership to understand the extents of this feature",
        Size = UDim2.new(0,150,0,50)
    }
    spawnpopuphover(gm.InfoPopup, gmpopup)
    local function gmattachchar(char)
        local prev = stuff.Connections.GodmodeChar
        if prev then prev:Disconnect() end
        local new = char.ChildAdded:Connect(function(v)
            if v:IsA"BasePart" then v.CanTouch = false end
        end)
        stuff.Connections.GodmodeChar = new
        char.once("AncestryChanged", function() new:Disconnect() end)
    end
    local gmon, gmcon, gmdb = false
    local function sgm()
        if gmdb or (not gmon or (gmcon and gmcon.Connected)) then return end
        gmdb = true
        if lp.Character then
            for i,v in pairs(lp.Character:GetChildren()) do if v:IsA"BasePart" then v.CanTouch = false end end
        end
        gmattachchar(lp.Character)
        gmcon = lp.CharacterAdded:Connect(gmattachchar)
        stuff.Connections.Godmode = gmcon
        if lp.Character and not lp.Character:FindFirstChildOfClass"ForceField" and not doowop.IsPlaying then debris:AddItem(Instance.new("ForceField", lp.Character), 3) doowop:Play() end
        gmdb = false
    end
    local function ungm()
        if gmdb then return end
        gmdb = true
        gmon = false
        if gmcon then gmcon:Disconnect() end
        if stuff.Connections.GodmodeChar then stuff.Connections.GodmodeChar:Disconnect() end
        if lp.Character then
            for i,v in pairs(lp.Character:GetChildren()) do if v:IsA"BasePart" then v.CanTouch = true end end
        end
        gmdb = false    
    end
    newtogglefuncs("GODMODE", sgm, ungm)
    gm.Toggle.ApplyProperties{BackgroundColor3 = cols[mysttracking]}.MouseButton1Click:Connect(function()
        if gmdb then return end
        gmon = not gmon
        aligntoggle(gm, gmon)
        stuff.NameFuncs.GODMODE[gmon]()
    end)
    
    --
    
    local mkit = basetoggle:Clone().ApplyProperties{
        Parent = tab_survivalpage,
        Name = "MEDKIT"
    }
    mkit.Desc.Text = "    Medkit Steal"
    local gmpopup = defaultpopup:Clone().ApplyProperties{
        Text = "Auto pickup/use medkits when available",
        Size = UDim2.new(0,100,0,60)
    }
    spawnpopuphover(mkit.InfoPopup, gmpopup)
    local mkfrom, mktarget, mkrad = lp, lp, 1/0
    local mkbelowframe = Instance.new("TextLabel").ApplyProperties(default).ApplyProperties{
        Size = UDim2.new(1,0,1,0),
        Parent = mkit,
        Position = UDim2.new(0,0,1,0),
        Text = " ‚Üò",
        TextSize = 18,
        TextYAlignment = "Top",
        BackgroundColor3 = Color3.new(1/4,1/4,1/4)
    }
    local mktargetinput = Instance.new"TextBox".ApplyProperties(default).ApplyProperties{
        Text = "  To: "..tostring(mktarget),
        PlaceholderText = "  The player to heal...",
        Parent = mkbelowframe,
        Position = UDim2.new(0,25,0,0),
        Size = UDim2.new(0,163,1,0),
        TextSize = 12
    }
    local mkfrominput = mktargetinput:Clone().ApplyProperties{
        Text = "  From: "..tostring(mkfrom),
        PlaceholderText = "@ for anyone, -r <num> for radius",
        Parent = mkbelowframe,
        Position = UDim2.new(0,188,0,0)
    }
    
    local mkon, mkcons, mkdb = false, {}
    
    
    local selectionmks = {}
    local medtick = tick() --not in stuff.Ticktable cuz its not used by a thousand other functions (no need to be shared)
    stuff.Heartbeat.TrackMkSelections = function()
        if tick() - medtick < 0.1 then return else medtick = tick() end
        local attemptpart = getplayerpart(mktarget)
        if not attemptpart then return end
        for i,v in pairs(selectionmks) do
            if not (v.Parent and v.Adornee and v.Adornee.Parent) then selectionmks[i] = nil continue end --table.remove complete waste of time
            if (v.Adornee.Position - attemptpart.Position).Magnitude <= mkrad and (mktarget == lp or isnetworkowner(v.Adornee)) then
                v.Color3 = Color3.fromRGB(255,182,193)
                touch(v.Adornee, attemptpart)
            else
                v.Color3 = Color3.new()
            end
        end
    end
    local function checkmk(v)
        if v.Name == 'Handle' and v.Size == Vector3.new(1, 0.4, 1) then
            local owner = v.WaitForDescendant("Player", 5, true)"ObjectValue"
            if not owner or (mkfrom and owner.Value ~= mkfrom) then return end --nil check bc nil = take anyones kit
            local new = baseselection:Clone().ApplyProperties{
                Parent = stuff.PhysicalStorage.Selections,
                Adornee = v
            }
            selectionmks[new] = new --crazy
            stuff.Selections[new] = 69
            v.once("AncestryChanged", function()
                selectionmks[new] = nil
                stuff.Selections[new] = nil
                new:Destroy()
            end)
        end
    end
     mktargetinput.FocusLost:Connect(function()
        local target = plrfromname(mktargetinput.Text)
        mktarget = target
        mktargetinput.Text = "  To: "..tostring(target)
        if mkon then
            for i,v in pairs(selectionmks) do v:Destroy() end
            for i,v in pairs(workspace:GetChildren()) do checkmk(v) end
        end
    end)
    mkfrominput.FocusLost:Connect(function()
        local msg = mkfrominput.Text:gsub("%s", "")
        if (msg == "@") then
            mkfrom = nil
        elseif (msg:match"^%-r%d+e?%d*$") then
            mkrad = tonumber(msg:sub(3,-1))
            notify{ Title = "Medkit Snipe", Text = "Updated radius to "..mkrad }
        elseif not msg:match"[^%a_]" then
            mkfrom = plrfromname(msg)
        end
        mkfrominput.Text = "  From: "..tostring(mkfrom or "{ ANYONE }")
        if mkon then
            for i,v in pairs(selectionmks) do v:Destroy() end
            for i,v in pairs(workspace:GetChildren()) do checkmk(v) end
        end
    end)
    local function smk()
        if mkdb or not mkon or (mkcons[1] and mkcons[1].Connected) then return end
        mkdb = true
        for i,v in pairs(workspace:GetChildren()) do checkmk(v) end
        mkcons[1] = workspace.ChildAdded:Connect(checkmk)
        
        stuff.Connections.MedAdd = mkcons[1]
        stuff.Connections.TouchMed = mkcons[2]
        mkdb = false
        return
    end
    local function unmk()
        if mkdb then return end
        mkdb = true
        mkon = false
        for i,v in pairs(mkcons) do v:Disconnect() end
        for i,v in pairs(selectionmks) do v:Destroy() end
        mkdb = false
        return
    end
    
    newtogglefuncs("MEDKIT", smk, unmk)
    mkit.Toggle.ApplyProperties{BackgroundColor3 = cols[mysttracking]}.MouseButton1Click:Connect(function()
        if mkdb then return end
        mkon = not mkon
        aligntoggle(mkit, mkon)
        stuff.NameFuncs.MEDKIT[mkon]()
    end)
end

do
    local tracktbl = {}
    stuff.Misc.Tracking = tracktbl
    local tab_tracerpage = menudata:GetMenu"Tracers".Frame
    Instance.new("UIListLayout").ApplyProperties{
        SortOrder = "LayoutOrder",
        Parent = tab_tracerpage
    }
    
    spawnpopuphover(Instance.new"TextLabel".ApplyProperties(default).ApplyProperties{
        Size = UDim2.new(1,0,0,25),
        BackgroundColor3 = Color3.new(1/6,1/6,1/6),
        Parent = tab_tracerpage,
        Text = "  Tracers"
    }, defaultpopup:Clone().ApplyProperties{
        Text = "Creates lines in the world that point towards significant information",
        Size = UDim2.new(0,150,0,50)
    })
    --volcano 
    local volc = basetoggle:Clone().ApplyProperties{
        Parent = tab_tracerpage,
        Name = "VOLCANO"
    }
    volc.Desc.Text = "    Volcano"
    volc.InfoPopup:Destroy()
    local tvol, tvoldb
    local function stvol()
        if tvoldb or not tvol then return end
        tvoldb = true
        for i,v in pairs(dis:GetChildren()) do if tostring(v) == 'Volcano' then tracerdata:Load(v.WaitForDescendant("Or", 30, false, true)"BasePart", "Volcano", "Vlc") end end
        tvoldb = false
        return
    end
    tracktbl.Volcano = {Function = stvol, Enabled = tvol}
    local function untvol()
        if tvoldb then return end
        tvoldb = true
        tvol = false
        for i,v in pairs(stuff.Tracers) do if i.Id == 'Vlc' then i:Unload() end end
        tvoldb = false
    end
    newtogglefuncs("VOLCANO", stvol, untvol)
    volc.Toggle.ApplyProperties{BackgroundColor3 = cols[tvol]}.MouseButton1Click:Connect(function()
        if tvoldb then return end
        tvol = not tvol
        tracktbl.Volcano.Enabled = tvol
        aligntoggle(volc, tvol)
        stuff.NameFuncs.VOLCANO[tvol]()
    end)
    
    --ptb 
    local ptb = basetoggle:Clone().ApplyProperties{
        Parent = tab_tracerpage,
        Name = "PTB"
    }
    ptb.Desc.Text = "    Press The Button"
    ptb.InfoPopup:Destroy()
    local tptb, tptbdb
    local function stptb()
        if tptbdb or not tptb then return end
        tptbdb = true
        for i,v in pairs(dis:GetChildren()) do if tostring(v) == 'Press The Button' then task.spawn(function() tracerdata:Load(v.WaitForDescendant("Trigger", 30, false, true)"MeshPart", "Button", "Ptb") end) end end
        tptbdb = false
        return
    end
    tracktbl['Press The Button'] = {Function = stptb, Enabled = tptb}
    local function untptb()
        if tptbdb then return end
        tptbdb = true
        tptb = false
        for i,v in pairs(stuff.Tracers) do if i.Id == 'Ptb' then i:Unload() end end
        tptbdb = false
    end
    newtogglefuncs("PTB", stptb, untptb)
    ptb.Toggle.ApplyProperties{BackgroundColor3 = cols[tptb]}.MouseButton1Click:Connect(function()
        if tptbdb then return end
        tptb = not tptb
        tracktbl['Press The Button'].Enabled = tptb
        aligntoggle(ptb, tptb)
        stuff.NameFuncs.PTB[tptb]()
    end)
    
    --gz 
    local gz = basetoggle:Clone().ApplyProperties{
        Parent = tab_tracerpage,
        Name = "GZ"
    }
    gz.Desc.Text = "    Green Zone"
    gz.InfoPopup:Destroy()
    local tgz, tgzdb
    local function stgz()
        if tgzdb or not tgz then return end
        tgzdb = true
        for i,v in pairs(dis:GetChildren()) do if tostring(v) == 'Green Zone' then task.spawn(function() tracerdata:Load(v.WaitForDescendant("Part", 30, false, true)"Part", "Zone", "Gz") end) end end
        tgzdb = false
        return
    end
    tracktbl['Green Zone'] = {Function = stgz, Enabled = tgz}
    local function untgz()
        if tgzdb then return end
        tgzdb = true
        tgz = false
        for i,v in pairs(stuff.Tracers) do if i.Id == 'Gz' then i:Unload() end end
        tgzdb = false
    end
    newtogglefuncs("GZ", stgz, untgz)
    gz.Toggle.ApplyProperties{BackgroundColor3 = cols[tgz]}.MouseButton1Click:Connect(function()
        if tgzdb then return end
        tgz = not tgz
        tracktbl.Volcano.Enabled = tgz
        aligntoggle(gz, tgz)
        stuff.NameFuncs.GZ[tgz]()
    end)
    
    
    --nuke
    local nuke = basetoggle:Clone().ApplyProperties{
        Parent = tab_tracerpage,
        Name = "NUKE"
    }
    nuke.Desc.Text = "    Nuclear Bomb"
    nuke.InfoPopup:Destroy()
    local tnb, tnkdb
    local function stnk()
        if tnkdb or not tnb then return end
        tnkdb = true
        for i,v in pairs(dis:GetChildren()) do if tostring(v) == 'Nuclear Bomb' then task.spawn(function() tracerdata:Load(v.WaitForDescendant("Point", 30, false, true)"BasePart", "Bomb", "Nuke") end) end end
        tnkdb = false
        return
    end
    tracktbl['Nuclear Bomb'] = {Function = stnk, Enabled = tnb}
    local function untnk()
        if tnkdb then return end
        tnkdb = true
        tnb = false
        for i,v in pairs(stuff.Tracers) do if i.Id == 'Nuke' then i:Unload() end end
        tnkdb = false
    end
    newtogglefuncs("NUKE", stnk, untnk)
    nuke.Toggle.ApplyProperties{BackgroundColor3 = cols[tnb]}.MouseButton1Click:Connect(function()
        if tnkdb then return end
        tnb = not tnb
        tracktbl.Volcano.Enabled = tnb
        aligntoggle(nuke, tnb)
        stuff.NameFuncs.NUKE[tnb]()
    end)
    
    spawnpopuphover(Instance.new"TextLabel".ApplyProperties(default).ApplyProperties{
        Size = UDim2.new(1,0,0,25),
        BackgroundColor3 = Color3.new(1/6,1/6,1/6),
        Parent = tab_tracerpage,
        Text = "  Other"
    }, defaultpopup:Clone().ApplyProperties{
        Text = "Similar in purpose, but not a tracer",
        Size = UDim2.new(0,150,0,50)
    })
end
stuff.Connections.DisasterTrack = dis.ChildAdded:Connect(function(v)
    local x = stuff.Misc.Tracking[tostring(v)]
    if x then x.Function(v) end
end)
stuff.Connections.Heartbeat = game.RunService.Heartbeat:Connect(function(diff)
    local ticks = stuff.Ticktable
    local homepage = menudata:GetMenu"Home"
    if homepage and homepage.Frame.Visible then
        homepage.Frame.MainText.Text = txtformat:format(myLastMessage or "...", formatnum(math.round(workspace.DistributedGameTime)))
        local lmsg = floor(tick() - stuff.Ticktable.SendMessage)
        homepage.Frame.Submit.Text = (lmsg >= 600 and "Ready!") or (lmsg <= 5 and "Sent!") or formatnum(600 - lmsg):match("%d%d:%d%d$")
    end
    if tick() - ticks.CheckMessage >= 15 then
        ticks.CheckMessage = 1/0
        local new = getMyMessage()
        if myLastMessage and new ~= myLastMessage then
            task.spawn(notify, {Title = "New message!", Text = new})
        end
        myLastMessage = new
        ticks.CheckMessage = tick()
    end
    
    --
    for i,v in pairs(stuff.Heartbeat) do
        v(diff)
    end
end)
stuff.Connections.RenderStep = game.RunService.RenderStepped:Connect(function(t)
    local root = getplayerpart(lp, true)
    if root then
        local x = 0
        for i,v in pairs(stuff.Tracers) do
            x = x + 1
            local t, a  = i.Tracer, i.Adornee
            if not (t.Parent and a:IsDescendantOf(game)) then continue end
            local dist = a.Position -  root.Position
            t.ApplyProperties{
                Size = Vector3.new(0.3,0.3,dist.Magnitude),
                CFrame = CFrame.new(root.Position, a.Position) + dist/2
            }
        end
    end
end)
--
menudata:SwitchTo"Home"
stuff.PhysicalStorage.Parent = workspace
ui.ApplyProperties{
    Name = http:GenerateGUID(false),
    Parent = game.CoreGui
}
