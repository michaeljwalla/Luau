--todo
--[[


]]
if shared.loaddebounce then return else shared.loaddebounce = true end
local function require(d, recache)
    shared.requirecache = shared.requirecache or {}
    if (typeof(d) ~= 'string') then return getfenv().require(d) end
    if d:find"^http" then return loadstring(game:HttpGet(d))()
    else
        if not recache and shared.requirecache[d] then return shared.requirecache[d] end
        local n, a = pcall(readfile, d..".lua") --loadfile lol
        assert(n, "No local module '"..d.."'")
        local chunk = loadstring(a)
        assert(chunk, "Error in local: "..d)
        shared.requirecache[d] = chunk()
        return shared.requirecache[d]
    end
end
require"bell/fly"
local visualizer = require"bell/Visualize"
local saver = require"bell/DataSaver"
local lp = game.Players.LocalPlayer
local mouse = lp:GetMouse()
local uis = game:GetService"UserInputService"

if not isfolder("PMapper") then
    makefolder("PMapper")
    makefolder("PMapper/Funcs")
    makefolder("PMapper/Saved") 
end

local function newPlayback()
    return {
        Name = "",
        RecordMetadata = { --can only be edited before starting the recording (wouldnt make sense if not)
            Type = "Distance",
            Distance = { Interval = 15, TotalSteps = 0 },
            Time = { Interval = 1/3, TimeLength = 0 },
        },
        WalkSpeed = 40,
        JumpHeight = 20,
        InvertPlayback = false,
        PlayPosition = 0,
        Steps = {},
        FollowMode = "Strict",
        DefaultFuzziness = 10,
    }
end
local curSave = newPlayback()
local settings = --[[saver.GetSave"PMapper/settings" or print("defaulted settings") or]] {
    LastPlayback = newPlayback(),
    VisualizePlayback = false,
    Currents = {
        WalkSpeed = 40,
        JumpHeight = 20
    },
    ViewDistance = 250,
    Dir = ""
}
settings.Paused, settings.Stopped, settings.Playbcking = false, true, false
local function savesettings()
    saver.SetSave("PMapper/settings", settings)
    return
end --savesettings()
local function hasprop(inst, prop, pcd)
    return pcd and inst[prop] or pcall(hasprop, inst, prop, true)
end
local function apply(inst, props)
    local parent = props.Parent
    props.Parent = nil
    for i,v in next, props do if hasprop(inst, i) then inst[i] = v end end
    if parent then inst.Parent = parent end
    return inst
end
local function gethum()
    return lp and lp.Character and lp.Character:FindFirstChild"Humanoid"
end
local function getroot()
    local h = gethum()
    return h and h.RootPart
end

local activator = require(game:GetService("ReplicatedStorage").Activatables.Toys).ButtonEffect
local toys = workspace.Toys
local toyevent = game:GetService("ReplicatedStorage").Events.ToyEvent

local function rethread(n)
    syn.set_thread_identity(n)
end
local function activate(what)
    if not toys:FindFirstChild(what) then return end
    rethread(2)
    --toyevent:FireServer(what)
    activator(lp, toys[what])
    rethread(7)
    return
end
local function getclosesttoy()
    local root = getroot()
    if not root then return end
    local closest, dist
    for i,v in next, toys:GetChildren() do
        if not (v:FindFirstChild"Platform" and v:FindFirstChild"ServerEffect") then continue end
        local cur, cdist = v, (v.Platform.Position - root.Position).Magnitude
        if not dist or dist > cdist then closest, dist = cur, cdist end
    end
    return closest, dist
end
local function rand(len)
    local result = ""
    for i = 1, len do result = result..string.char(math.random(0,255)) end
    return result
end

--
local data =  {
    Gui = nil, --nothing,
    Connections = {}
}
shared.PMapper = data
local defaults = {
    RichText = true,
    BackgroundColor3 = Color3.new(1/3,1/3,1/3), 
    TextColor3 = Color3.new(1,1,1),
    TextSize = 14,
    TextXAlignment = "Center",
    Font = 18, --10, 18 (17 non bold),
    ScrollBarThickness = 1,
    CanvasSize = UDim2.new(0,0,0,0),
    AutomaticCanvasSize = "Y",
    TextWrapped = true,
}
local sgui = apply(Instance.new"ScreenGui", {
    Parent = game.CoreGui,
    Name = rand(12),
})
data.Gui = sgui
local main = apply(apply(Instance.new"TextButton", defaults), {
    Parent = sgui,
    Size = UDim2.new(0,350,0,100),
    Visible = false,
    Position = UDim2.new(0.5,-175,1,-100)
})
local mainviewtoggle = apply(apply(Instance.new"TextButton", defaults), {
    Parent = sgui,
    Text = "/\\",
    Size = UDim2.fromOffset(25,15),
    Position = UDim2.new(0.5,-175,1,-16)
})
mainviewtoggle.MouseButton1Click:Connect(function()
    main.Visible = not main.Visible
    mainviewtoggle.Position = main.Visible and UDim2.new(0.5,-175,1,-116) or UDim2.new(0.5,-175,1,-16)
    mainviewtoggle.Text = main.Visible and "\\/" or "/\\"
    return
end)
local playbacker = apply(apply(Instance.new"Frame", defaults), {
    Parent = main,
    Size = UDim2.new(0.5,0,1,0)
})
local playbacktoggler = apply(apply(Instance.new"TextButton", defaults), {
    Parent = playbacker,
    Text = "▶",
    Size = UDim2.fromOffset(25,25),
    Position = UDim2.new(0,25,0,25)
})
local playbackrewinder = apply(playbacktoggler:Clone(), {
    Parent = playbacker,
    Text = "<<",
    Position = UDim2.new(0,0,0,25)
})
local playbackseeker = apply(playbacktoggler:Clone(), {
    Parent = playbacker,
    Text = ">>",
    Position = UDim2.new(0,50,0,25)
})
local playbackcompletion = apply(apply(Instance.new"TextLabel", defaults), {
    Parent = playbacker,
    Text = "0 / 0",
    TextSize = 12,
    Position = UDim2.new(0,75,0,25),
    Size = UDim2.new(1,-75,0,25)
})
local playbackname = apply(apply(Instance.new"TextBox", defaults), {
    Parent = playbacker,
    Text = "",
    PlaceholderText = "File to playback",
    TextSize = 12,
    Size = UDim2.new(1,0,0,25),
    ClearTextOnFocus = false
})
local playbacklazy = apply(apply(Instance.new"TextButton", defaults),  {
    Parent = playbacker,
    Text = "F - Strict",
    TextSize = 12,
    Size = UDim2.new(0,60,0,25),
    Position = UDim2.new(0,0,0,50)
})

playbacklazy.MouseButton1Click:Connect(function()
    settings.LastPlayback.FollowMode = settings.LastPlayback.FollowMode == 'Strict' and 'Lazy' or 'Strict'
    playbacklazy.Text = "F - "..settings.LastPlayback.FollowMode
    return
end)
local playbackfuzziness = apply(apply(Instance.new"TextBox", defaults),  {
    Parent = playbacker,
    Text = "Fz ≈ "..settings.LastPlayback.DefaultFuzziness,
    PlaceholderText = "Approx",
    TextSize = 12,
    Size = UDim2.new(0,50,0,25),
    ClearTextOnFocus = true,
    Position = UDim2.new(0,60,0,50),
})
local lastfuzzy
playbackfuzziness.FocusLost:Connect(function()
    playbackfuzziness.Text = playbackfuzziness.Text:sub(1,12)
    local tryspeed = tonumber(playbackfuzziness.Text)
    if not tryspeed then playbackfuzziness.Text = "Fz ≈ "..settings.LastPlayback.DefaultFuzziness return end
    tryspeed = math.clamp(math.round(tryspeed), 1, 50)
    playbackfuzziness.Text = "Fz ≈ "..tryspeed
    lastfuzzy = tryspeed
    return
end)
local playbackvisuals = apply(apply(Instance.new"TextButton", defaults),  {
    Parent = playbacker,
    Text = "Visual - OFF",
    TextSize = 11,
    Size = UDim2.new(0,65,0,25),
    Position = UDim2.new(0,110,0,50)
})

local playbackinverter = apply(apply(Instance.new"TextButton", defaults),  {
    Parent = playbacker,
    Text = "⇄ - OFF",
    TextSize = 12,
    Size = UDim2.new(0,50,0,25),
    Position = UDim2.new(0,0,1,-25)
})
playbackinverter.MouseButton1Click:Connect(function()
    settings.LastPlayback.InvertPlayback = not settings.LastPlayback.InvertPlayback
    playbackinverter.Text = "⇄ - "..(settings.LastPlayback.InvertPlayback and "ON" or "OFF")
end)
local playbackwalkspeed = apply(playbackname:Clone(), {
    Parent = playbacker,
    PlaceholderText = "WalkSpeed",
    ClearTextOnFocus = true,
    TextSize = 10,
    Position = UDim2.new(0,50,1,-25),
    Size = UDim2.new(0,62.5,0,25)
})
local playbackjumppower = apply(playbackwalkspeed:Clone(), {
    Parent = playbacker,
    PlaceholderText = "JumpHeight",
    Position = UDim2.new(0,113,1,-25)
})

playbackwalkspeed.FocusLost:Connect(function()
    if settings.Playbacking then return end
    local tryspeed = tonumber(playbackwalkspeed.Text)
    tryspeed = tryspeed or settings.LastPlayback.WalkSpeed
    playbackwalkspeed.Text = "WS: "..tryspeed
    return
end)
playbackjumppower.FocusLost:Connect(function()
    if settings.Playbacking then return end
    local tryspeed = tonumber(playbackjumppower.Text)
    tryspeed = tryspeed or settings.LastPlayback.JumpHeight
    playbackjumppower.Text =  "JH: "..tryspeed
    return
end)
local function timeformat(n)
    local seconds = n % 60
    local minutes = tostring((n-seconds) / 60)
    seconds = tostring(seconds)
    return (#minutes < 2 and "0" or "")..minutes..":"..(#seconds < 2 and "0" or "")..seconds
    
end

local function getplayback(name)
    return saver.GetSave("PMapper/Saved/"..settings.Dir..tostring(name))
end
local function saveplayback(name, save)
    saver.SetSave("Pmapper/Saved/"..settings.Dir..tostring(name), save or settings.LastPlayback)
    return
end
local function notify(options) --Title, Text, Duration, Icon
    options.Text, options.Title = tostring(options.Text), tostring(options.Title)
    game.StarterGui:SetCore("SendNotification", options)
    return true
end
local function syncplaybackgui()
    local lastpb = settings.LastPlayback
    playbackname.Text = lastpb.Name
    playbackcompletion.Text = lastpb.RecordMetadata.Type == 'Time' and ('%s / %s'):format(timeformat(lastpb.PlayPosition),timeformat(lastpb.RecordMetadata.Time.TimeLength)) or lastpb.PlayPosition.." / "..lastpb.RecordMetadata.Distance.TotalSteps
    playbacklazy.Text = "F - "..settings.LastPlayback.FollowMode
    playbackvisuals.Text = "Visual - "..(settings.VisualizePlayback and "ON" or "OFF")
    playbackfuzziness.Text = "Fz ≈ "..settings.LastPlayback.DefaultFuzziness
    playbackinverter.Text = "⇄ - "..(lastpb.InvertPlayback and "ON" or "OFF")
    playbackwalkspeed.Text = "WS: "..lastpb.WalkSpeed
    playbackjumppower.Text = "JH: "..lastpb.JumpHeight
    playbacktoggler.Text = not settings.Playbacking and "▶" or "⏸" 
end
syncplaybackgui()
local function roundnum(n)
    return tonumber(tostring(n):match"%-?%d*%.?%d?%d?%d?")
end
local function packvec(vec)
    return {roundnum(vec.X), roundnum(vec.Y), roundnum(vec.Z)}
end
local function revectorize(tbl)
    return Vector3.new(unpack(tbl))
end
local lastvisualized = {}
local function visualizeplayback(data, toggle)
    for i,v in next, lastvisualized do pcall(visualizer.Destroy, v) rawset(lastvisualized, i, nil) end
    if not toggle then return end
    for i,v in next, data do
        local pos, draw = revectorize(v.Position)
        if v.Type == 'Toy' then
            draw = visualizer.Create{Type = "Quad", At = {pos}, Color = visualizer.Colors.Purple, MaxDistance = settings.ViewDistance}
        elseif v.Type == 'Jump' then
            draw = visualizer.Create{Type = "Circle", At = {pos}, Color = visualizer.Colors.Orange, Mul = 15, MaxDistance = settings.ViewDistance}
        elseif v.Type == 'Parachute' then
            draw = visualizer.Create{Type = "Quad", At = {pos}, Color = visualizer.Colors.Pink, MaxDistance = settings.ViewDistance}
        else
            draw = visualizer.Create{Type ="Circle", At = {pos}, Color = visualizer.Colors.Blue,MaxDistance = settings.ViewDistance,}
        end
        table.insert(lastvisualized, draw)
    end
end
playbackvisuals.MouseButton1Click:Connect(function()
    settings.VisualizePlayback = not settings.VisualizePlayback
    playbackvisuals.Text = "Visual - "..(settings.VisualizePlayback and "ON" or "OFF")
    visualizeplayback(settings.LastPlayback.Steps, settings.VisualizePlayback)
    return
end)
playbackname.FocusLost:Connect(function()
    
    playbackname.Text = playbackname.Text:sub(1,32):gsub("[^/a-zA-Z0-9%-_]*", "")
    if playbackname.Text == "" then
        playbackname.Text = settings.LastPlayback.Name
        return
    end
    local pb = getplayback(playbackname.Text)
    if pb then settings.LastPlayback = pb visualizeplayback(pb.Steps, settings.VisualizePlayback) notify{Title = "Success", Text = "Loaded playback: "..playbackname.Text}
    else notify{Title = "File not found", Text = "No save for: '"..playbackname.Text.."'"}
    end
    --do stuff
    
    --savesettings()
    syncplaybackgui()
end)
--end playback tools
local newpber = apply(apply(Instance.new"Frame", defaults),{
    Parent = main,
    Position = UDim2.new(0.5),
    Size = UDim2.new(0.5,0,1,0)
})
local newpbname = apply(playbackname:Clone(), {
    Parent = newpber,
    PlaceholderText = "Create new playback ↓",
    ZIndex = 69,
    Text = ""
})

local newpbrecord = apply(apply(Instance.new"TextButton", defaults), {
    Text = "◉",
    Size = UDim2.fromOffset(25,25),
    Position = UDim2.fromOffset(0,25),
    TextSize = 12,
    Font = 0,
    Parent = newpber
})
local newpbreset = apply(newpbrecord:Clone(), {
    Text = "■",
    TextYAlignment = "Top",
    TextSize = 14,
    Parent = newpber,
    Position = UDim2.fromOffset(25,25)
})

local newpbclear = apply(newpbrecord:Clone(), {
    Text = "⇌",
    Font = 0,
    Parent = newpber,
    Position = UDim2.fromOffset(50,25)
})
local newpbmode = apply(apply(Instance.new"TextButton", defaults), {
    Parent = newpber,
    Text = "Steps - 0",
    TextSize = 12,
    Position = UDim2.new(0,75,0,25),
    Size = UDim2.new(0,100,0,25)
})

local newpbinterval = apply(apply(Instance.new"TextBox", defaults), {
    Parent = newpber,
    Text = "Rec @ 0.33s",
    Visible = true,
    TextSize = 12,
    Position = UDim2.new(1,1,0,26),
    Size = UDim2.new(0,74,0,23),
    ClearTextOnFocus = true
})

local newpblazy = apply(apply(Instance.new"TextButton", defaults),  {
    Parent = newpber,
    Text = "F - Strict",
    TextSize = 12,
    Size = UDim2.new(0,60,0,25),
    Position = UDim2.new(0,0,0,50)
})
newpblazy.MouseButton1Click:Connect(function()
    if not (settings.Stopped or settings.Paused) then return end
    curSave.FollowMode = curSave.FollowMode == 'Strict' and 'Lazy' or 'Strict'
    newpblazy.Text = "F - "..curSave.FollowMode
    return
end)

local newpbfuzziness = apply(apply(Instance.new"TextBox", defaults),  {
    Parent = newpber,
    Text = "Fz ≈ 5",
    PlaceholderText = "Approx",
    TextSize = 12,
    Size = UDim2.new(0,65,0,25),
    ClearTextOnFocus = true,
    Position = UDim2.new(0,60,0,50),
})
local lastfuzzynew
newpbfuzziness.FocusLost:Connect(function()
    if not (settings.Stopped or settings.Paused) then return end
    newpbfuzziness.Text = newpbfuzziness.Text:sub(1,12)
    local tryspeed = tonumber(newpbfuzziness.Text)
    if not tryspeed then newpbfuzziness.Text = "Fz ≈ "..curSave.DefaultFuzziness return end
    tryspeed = math.clamp(math.round(tryspeed), 1, 50)
    newpbfuzziness.Text = "Fz ≈ "..tryspeed
    curSave.DefaultFuzziness = tryspeed
    return
end)

local newpbinverter = apply(apply(Instance.new"TextButton", defaults),  {
    Parent = newpber,
    Text = "⇄ - OFF",
    TextSize = 12,
    Size = UDim2.new(0,50,0,25),
    Position = UDim2.new(1,-50,1,-50)
})
newpbinverter.MouseButton1Click:Connect(function()
    if not (settings.Stopped or settings.Paused) then return end
    curSave.InvertPlayback = not curSave.InvertPlayback
    newpbinverter.Text = "⇄ - "..(curSave.InvertPlayback and "ON" or "OFF")
end)
local newpbwalkspeed = apply(playbackname:Clone(), {
    Parent = newpber,
    PlaceholderText = "WalkSpeed",
    ClearTextOnFocus = true,
    TextSize = 10,
    Position = UDim2.new(0,0,1,-25),
    Size = UDim2.new(0,63,0,25)
})
local newpbjumppower = apply(newpbwalkspeed:Clone(), {
    Parent = newpber,
    PlaceholderText = "JumpHeight",
    Position = UDim2.new(0,63,1,-25)
})

newpbwalkspeed.FocusLost:Connect(function()
    if settings.Playbacking or #curSave.Steps ~= 0 then return end
    local tryspeed = tonumber(newpbwalkspeed.Text)
    tryspeed = tryspeed or curSave.WalkSpeed
    newpbwalkspeed.Text = "WS: "..tryspeed
    curSave.WalkSpeed = tryspeed
    settings.Currents.WalkSpeed = tryspeed
    return
end)
newpbjumppower.FocusLost:Connect(function()
    if settings.Playbacking or #curSave.Steps ~= 0 then return end
    local tryspeed = tonumber(newpbjumppower.Text)
    tryspeed = tryspeed or curSave.JumpHeight
    newpbjumppower.Text = "JH: "..tryspeed
    curSave.JumpHeight = tryspeed
    settings.Currents.JumpHeight = tryspeed
    return
end)
local newpbsave = apply(apply(Instance.new"TextButton", defaults), {
    Parent = newpber,
    Text = "Save",
    Size = UDim2.new(0,50,0,25),
    Position = UDim2.new(1,-50,1,-25)
})

local function syncnewplaybackgui()
    newpbname.Text = curSave.Name
    newpbrecord.Text = (settings.Stopped and "◉") or (settings.Paused and "▶") or "⏸"
    if curSave.RecordMetadata.Type == 'Distance' then
        newpbmode.Text = "Steps - "..#curSave.Steps
    else
        newpbmode.Text = "Len - "..timeformat(math.floor(#curSave.Steps * curSave.RecordMetadata.Time.Interval))
    end
    newpblazy.Text = "F - "..curSave.FollowMode
    newpbfuzziness.Text = "Fz ≈ "..curSave.DefaultFuzziness
    newpbinverter.Text = "⇄ - "..(curSave.InvertPlayback and "ON" or "OFF")
    newpbwalkspeed.Text = "WS: "..curSave.WalkSpeed
    newpbjumppower.Text = "JH: "..curSave.JumpHeight
    
    newpbinterval.Text = curSave.RecordMetadata.Type == 'Distance' and ('Rec @ %sm'):format(math.round(curSave.RecordMetadata.Distance.Interval*100)/100) or ("Rec @ %ss"):format(math.round(curSave.RecordMetadata.Time.Interval*100)/100)
    
end syncnewplaybackgui()
newpbsave.MouseButton1Click:Connect(function()
    local filename = newpbname.Text
    curSave.Name = newpbname.Text:match("[a-zA-Z0-9%-_]*$")
    if #filename < 1 then return notify{Title = "Save fail", Text = "Missing filename"}
    elseif not settings.Stopped then return notify{Title = "Save fail", Text = "End the recording first"}
    elseif #curSave.Steps < 1 then return notify{Title = "Save fail", Text = "No movement to save!"}
    end 
    if curSave.RecordMetadata.Type == 'Time' then
        curSave.RecordMetadata.Time.TimeLength = math.floor(#curSave.Steps * curSave.RecordMetadata.Time.Interval)
    else
        curSave.RecordMetadata.Distance.TotalSteps = #curSave.Steps
    end
    saveplayback(filename, curSave)
    syncnewplaybackgui()
    notify{Title = "Save success", Text = "/PMapper/Saved/"..settings.Dir..filename..".bll"}
    return
end)
newpbinterval.FocusLost:Connect(function()
    if not (settings.Stopped or settings.Paused) then return end
    newpbinterval.Text = newpbinterval.Text:sub(1,12)
    local tryspeed = tonumber(newpbinterval.Text) or (curSave.RecordMetadata.Type == 'Distance' and curSave.RecordMetadata.Distance.Interval) or curSave.RecordMetadata.Time.Interval
    
    tryspeed = (curSave.RecordMetadata.Type == 'Distance' and math.clamp(tryspeed, 0.5, 35)) or math.clamp(tryspeed, 0.1, 5)
    
    --newpbinterval.Text = curSave.RecordMetadata.Type == 'Distance' and ('Rec @ %sm'):format(math.round(curSave.RecordMetadata.Distance.Interval*100)/100) or ("Rec @ %ss"):format(math.round(curSave.RecordMetadata.Time.Interval*100)/100)
    curSave.RecordMetadata[curSave.RecordMetadata.Type].Interval = tryspeed
    syncnewplaybackgui()
end)
newpbmode.MouseButton1Click:Connect(function()
    if #curSave.Steps ~= 0 then return end
    curSave.RecordMetadata.Type = curSave.RecordMetadata.Type == 'Distance' and 'Time' or 'Distance'
    syncnewplaybackgui()
end)
newpbreset.MouseButton1Click:Connect(function()
    settings.Paused = false
    settings.Stopped = true
    syncnewplaybackgui()
end)
newpbclear.MouseButton1Click:Connect(function()
    settings.Paused = false
    settings.Stopped = true
    curSave = newPlayback()
    visualizer.ClearAllDrawings()
    syncnewplaybackgui()
end)

local recdb, humcons = nil, {}
pcall(data.cleanup)
data.cleanup = function()
    data.Gui:Destroy()
    for i,v in next, data.Connections do v:Disconnect() end
    settings.Stopped = true
    settings.Playbacking = false
    visualizer.ClearAllDrawings()
end

local function plotjump(steps, root, starttime, hum, precision, nojumpdelay) 
    table.insert(steps, {
        Position = packvec(root.Position),
        Time = tick()-starttime,
        JumpHeight = hum.JumpHeight,
        Precision = precision,
        NJD = nojumpdelay,
        Type = "Jump"
    })
    visualizer.Create{Type = "Circle", At = {root.Position}, Color = visualizer.Colors.Orange, Mul = 15, MaxDistance = settings.ViewDistance}
end
local function plottoy(steps, starttime, hum, precision, toy) 
    table.insert(steps, {
        Position = packvec(toy.Platform.Position + Vector3.new(0, 5)),
        Time = tick()-starttime,
        JumpHeight = hum.JumpHeight,
        Precision = precision,
        Type = "Toy",
        Toy = toy.Name
    })
    visualizer.Create{Type = "Quad", At = {toy.Platform.Position + Vector3.new(0, 5)}, Color = visualizer.Colors.Purple, MaxDistance = settings.ViewDistance}

end
local function lastnontoy(ls)
    for i = #ls, 1, -1 do
        local entry = ls[i]
        if entry.Type ~= "Toy" then return entry end
    end
    return ls[#ls]
end
local starttime = tick()
local tryparachute = getsenv(lp.PlayerScripts.Controls).onJumpRequest
local function plotparachute(steps, root, starttime, hum, precision) 
    table.insert(steps, {
        Position = packvec(root.Position),
        Time = tick()-starttime,
        --JumpHeight = hum.JumpHeight,
        Precision = precision,
        Type = "Parachute"
    })
    visualizer.Create{Type = "Quad", At = {root.Position}, Color = visualizer.Colors.Pink, MaxDistance = settings.ViewDistance}
end
newpbname.FocusLost:Connect(function()
    local loadprev, endat = newpbname.Text:find("\\unpack%s.")
    if loadprev then
        local fname = newpbname.Text:sub(endat):gsub("[^/a-zA-Z0-9%-_]*", "")
        
        local pb = getplayback(fname)
        if pb then
            local insertto = curSave.Steps
            for i,v in next, pb.Steps do table.insert(insertto, v) end
            visualizeplayback(curSave.Steps, true)
            syncnewplaybackgui()
            
            notify{Title = "Success", Text = "Unpacked: "..fname}
        else 
            notify{Title = "File not found", Text = "No save for: '"..fname.."'"}
        end
        return
    else
        loadprev, endat = newpbname.Text:find("\\jumpdelay%s.")
        if loadprev then
            local fname = newpbname.Text:sub(endat):gsub("[^%.0-9r]*", "")
            local num = tonumber(fname)
            if (fname == 'r') then 
                curSave.JumpDelay = nil
                notify{Title = "Success", Text = "Removed jump delay (if active)"}
            elseif num then
                curSave.JumpDelay = num
                notify{Title = "Success", Text = "Jump delay override: "..fname}
            else 
                notify{Title = "Failure", Text = "Invalid number"}
            end
            syncnewplaybackgui()
            return
        else
            loadprev, endat = newpbname.Text:find("\\dir%s.")
            if loadprev then
                local fname = newpbname.Text:sub(endat):gsub("[^/a-zA-Z0-9%-_%.]*", "")
                if fname == '.' then
                    settings.Dir = ""
                    notify{Title = "Success", Text = "Moved to parent dir /PMapped/Saved"}
                elseif isfolder("PMapper/Saved/"..fname) then
                    settings.Dir = fname.."/"
                    notify{Title = "Success", Text = "Moved to dir: "..fname}
                else 
                    notify{Title = "File not found", Text = "No directory: '"..fname.."'"}
                end
                syncnewplaybackgui()
                return
            else
                loadprev, endat = newpbname.Text:find("\\jumpfuzz%s.")
                if loadprev then
                    local fname = newpbname.Text:sub(endat):gsub("[^%.0-9r]*", "")
                    local num = tonumber(fname)
                    if (fname == 'r') then 
                        curSave.JumpFuzz = nil
                        notify{Title = "Success", Text = "Reset jump precision"}
                    elseif num then
                        curSave.JumpFuzz = num
                        notify{Title = "Success", Text = "Jump precision override: "..fname}
                    else 
                        notify{Title = "Failure", Text = "Invalid number"}
                    end
                    syncnewplaybackgui()
                    return
                else
                    loadprev, endat = newpbname.Text:find("\\del%s.")
                    if loadprev then
                        local fname = newpbname.Text:sub(endat):gsub("[^%.0-9r]*", "")
                        local num = tonumber(fname)
                        if num then
                            table.remove(curSave.Steps, num)
                            visualizeplayback(curSave.Steps, true)
                            notify{Title = "Success", Text = "Deleted step: "..fname}
                        else 
                            notify{Title = "Failure", Text = "Invalid number"}
                        end
                        syncnewplaybackgui()
                        return
                    end
                end
            end
        end
    end
    newpbname.Text = newpbname.Text:sub(1,32):gsub("[^/a-zA-Z0-9%-_]*", "")
    curSave.Name = newpbname.Text
end)
newpbrecord.MouseButton1Click:Connect(function()
    if recdb then return end
    for i,v in next, humcons do v:Disconnect() end
    recdb = true
    settings.Paused = not settings.Paused
    if settings.Stopped then settings.Stopped = false settings.Paused = false end
    syncnewplaybackgui()
    if not settings.Paused then
        local hum = gethum()
        local root = hum.RootPart
        if not (hum and root) then return end
        settings.Currents.WalkSpeed = curSave.WalkSpeed
        settings.Currents.JumpHeight = curSave.JumpHeight
        local steps = curSave.Steps
        visualizer.Create{Type = "Circle", At = {lp}, Color = visualizer.Colors.Blue, MaxDistance = settings.ViewDistance}
        
        local lastdrawings
        starttime, lastdrawings = tick(), {}
        local lastupd = starttime
        
        humcons[1] =  hum.Died:Connect(function()
            settings.Stopped = true
            settings.Paused = false
            visualizer.ClearAllDrawings()
        end)
        data.Connections.OnDeath = humcons[1]
        humcons[2] = hum.StateChanged:Connect(function(old, new)
            if settings.Paused or settings.Stopped then for i,v in next, humcons do v:Disconnect() end return end
            if new == Enum.HumanoidStateType.Jumping then
                plotjump(steps, root, starttime, hum, settings.JumpFuzz or 5)
            end
        end)
        data.Connections.OnJump = humcons[2]
        humcons[3] = root.ChildAdded:Connect(function(inst)
            if inst:IsA"BodyVelocity" then plotparachute(steps, root, starttime, hum, 10) end
        end)
        data.Connections.OnParachuteOpen = humcons[3]
        humcons[4] = root.ChildRemoved:Connect(function(inst)
            if inst:IsA"BodyVelocity" and hum.FloorMaterial.Name == 'Air' then plotparachute(steps, root, starttime, hum, 10) end
        end)
        data.Connections.OnParachuteClose = humcons[4]
        humcons[5] = uis.InputBegan:Connect(function(key, focused)
            if key.KeyCode.Name == "E" then --focused activates anyways when pressing e ok
                local toy, dist = getclosesttoy()
                if dist < 30 then plottoy(steps, starttime, hum, 5, toy) end
            end
        end)
        data.Connections.OnToyUse = humcons[5]
        recdb = false
        local sticky
        while task.wait() and not (settings.Stopped or settings.Paused) do
            local root = getroot()
            if not getroot then 
                visualizer.ClearAllDrawings() 
                break
            elseif curSave.RecordMetadata.Type == 'Distance' and (#steps == 0 or (root.Position - revectorize(lastnontoy(steps).Position)).Magnitude > curSave.RecordMetadata.Distance.Interval) then
                local newpos = root.Position
                table.insert(steps, {
                    Position = packvec(newpos),
                    --Time = tick()-starttime,
                    Precision = curSave.DefaultFuzziness,
                    Type = "Move"
                })
                visualizer.Create{
                    Type ="Circle", 
                    At = {root.Position}, 
                    Color = visualizer.Colors.Blue,
                    MaxDistance = settings.ViewDistance,
                }
                sticky = (sticky and pcall(visualizer.Destroy, sticky) and false) or visualizer.Create{
                    Type = "Line",
                    At = {lp, revectorize(steps[#steps].Position)},
                    Color = visualizer.Colors.Blue,
                    MaxDistance = settings.ViewDistance
                }
            elseif curSave.RecordMetadata.Type == 'Time' and (#steps == 0 or tick()-lastupd >= curSave.RecordMetadata.Time.Interval ) then
                lastupd = tick()
                local newpos = root.Position
                table.insert(steps, {
                    Position = packvec(newpos),
                    Time = tick()-starttime,
                    Precision = curSave.DefaultFuzziness,
                    Type = "Move"
                })
                visualizer.Create{
                    Type ="Circle", 
                    At = {root.Position}, 
                    Color = visualizer.Colors.Green,
                    MaxDistance = settings.ViewDistance,
                }
                visualizer.Create{
                    Type = "Line",
                    At = {lp, revectorize(steps[#steps].Position)},
                    Color = visualizer.Colors.Green,
                    MaxDistance = settings.ViewDistance
                }
                    --new bind, remove old bind from player and put onto prev two dots
            end
            syncnewplaybackgui()
        end
        pcall(visualizer.Destroy, sticky)
        for i,v in next, humcons do v:Disconnect() end
    end
    recdb = false
end)
data.Connections.ForceTryLog = uis.InputBegan:Connect(function(key, focused)
    if key.KeyCode.Name == 'Space' and uis:IsKeyDown(Enum.KeyCode.RightControl) then
        plotparachute(curSave.Steps, getroot(), starttime, gethum(), 40)
        --plotjump(curSave.Steps, getroot(), starttime, gethum(), 2, true) --force plot
        syncnewplaybackgui()
    end     
end)
data.Connections.MovementHandler = game.RunService.RenderStepped:Connect(function()
    local hum = gethum()
    if not hum then return end
    hum.UseJumpPower = false
    hum.WalkSpeed = settings.Currents.WalkSpeed or hum.WalkSpeed
    hum.JumpHeight = settings.Currents.JumpHeight or hum.JumpHeight
end)
local walkingat
local function walkto(entry, playbacked)
    local hum = gethum()
    local root = hum.RootPart
    if not hum and root then return elseif data.Connections.PlaybackDeathCheck then data.Connections.PlaybackDeathCheck:Disconnect() end
    local pos = not playbacked and entry.Position or revectorize(entry.Position)
    data.Connections.PlaybackDeathCheck = hum.Died:Connect(function()
        settings.LastPlayback = false
        pos = nil --ok?
    end)
    walkingat = pos
    while task.wait() and (not playbacked or settings.Playbacking) and walkingat == pos and (pos - root.Position).Magnitude > entry.Precision do
        hum.WalkToPoint = pos
    end
    return
end
local function nextpos(steps, pos)
    return steps[pos]
end
local function nextposlazy(steps, root)
    local index, shortest = 1, revectorize(steps[1].Position)
    for i, entry in next, steps do
        if entry.Type == 'Parachute' then continue end
        local p = revectorize(entry.Position)
        if math.abs(p.Y - root.Position.Y) <= settings.LastPlayback.DefaultFuzziness and (root.Position - p).Magnitude < (root.Position - shortest).Magnitude then index, shortest = i, p end
    end
    return index, shortest
end
local colassign = {
    Move = visualizer.Colors.Blue,
    Jump = visualizer.Colors.Orange,
    TimedMove = visualizer.Colors.Green,
    Toy = visualizer.Colors.Purple,
    Parachute = visualizer.Colors.Pink
}
local extassign = {
    Jump = function(hum, toy, playback, entry)
        if playback.JumpDelay and not entry.NJD then
            while settings.Playbacking and hum.FloorMaterial.Name == 'Air' do task.wait(playback.JumpDelay) end
            task.wait(playback.JumpDelay) 
        end
        
        hum.Jump = true
        end,
    Toy = function(hum, toy, playback) activate(toy) end,
    Parachute = tryparachute
}
local function runplayback(playback)
    local steps = playback.Steps
    if #steps < 1 then return end
    settings.Playbacking = true
    local hum, root = gethum(), getroot()
    local step = (playback.FollowMode == 'Lazy' and nextposlazy(steps, root)) or (playback.InvertPlayback and #steps or playback.PlayPosition+1)
    
    
    if playback.RecordMetadata.Type == 'Distance' then
        playback.PlayPosition = step
        syncplaybackgui()
        local sticky
        local increment = playback.InvertPlayback and -1 or 1
        rethread(2) --func should be task.spawned or coroutined
        while task.wait() and settings.Playbacking and step > 0 and step <= #steps do
            local nextstep = steps[step]
            if settings.VisualizePlayback then
                sticky = (sticky and pcall(visualizer.Destroy,sticky) and false) or visualizer.Create{
                    At = {lp, revectorize(nextstep.Position)},
                    Color = colassign[nextstep.Type],
                    Type = 'Line',
                    MaxDistance = settings.ViewDistance
                }
            end
            rethread(7)
            syncplaybackgui()
            rethread(2)
            walkto(nextstep, true)
            if not settings.Playbacking then break 
            elseif nextstep.Type ~= "Move" then extassign[nextstep.Type](hum, nextstep.Toy, playback, nextstep) end
            --finish playback
            
            step = step + increment
            playback.PlayPosition = step
            --if step > #steps then break end --yea messed up the inversion so needs 2 checks now
        end
        playback.PlayPosition = math.clamp(step, 0, #steps)
        pcall(visualizer.Destroy, sticky)
        settings.Playbacking = false 
        rethread(7)
        syncplaybackgui()
        rethread(2)
    else
        
    end
end
local runnerdebounce
playbacktoggler.MouseButton1Click:Connect(function()
    if runnerdebounce then return else runnerdebounce = true end
    if #settings.LastPlayback.Steps < 1 then runnerdebounce = false return end
    settings.Playbacking = not settings.Playbacking
    settings.LastPlayback.PlayPosition = settings.LastPlayback.PlayPosition == #settings.LastPlayback.Steps and 0 or settings.LastPlayback.PlayPosition
    if settings.Playbacking then
        playbacktoggler.Text = "⏸" 
        settings.Currents.WalkSpeed = settings.LastPlayback.WalkSpeed
        settings.Currents.JumpHeight = settings.LastPlayback.JumpHeight
        task.spawn(runplayback, settings.LastPlayback)
    else
        playbacktoggler.Text = "▶" 
    end
    runnerdebounce = false
end)
shared.loaddebounce = false