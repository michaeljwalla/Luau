if shared.walkercons then shared.walkercons:cleanup() end -- in case of rerun
shared.walkercons = {}
local function require(d, recache)
    shared.requirecache = shared.requirecache or {}
    if (typeof(d) ~= 'string') then return getfenv().require(d) end
    if d:find"^http" then return loadstring(game:HttpGet(d))()
    else
        if not recache and shared.requirecache[d] then return shared.requirecache[d] end
        local n, a = pcall(readfile, d..".lua") --loadfile lol
        assert(n, "No local module '"..d.."'")
        local chunk = loadstring(a)
        assert(chunk, "Error in local: "..d)
        shared.requirecache[d] = chunk()
        return shared.requirecache[d]
    end
end
local visualizer = require"bell/Visualize"
local saver = require"bell/DataSaver"
local mover = require"bell/movement"

local lp = game.Players.LocalPlayer
local module = {}
local rethread = syn and syn.set_thread_identity or setthreadidentity or error"unsupported"
local activator = require(game:GetService("ReplicatedStorage").Activatables.Toys).ButtonEffect
local toys = workspace.Toys
local toyevent = game:GetService("ReplicatedStorage").Events.ToyEvent
local threadmt, extassign, settings = {}, {}, {
    Playbacking = false,
    VisualizePlayback = false,
    LastPlayback = nil, --later
    LastDeath = 0,
    cached = {},
}
shared.walkercache = settings.cached
local create, resume, running = coroutine.create, coroutine.resume, coroutine.running
local responses = {
    [-4] ='(Unstarted)',
    [-3] ='(Incomplete)',
    [-2] ='(F) Invalid list load',
    [-1] ='(F) Invalid/missing save',
    [0] = '(Completed)',
    [1] = '(F) Out of time',
    [2] = '(F) Character instability', --aka death/respawn
    [3] = '(Exited)'
}
local drawinghelp = {Move = {'Circle',visualizer.Colors.Blue},Jump = {'Circle',visualizer.Colors.Orange,15},Parachute = {'Quad',visualizer.Colors.Pink},Toy = {'Quad',visualizer.Colors.Purple}}
local wait = task.wait


local function newplayback(ws, jh, poss)
    return {
        WalkSpeed = ws,
        JumpHeight = jh,
        InvertPlayback = false,
        Steps = poss,
        FollowMode = "Strict", 
    }
end

local function gethum()
    return lp and lp.Character and lp.Character:FindFirstChild"Humanoid"
end
local function getroot()
    local h = gethum()
    return h and h.RootPart
end

local function nextpos(steps, pos)
    return steps[pos]
end
local function revectorize(data)
    return Vector3.new(unpack(data))
end
local function unpackvec(vec3)
    return {vec3.X, vec3.Y, vec3.Z}
end

local function rethread(n)
    syn.set_thread_identity(n)
end
local function activate(what)
    if not toys:FindFirstChild(what) then return end
    rethread(2)
    --toyevent:FireServer(what)
    activator(lp, toys[what])
    rethread(7)
    return
end
function extassign.Jump(hum, toy, playback, starttime)--, entry)
    --print(starttime)
    if playback.JumpDelay --[[and not entry.NJD]] then
        local thread = running()
        while not thread.stopped and settings.Playbacking and hum.FloorMaterial.Name == 'Air' do if settings.LastDeath > starttime then return end wait(playback.JumpDelay) end
        wait(playback.JumpDelay) 
    end
    
    hum.Jump = true
    end
function extassign.Toy(hum, toy, playback) activate(toy) end
extassign.Parachute = clonefunction(newcclosure(getsenv(lp:WaitForChild"PlayerScripts":WaitForChild"Controls").onJumpRequest))

local function nextposlazy(steps, root)
    local index, shortest = 1, revectorize(steps[1].Position)
    for i, entry in next, steps do
        if entry.Type == 'Parachute' then continue end
        local p = revectorize(entry.Position)
        if math.abs(p.Y - root.Position.Y) <= 10 and (root.Position - p).Magnitude < (root.Position - shortest).Magnitude then index, shortest = i, p end
    end
    return index, shortest
end


local function logdeath()
    settings.LastDeath = tick() - wait()
end

local function walkto(entry, breaklim)
    local hum, root = gethum(), getroot()
    if not hum and root then return 2 end
    local pos = revectorize(entry.Position)
    
    shared.walkercons.death = shared.walkercons.death:Disconnect() or gethum().Died:Connect(logdeath)
    local t = tick()
    local thread = running()
    while not thread.stopped and settings.Playbacking and (pos - root.Position).Magnitude > entry.Precision do
        if breaklim and tick() - t > breaklim then return 1
        elseif settings.LastDeath > t then return 2
        end
        hum.WalkToPoint = pos
        if thread.fromlist and pos.Y - root.Position.Y >= root.Size.Y/2 then extassign.Jump(hum, nil, thread.playback, t) end
        wait()
    end
    return 0, tick() - t
end

local function setresponse(resp)
    local self = running() --money face
    if self.response ~= -3 then return warn("attempted "..resp) end
    self.response = resp
    self:close(resp)
    return 
end


local function runplayback(playback)
    local steps = playback.Steps
    if #steps < 1 then return setresponse(0) end
    settings.Playbacking = true
    
    local hum, root = gethum(), getroot()
    local step = (playback.FollowMode == 'Lazy' and nextposlazy(steps, root)) or (playback.InvertPlayback and #steps or 1)
    
    local increment = playback.InvertPlayback and -1 or 1
    
    local thread = running()
    local lines = thread.lines
    
    mover(playback.WalkSpeed, playback.JumpHeight)
    while wait() and not thread.stopped and settings.Playbacking and step > 0 and step <= #steps do
        local nextstep = nextpos(steps, step)
        
        if thread.visualizing then 
            lines.line = pcall(visualizer.Destroy, lines.line) and false or visualizer.Create{
                At = {lp, revectorize(nextstep.Position)},
                Color = drawinghelp[nextstep.Type][2],
                Type = 'Line',
                MaxDistance = 250
            }
            lines[lp] = pcall(visualizer.Destroy, lines[lp]) and false or visualizer.Create{
                    Type = "Circle",
                    At = {lp},
                    Color = drawinghelp[nextstep.Type][2],
                    MaxDistance = 250 --nothing lol
                }
        end
        
        local response, timetaken = walkto(nextstep, 15)
        if response ~= 0 then return setresponse(response) end
        if not settings.Playbacking then return setresponse(3)
        elseif nextstep.Type ~= "Move" then extassign[nextstep.Type](hum, nextstep.Toy, playback, 15-timetaken) end
        --finish playback
        
        step = step + increment
    end
    pcall(visualizer.Destroy, sticky)
    thread.stopped = true
    return setresponse(0)
end





threadmt.__index = {
    getresponse = function(self)
        return self.response
    end,
    close = function(self, response)
        self.response = response or 3
        self.stopped = true
        self:visualize(true)
        return 
    end,
    isfinished = function(self)
        return self.response ~= -3
    end,
    visualize = function(self, off)
        self.visualizing = not off
        local x = self.lines
        for i,v in next, x do pcall(visualizer.Destroy, v) rawset(x, i, nil) end
        if off then return end
        rawset(x, lp, visualizer.Create{
            Type = "Circle",
            At = {lp},
            Color = visualizer.Colors.Blue,
            MaxDistance = 250 --nothing lol
        })
        for i,v in next, self.playback.Steps do
            local pos, draw = revectorize(v.Position)
            local fortype = drawinghelp[v.Type]
            if not fortype then continue end
            table.insert(x, visualizer.Create{
                Type = fortype[1],
                At = {pos},
                Color = fortype[2],
                Mul = fortype[3],
                MaxDistance = 250
            })
        end
        return
    end,
    run = function(self)
        assert(self.response == -4, "\n\nCannot run() as playback is not properly initialized or is already used\n\Reason: "..self:status().."\n")
        self.response = -3
        resume(self, self.playback)
        settings.LastPlayback = self
        return self
    end,
    status = function(self)
        return responses[self.response]
    end,
    stopped = false
}

local function make(playback, fromlist)
    local thread = create(runplayback)
    local dat = setmetatable({
            playback = playback,
            lines = {},
            visualizing = false,
            fromlist = fromlist,
            response = not playback and -1 or -4
        }, threadmt)
    if fromlisted then
        dat.playback.JumpDelay = 0.067 -- 1/15
    end
    debug.setmetatable(thread, {
        __index = dat,
        __newindex = function(self, i, v)
            rawset(dat, i, v)
            return
        end
    })
    return thread
end
function module:fromcache(path)
    local tocache = path:match"^[/\\a-zA-Z0-9%-_]*"
    if tocache then 
        settings.cached[tocache] = settings.cached[tocache] or saver.GetSave(tocache)
    end
    return settings.cached[tocache]
end
function module:uncache(hi)
    settings.cached = not hi and {} or rawset(settings.cached, hi, nil)
end
function module:loadlocal(path)
    return make(self:fromcache(path), false)
end
function module:loadlist(positions, ws, jh)
    for i,v in next, positions do
        if not typeof(v) == 'Vector3' then return -2 end
        positions[i] = {
            Position = unpackvec(v),
            Precision = 5,
            Type = "Move"
        }
    end
    return make(newplayback(ws or 40, jh or 20, positions), true)
end
function module:loadplayback(pb) --usually from cached
    return make(pb, true)
end
function module:closemostrecent()
    local last = settings.LastPlayback
    if last and not last:isfinished() then last:close() end
    return
end
function shared.walkercons:cleanup() for i,v in next, self do if typeof(v) == 'RBXScriptConnection' then v:Disconnect() end end end
shared.walkercons.death = gethum().Died:Connect(logdeath)

return setmetatable(module, threadmt)