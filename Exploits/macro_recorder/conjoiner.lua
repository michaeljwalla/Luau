local function require(d, recache)
    shared.requirecache = shared.requirecache or {}
    if (typeof(d) ~= 'string') then return getfenv().require(d) end
    if d:find"^http" then return loadstring(game:HttpGet(d))()
    else
        if not recache and shared.requirecache[d] then return shared.requirecache[d] end
        local n, a = pcall(readfile, d..".lua") --loadfile lol
        assert(n, "No local module '"..d.."'")
        local chunk = loadstring(a)
        assert(chunk, "Error in local: "..d)
        shared.requirecache[d] = chunk()
        return shared.requirecache[d]
    end
end
local function reassert(arg, resp)
    return assert(arg, resp) and arg
end
local zonehelp = require"bell/flowerzoner"
local walker = require"bell/walkmodule"
local mover = require"bell/movement"

local pi = math.pi
local cc, random, min, sqrt, ceil, abs, thread, resume, yield, delay, wait, insert = workspace.CurrentCamera, math.random, math.min, math.sqrt, math.ceil, math.abs, coroutine.running(), coroutine.resume, coroutine.yield, task.delay, task.wait, table.insert
local lp, fzones = game.Players.LocalPlayer, workspace.FlowerZones
local module = {
    Speed = 160,
    Walking = false,
    Files = {},
    Path = "PMapper\\Saved"
}
for i, dir in next, listfiles(module.Path) do
    if not isfolder(dir) then
        dir = dir:sub(1,-5)
        module.Files[dir:match"[a-zA-Z0-9%-_%.]*$"] = dir
    else
        local curdir = {}
        module.Files[dir:match"[a-zA-Z0-9%-_]*$"] = curdir
        for x, file in next, listfiles(dir) do
            file =  file:sub(1,-5)
            curdir[file:match"[a-zA-Z0-9%-_%.]*$"] = file
        end
    end
end
if shared.charwaiting then for i,v in next, shared.charwaiting do v:Disconnect() end end
local cons = {}
shared.charwaiting = cons
local ok = game:GetService"PointsService".ChildAdded:Connect(function() end)
shared.imtoolazytoaddarealcheck = ok
local function printstack()
    warn("\n"..debug.traceback())    
end
local function gethum(plr)
    plr = plr or lp
    return plr.Character and plr.Character:FindFirstChildOfClass"Humanoid"
end
local function die()
    local hum = gethum()
    if hum then hum.Health = 0 end
    return
end
local function getroot(plr)
    local hum = gethum(plr)
    return hum and hum.RootPart
end
--[[cons.charadded = lp.CharacterAdded:Connect(function(char)
    resume(thread, char)
    return
end)]]
local function defaultrun(thread, visualize)
    if visualize then thread:visualize() end
    thread:run()
    while not thread:isfinished() do wait() end
    if visualize then thread:visualize(true) end
    return thread:getresponse(), thread:status()
end
local function waitfornewchar(timeout, old)
    local char, start = lp.Character, tick()
    while (lp.Character == char or not (lp.Character and lp.Character:FindFirstChild"Humanoid" and lp.Character:FindFirstChild"HumanoidRootPart")) do
        task.wait()
        if tick() - start >= timeout then return false end
    end
    return true, lp.Character
    --[[if char == old then
        local satisfied
        delay(timeout, function()
            if not satisfied then resume(thread, false) end
        end)
        char = yield(thread)
        if not char then return char end
    end
    local hum, root = char:FindFirstChild"Humanoid", char:FindFirstChild"HumanoidRootPart"
    if hum and root then return char, tick() - start elseif cons.instadded then cons.instadded:Disconnect() end
    cons.humadded = char.ChildAdded:Connect(function(c)
        if c:IsA"Humanoid" then
            hum = c
            cons.humadded:Disconnect()
            if cons.rooted then cons.rooted:Disconnect() end
            cons.rooted = hum:GetPropertyChangedSignal"FloorMaterial":Connect(function(t)
                cons.rooted:Disconnect()
                if satisfied then return end
                coroutine.resume(thread, char)
            end)
        end
    end)
    
    delay(timeout - (tick() - start), function()
        if not satisfied then resume(thread, false) end
    end)
    char = yield(thread)
    satisfied = true
    return char, tick() - start]]
    
end
local colliding = true
cons.clipping = game.RunService.Stepped:Connect(function()
    if not lp.Character then return end
    for i,v in next, lp.Character:GetChildren() do
        if v:IsA"BasePart" and v.Name:find"Root" or v.Name:find"Torso" then v.CanCollide = colliding
        elseif v:IsA"Humanoid" then v.PlatformStand = not colliding end
    end
    return
end)
local function getmassof(part, ignorelist)
    ignorelist = ignorelist or {}
    local mass = part:GetMass()
    ignorelist[part] = true
    for i,v in next, part:GetConnectedParts() do
        mass = mass + (ignorelist[v] and 0 or getmassof(v, ignorelist))
    end
    return mass
end
function module:ChangeLaunchSpeed(n) --changes xz speed
    self.Speedspeed = typeof(n) == 'number' and abs(n) or self.Speed
end
local center = Vector3.new(-6.796, 79.548, 52.652)
function module:LaunchTo(pos, checkpos)
    local nspeed = self.Speed
    local root = getroot()
    if not root then return
    elseif checkpos then
        local a,b = self:LaunchTo(center)
        if not a then return a, b end
    end
    local gravity = -workspace.Gravity
    local mass = getmassof(root)
    
    local startpos = root.Position
    local maxdistperpush = (0 - nspeed^2) / (2 * gravity)
    colliding = false
    
    local timetaken = (root.Position - pos).Magnitude/nspeed
    --local preorient = root.CFrame.Rotation
    
    local rotvel = Vector3.new()
    if timetaken >= 1 then
        local onerotate = 2*pi/timetaken
        rotvel = Vector3.one*onerotate*random(-2,2)
        if rotvel.Magnitude == 0 then rotvel = Vector3.new(0,onerotate) end
    elseif timetaken >= 0.3 then
        rotvel = Vector3.new(0,2*pi/timetaken)
    end
    local c = lp.Character
    while wait() and ok.Connected and lp.Character == c and (root.Position - pos).Magnitude > 5 do
        root.RotVelocity = rotvel
        root:ApplyImpulse((((pos - root.Position)).Unit*nspeed - root.Velocity)*getmassof(root))--xz + Vector3.new(0,fy))
    end
    
    colliding = true
    root.Velocity = Vector3.zero
    root.RotVelocity = Vector3.zero
    root.CFrame = CFrame.new(root.Position)--, cc.CFrame.p + cc.CFrame.LookVector*500 )
    --wait((#disty-1) * 0.01185
    
    return c == lp.Character, c == lp.Character and "(Completed)" or "(F) Character instability"
end
local function revectorize(tbl)
    return Vector3.new(unpack(tbl))
end
local function getspawnpoint()
    for i,v in next, workspace.Honeycombs:GetChildren() do
        if v:FindFirstChild"localpatharrow" then break --unclaimed save 0.00125 ms
        elseif v.Owner.Value == lp then return v.SpawnPos.Value.p end
    end
    return workspace.SpawnLocation.Position
end
local function pleasedie(wait, iters, curchar)
    for i = 1, iters do
        die()
        local x = waitfornewchar(wait)
        if x then return x end
    end    
    return nil
end
local tofilename = "[a-zA-Z0-9%-_]*"
function module:SyncZone()--[[field)
    field = typeof(field) == 'number' and zonehelp.GetName(field) or field
    field, root = typeof(field) == 'Instance' and field or fzones:FindFirstChild(field), getroot()
    assert(field, "Invalid Field.")]]
    local root = reassert(getroot(), "need to add better retry")
    
    local curfield, curzone = root and zonehelp:GetCurrentField(root.Position), zonehelp:GetCurrentGate(root.Position)
    local toorigin
    if root.Position.Y > 25000 or not curzone then
        pleasedie(10, 3, lp.Character)
        return self:SyncZone()
    elseif curfield then
        local file = self.Files[curzone] and self.Files[curzone][curfield:lower():match(tofilename)]
        toorigin = reassert(file and walker:loadlocal(file), ("\n\n\tFile not found for:\n\t\tZone = %s\n\t\tField = %s\n"):format(curzone, curfield))
        local origin = revectorize(walker:fromcache(self.Files[curzone].origin).Steps[1].Position)
        local steps = toorigin.playback.Steps
        local end1, end2 = revectorize(steps[1].Position), revectorize(steps[#steps].Position)
        toorigin.playback.InvertPlayback = (end2 - origin).Magnitude > (end1 - origin).Magnitude
    elseif curzone == 'FromSpawn' then
        toorigin = walker:loadlist{
            getspawnpoint()
        }
    else--when only curzone
        toorigin = walker:loadplayback(walker:fromcache(self.Files[curzone].origin)) --removes .bll tag
    end
    
    local resp, stat = defaultrun(toorigin, true)
    if resp == 1 or resp == 2 then --if out of time or died, run again
        pleasedie(10, 3, lp.Character)
        curzone = 'FromSpawn'
    elseif not (resp == 3 or resp == 0) then
        return error("err "..resp.." - "..toorigin:status())
    end
    toorigin.playback.InvertPlayback = false
    return curzone
end
local validzones = { 0, 5, 10, 15, 20, 25, 30, 35 }
local function createpathto(curzone, tozone, recursed) --curzone is dir key ex 5zone, tozone is toNzone
    local files = module.Files
    local start = files[curzone]
    if start[tozone] or curzone == tozone:sub(3) then return { start[tozone] } end
    local possibles = {}
    for fname, fpath in next, start do
        if not fname:find"^to%d+" then continue end
        local zone = fname:match"(%d+zone)$"
        insert(possibles, files[zone][tozone] and zone)
    end
    local closestzone, cor = "FromSpawn", revectorize(walker:fromcache(files.FromSpawn.origin).Steps[1].Position)
    local root = getroot()--should be run in same cycle as :synczone
    for i,zone in next, possibles do
        local origin = revectorize(walker:fromcache(files[zone].origin).Steps[1].Position)
        local newdist = (root.Position - origin).Magnitude
        if  (root.Position - cor).Magnitude > newdist then closestzone, cor = zone, origin end
    end
    return { start["to"..(closestzone == 'FromSpawn' and 'spawn' or closestzone)], files[closestzone][tozone] }
end
function module:ToZone(zone)
    if not zone then return pleasedie(10, 3, lp.Character) and true, "(Completed)" end --easy FromSpawn
    assert(zone == -1 or (zone >= 0 and zone <= 35 and zone % 5 == 0), 'invalid zone given: '..zone)
    --local start = self:SyncZone()
    if not self.Walking then
        if getroot().Position.Y > 25000 then pleasedie(10,3, lp.Character) end
        local path = zone == -1 and getspawnpoint() or revectorize(walker:fromcache(self.Files["to"..zone].origin).Steps[1].Position)
        return self:LaunchTo(path, true)
    end
    local path = createpathto(self:SyncZone(), zone == -1 and "tospawn" or "to"..zone.."zone") --maybe?
    for i, fpath in next, path do
        --print(fpath)
        local nextthread = walker:loadlocal(fpath)
        local resp = defaultrun(nextthread, true)
        if resp ~= 0 then
            if erronfail then error(("\n\n\tToZone fail at:\n\t\tStep - %d/%d\n\t\tResponse - %s\n\t\tFile - %s.bll"):format(i, #path, nextthread:status(), path[i])) end
            return false, nextthread:status(), path, i 
        end
    end
    return true, "(Completed)"
end
function module:ToField(field)
    field = typeof(field) == 'string' and field or zonehelp.GetName(field)
    if not self.Walking then
        if getroot().Position.Y > 25000 then pleasedie(10,3, lp.Character) end
        local root = getroot()
        local zone, endzone = zonehelp:GetCurrentGate(root.Position), zonehelp:GetGateFromField(field)
        local path = fzones:FindFirstChild(field).Position
        return self:LaunchTo(path + Vector3.new(0,root.Size.Y*1.2), zone == '10zone' and endzone == '15zone' or zone == '15zone' and endzone == '10zone')
    end
    if zonehelp:GetCurrentField(getroot().Position) == field then return true, "(Completed)" end
    local fieldzone = zonehelp:GetCurrentGate(reassert(fzones:FindFirstChild(field), "unknown field: "..field).Position)
    local success, response, pathtaken, errat = self:ToZone(tonumber(reassert(fieldzone, 'fieldzone not found, shouldnt be possible'):match"%d+"))
    local tofield = walker:loadlocal(self.Files[fieldzone][field:match("^%a*"):lower()])
    
    local resp = defaultrun(tofield, true)
    return resp == 3 or resp == 0, tofield:status()
end
local shopassign = {
    ['Pro Shop'] = '10shop',
    ['Ace Shop'] = 'aceshop',
    ['Basic Egg Shop'] = 'basiceggshop',
    ['Noob Shop'] = 'basicshop',
    ['Magic Bean Shop'] = 'beanshop',
    ['Beequip Shop'] = 'beequipshop',
    ['Blender'] = 'blender',
    ['Blue HQ Shop'] = 'blueshop',
    ['Coconut Cave Shop'] = 'cocoshop',
    ['Gumdrop Shop'] = 'gumdropshop',
    ['Gummy Shop'] = 'gummyshop',
    ['Mountain Top Shop'] = 'mtshop',
    ['Petal Shop'] = 'petalshop',
    ['Planter Shop'] = 'plantershop',
    ['RBC Drive Shop'] = 'rbcshop',
    ['Red HQ Shop'] = 'redshop',
    ['Sprinkler Shop'] = 'sprinklershop',
    ['Stringer Shop'] = 'stingershop',
    ['Ticket Shop'] = 'ticketshop',
    ['Ticket Tent'] = 'tickettentshop',
    ['Treat Shop'] = 'treatshop'
}
local actassign = {
    ["Starter Micro Converter (6tx)"] = '0converter',
    ["Royal Jelly Dispenser (6tx)"] = '6rjdisp',
    ["Ant Pass Dispenser (10tx)"] = '10ant',
    ["Tunnel Bear Micro-Converter"] = '10converter',
    ["Mountain Top Micro-Converter"] = '25converter',
    ["Robo Bear Pass Dispenser (50tx)"] = '50rbc',
    ["Blue Field Booster"] = 'bluebooster',
    ["Blueberry Dispenser"] = 'bluedisp',
    ["Blue HQ Portal"] = 'blueportal',
    ["Coconut Dispenser"] = 'cocodisp',
    ["Extreme Memory Match (25mH)"] = "extrememm",
    ["Ant Pass Dispenser"] = 'freeant',
    ['Glue Dispenser'] = 'gluedisp',
    ['Honey Dispenser'] = 'honeydisp',
    ['Honeystorm Summoner'] = 'honeystorm',
    ['Mega Memory Match (500kH)'] = 'megamm',
    ['Mythic Meteor Shower Summoner'] = 'meteors',
    ['Memory Match (25kH)'] = 'mm',
    ['Nectar Jar'] = 'nectarjar',
    ['Night Memory Match (5mH)'] = 'nightmm',
    ['Robo Pass Dispenser'] = 'rbcdisp',
    ['Red Field Booster'] = 'redbooster',
    ['Red HQ Portal'] = 'redportal',
    ['Rare Sprout Summoner'] = 'rsprout',
    ['Star Hall Royal Jelly Dispenser'] = 'starhalljelly',
    ['Strawberry Dispenser'] = 'strawdisp',
    ['Treat Dispenser'] = 'treatdisp',
    ['Wealth Clock'] = 'wclock',
    ['White Field Boosters'] = 'whitebooster'
}
local beesassign = {
    ["Mother Bear's Gingerbread House"] = 'gingerbread',
    ["Onett's Lid Art"] = 'lidart',
    ["Polar Bear's Beesmas Feast"] = 'polarfeast',
    ["Riley Bee's Honeyday Candles"] = 'rileycandles',
    ["Bucko Bee's Snow Machine"] = 'rileysnow', --lol oops
    ["Dapper Bear's Samovar"] = 'samovar',
    ["Brown Bear's Stockings"] = 'stockings',
    ["Black Bear's Honey Wreath"] = 'wreath'
}
function module:GetShopName(realname)
    return shopassign[realname]
end
function module:GetActivatableName(realname)
    return actassign[realname]
end
function module:GetBeesmasName(realname)
    return beesassign[realname]
end
function gotogummylair()
    if not module.Walking then
        if getroot().Position.Y > 25000 then pleasedie(10,3, lp.Character) end
        local path = walker:fromcache(module.Files['20zone'].gummylair).Steps
        if not module:LaunchTo(revectorize(path[#path].Position)) then return false, "(F) Character instability" end
        wait(1)
        getroot().CFrame = CFrame.new(275, 25275, -745)
        return true, "(Completed)"
    end
    module:ToZone(20) --idk
    local togumlair = walker:loadlocal(module.Files['20zone'].gummylair)
    local resp = defaultrun(togumlair, true)
    wait(1) --pretend use gumdrop
    if resp ~= 0 then return false, togumlair:status() end
    getroot().CFrame = CFrame.new(275, 25275, -745)
    return resp == 0 or resp == 3, togumlair:status()
end
function module:ToShop(shop)
    shop = tostring(shop)
    local path = self.Files.Shops[reassert(self:GetShopName(shop), "invalid shop:"..shop)]
    local shopfile = walker:fromcache(path)
    if shop:find'Gummy' then
        gotogummylair(true)
        if not self.Walking then
            return true, "(Completed)"
        end
    else
        if not self.Walking then
            return true, "(Completed)"
        end
        local shopzone = reassert(zonehelp:GetCurrentGate(revectorize(shopfile.Steps[1].Position)), "not possible? invalid zone for shop"..shop)
        self:ToZone(tonumber(shopzone:match"%d+"))
    end
    shopfile = walker:loadlocal(path) --oops thread mt data is not unique per thread
    local resp = defaultrun(shopfile, true)
    return resp == 3 or resp == 0, shopfile:status()
end
function module:ToActivatable(act)
    act = tostring(act)
    local path = self.Files.Activatables[reassert(self:GetActivatableName(act), "invalid activatable:"..act)]
    local actfile = walker:fromcache(path)
    if act == 'Glue Dispenser' then
        gotogummylair(true)
    end
    if not self.Walking then
        if getroot().Position.Y > 25000 then pleasedie(10,3, lp.Character) end
        local path = actfile.Steps
        return self:LaunchTo(revectorize(path[#path].Position))
    else
        local actzone = reassert(zonehelp:GetCurrentGate(revectorize(actfile.Steps[1].Position)), "not possible? invalid zone for shop"..act)
        self:ToZone(tonumber(actzone:match"%d+"))
    end
    actfile = walker:loadlocal(path)
    local resp = defaultrun(actfile, true)
    return resp == 3 or resp == 0, actfile:status()
end
function module:ToBeesmas(act)
    act = tostring(act)
    local path = self.Files.BeesmasActivatables[reassert(self:GetBeesmasName(act), "invalid activatable:"..act)]
    local actfile = walker:fromcache(path)
    if not self.Walking then
        if getroot().Position.Y > 25000 then pleasedie(10,3, lp.Character) end
        local path = actfile.Steps
        return self:LaunchTo(revectorize(path[#path].Position), true)
    end
    local actzone = reassert(zonehelp:GetCurrentGate(revectorize(actfile.Steps[1].Position)), "not possible? invalid zone for shop"..act)

    self:ToZone(tonumber(actzone:match"%d+"))
    actfile = walker:loadlocal(path)
    local resp = defaultrun(actfile, true)
    return resp == 3 or resp == 0, actfile:status()
end
local maskassign = {
    --[[['Honey Mask'] = {module.Files.Shops;CheckFileName;.aceshop},
    ['Fire Mask'] = {module.Files.Shops.redshop},
    ['Bubble Mask'] = {module.Files.Shops.blueshop},]]
    --['Gummy Mask'] = {Zone = 20, Ways = {i.dont.remember['20zonemaybe'].gummylair}},
    ['Diamond Mask'] = {module.Files.FromSpawn.diamondmask2, module.Files['15zone'].diamondmask},
    ['Demon Mask'] = {module.Files.FromSpawn.demonmask}
}
function module:ToProMask(mask) --all other gears should use ToShop()
    if mask == 'Gummy Mask' then
        return self:ToShop("Gummy Shop")
    else
        assert(maskassign[mask], "Mask is either invalid or not endgame")
        if not self.Walking then
            return true, "(Completed)"
        end
        local curzone, using = self:SyncZone()
        for i,path in next, maskassign[mask] do
            local startsfrom = revectorize(walker:fromcache(path).Steps[1].Position)
            if zonehelp:GetCurrentGate(startsfrom) == curzone then using = walker:loadlocal(path) end -- still uses cache
        end
        using = using or (self:ToZone(-1) and walker:loadlocal(maskassign[mask][1]))
        local resp = defaultrun(using, true)
        return resp == 0 or resp == 3, using:status()
    end
    return nil, "np"
end

function module:ToggleWalking(t)
    self.Walking = t
end
return setmetatable(module, {__index = walker})--weird thing, errs after being returned