--fly module

--modules/externals
local require = loadfile"bell/new/require.lua""" 

local shared = require"bell/new/shared"
local stepper = require"bell/new/stepper"
local keybinder = require"bell/new/keybinder"
local apply = require"bell/new/apply"

--local module setup
local module = shared:Get("FlyModule", { --default module
	speed = 50,
	status = false,
	noclip = true,
	axes = Vector3.one,
	connections = {},
	record = {}
})



--constants
local record, cons = module.record, module.connections
do
	for i,v in next, cons do
		stepper:Remove(unpack(v)) --clear old connections for re-runs
	end
end
local vzero, vone, vnoY = Vector3.zero, Vector3.one, Vector3.new(1,0,1)

local bv = apply(Instance.new"BodyVelocity", { MaxForce = vone * 9e29, Velocity = vzero }) --base instances
local bg = apply(Instance.new"BodyGyro", { MaxTorque = vone * 1e15, P = 1000000, D = 3000 })

local cc = workspace.CurrentCamera
local lp = game.Players.LocalPlayer
local runservice = game:GetService"RunService"
local uis = keybinder.UIS

local insert, clear = table.insert, table.clear

local sqrt3 = 3^0.5 --used for axis-locks unlocked (1,1,1) magnitude = sqrt3
local toradian = math.pi/180 --used when calling :stop() to preserve Y orientation
local abs = math.abs

local movedirs = { --quickly lookup how a key interacts with a KeyCode from uis.InputBegan
	[keybinder.Keys.W] = function(cframe)
		return cframe.LookVector
	end,
	[keybinder.Keys.A] = function(cframe)
		return -cframe.RightVector
	end,
	[keybinder.Keys.S] = function(cframe)
		return -cframe.LookVector
	end,
	[keybinder.Keys.D] = function(cframe)
		return cframe.RightVector
	end
}
local spacebar, tab = keybinder.Keys.Space, keybinder.Keys.Tab
local r15 = Enum.HumanoidRigType.R15

--variables
local lastbv, lastbg
local db --debounce

--functions
local function xor(a: boolean | any?, b: boolean | any?): boolean | any?
	return (a or b) and not (a and b)
end
local function rougheq(a, b, epsilon) --for decimal precision 
	return abs(a - b) <= (epsilon or 1e-7)
end
local function gethum(char): (Instance?, Instance?)
	char = char or lp.Character
	return char and char:FindFirstChildWhichIsA"Humanoid", char
end
local function getroot(char): (Instance?, Instance?, Instance?)
	local hum, char = gethum(char)
	return hum and hum.RootPart, hum, char
end

local function noclip15(char: Instance, toggle: boolean): nil --noclip for r15
	toggle = not toggle -- true = noclip = opposite

	local parts = {
		char:FindFirstChild"Head",
		char:FindFirstChild"HumanoidRootPart",
		char:FindFirstChild"UpperTorso",
		char:FindFirstChild"LowerTorso",
	}
	for i,v in next, parts do v.CanCollide, v.CanTouch = toggle, toggle end -- implementation without using 4 ifs
	return
end
local function noclip6(char: Instance, toggle: boolean): nil --noclip for r6
	toggle = not toggle -- true = noclip = opposite

	local parts = {
		char:FindFirstChild"Head",
		char:FindFirstChild"HumanoidRootPart",
		char:FindFirstChild"Torso"
	}
	for i,v in next, parts do v.CanCollide, v.CanTouch = toggle, toggle end -- imp w/o using 3 ifs
	return
end

local function recordinst(inst: Instance): nil --filter some physics instances from DescendantAdded/GetDescendants() & add to cache (to destroy when toggling fly)
	if record[inst] or not (inst:IsA"BodyVelocity" or inst:IsA"BodyGyro") then return end
	rawset(record, inst, inst)
end
local function setupfly(char: Instance): nil -- called on new character creation / 1st time require()'d
	if not char then
		return
	elseif cons.FlyOnCharDescendantAdded then
		stepper:Remove(unpack(cons.FlyOnCharDescendantAdded)) --clean up old connection
	end
	for i,v in next, char:GetDescendants() do
		recordinst(v)
	end
	cons.FlyOnCharDescendantAdded = { stepper:Add(char, "DescendantAdded", "FlyCharDescendantRecorder", recordinst) }
	return
end

--methods
function module:Stop(): nil
	if db then return else db = true end

	local root, hum, char = getroot()
	if not root then return end

	for i,v in next, self.record do v:Destroy() end --clear cache
	clear(self.record)
	
	stepper:Disable(runservice, "Heartbeat", "FlyEnable") -- (no point running while inactive)
	noclip15(char, false) --in case char was noclipping, disable it

	hum.PlatformStand = false

	local cf = root.CFrame
	root.CFrame = cf * cf.Rotation:Inverse() * CFrame.Angles(0,toradian * root.Orientation.Y, 0) -- inverse to undo rotation on XYZ axes, then reapply Y rotation to face same direction when unflying 
	self.status = false
	db = false
end
function module:Start(): nil
	if db then return end
	
	self:Stop()
	db = true -- :stop() wouldnt run if it were set any earlier

	lastbv, lastbg = bv:Clone(), bg:Clone()
	lastbv.Parent, lastbg.Parent = root, root

	stepper:Enable(runservice, "Heartbeat", "FlyEnable") -- (no point running while inactive)

	self.status = true
	db = false
end
--these dont rlly need debounces since nothing substantial could even have a chance of causing errors
function module:Toggle(status: boolean?): nil
	status = (status == nil and not self.status) or status --flip toggle if status unspecified (else set to status)
	if status then self:Start() else self:Stop() end
end
function module:ToggleNoclip(status: boolean?): nil --flip toggle if status unspecified (else set to status)
	self.noclip = (status == nil and not self.noclip) or status
end
function module:IsFlying(): boolean
	return self.status
end
function module:IsNoClipping(): boolean
	return self.noclip
end
function module:ChangeSpeed(speed: number): nil --update flying speed
	assert(type(speed) == 'number', "not a number retard")
	self.speed = speed
end

--updates axes movement specified by string 'axes' to boolean 'value'
									    -- undef 'value' -> true IF self.axes ~= (1, 1, 1) ELSE false
function module:ToggleAxis(axes: string, value: boolean?): nil -- toggleaxis("ZX", false)-> (0, 1, 0) ; toggleaxis("YZ", true) -> (0, 1, 1) ; toggleaxis("X") -> (1, 1, 1) ; toggleaxis("YXZ") -> (0, 0, 0)
	axes = axes:upper():split""
	value = (value == nil and not rougheq(self.axes.Magnitude, sqrt3, 1e-5) or value) and 1 or 0

	local temp = {}
	for i,v in next, axes do
		temp[v] = value
	end

	axes = self.axes
	self.axes = Vector3.new(temp.X or axes.X, temp.Y or axes.Y, temp.Z or axes.Z)
	return
end

--connections
cons.OnCharacterAdded = { stepper:Add(lp, "CharacterAdded", "FlyOnCharacterAdded", setupfly) }
cons.OnFlyAdded = { stepper:Add(runservice, "Heartbeat", "FlyEnable", function(): nil
	if not module.status or uis:GetFocusedTextBox() then return end --if not flying or key was pressed inside of a textbox
	
	local root, hum, char = getroot()
	if not root then return end

	-- *removed vehicle flying for now

	--local isvehicle = hum.SeatPart
	local lastgyro, lastfly = lastbg, lastbv
	hum.PlatformStand = module.status--not isvehicle

	local newparent = --[[isvehicle and isvehicle.Parent and (isvehicle.Parent:IsA"Model" and isvehicle.Parent.PrimaryPart or isvehicle) or ]]root
	
	xpcall(function()
		if lastgyro then
			lastgyro.Parent = newparent
			lastgyro.CFrame = cc.CFrame -- bodygyros only use Rotation of CFrame
		end
		if lastfly then
			lastfly.Parent = newparent

			local finalvel, relcframe = vzero, cc.CFrame --movement is relative to camera (player), NOT absolute position
			local speed = module.speed
			for i,v in next, uis:GetKeysPressed() do
				local validmove = movedirs[v.KeyCode] --quick lookup & call for keys WASD
				if validmove then finalvel = finalvel + validmove(relcframe) end
			end
			
			do
				local temp = finalvel * module.axes
				finalvel = temp.Magnitude ~= 0 and temp.Unit * speed or vzero --apply axis locks
			end

			local isspace, istab = uis:IsKeyDown(spacebar), uis:IsKeyDown(tab) --overrides
			if module.axes.Y ~= 0 and (isspace or istab) then --if updown keys pressed and y-axis not locked
				local upspeed = speed/2
				local adjusted = finalvel*vnoY
				finalvel = (adjusted.Magnitude ~= 0 and (adjusted.Unit * speed) or vzero) + Vector3.new(0,upspeed * ((isspace and 1 or 0) + (istab and -1 or 0))) --definitely can be optimized
			end

			lastfly.Velocity = finalvel --done
	--[[
			local hum = gethum()
			if isvehicle and hum then
				cc.CameraSubject = hum --fixes weird offsetting
			end]]
		end
	end, function(err)
		module:Start() --restart self if something errors (usually when you fly into void & insts get nil-locked)
	end)
	
	local toggle = xor(keybinder.IsHoldingCtrl(), module.noclip) -- xor lets you make IsHoldingCtrl() invert the current noclip status while being held
	if hum.RigType == r15 then
		noclip15(char, toggle)
	else
		noclip6(char, toggle)
	end
end) }

--

setupfly(lp.Character) --since it wont apply immediately (.CharacterAdded)
return module