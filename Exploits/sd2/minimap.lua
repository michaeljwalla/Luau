local function require(d, recache)
    shared.requirecache = shared.requirecache or {}
    if (typeof(d) ~= 'string') then return getfenv().require(d) end
    if d:find"^http" then return loadstring(game:HttpGet(d))()
    else
        if not recache and shared.requirecache[d] then return shared.requirecache[d] end
        local n, a = pcall(readfile, d..".lua") --loadfile lol
        assert(n, "No local module '"..d.."'")
        local chunk = loadstring(a)
        assert(chunk, "Error in local: "..d)
        shared.requirecache[d] = chunk()
        return shared.requirecache[d]
    end
end
local fetcher = require("bell/DataSaver")
local stepper = require("bell/new/stepper")
local enabled, option, mapson = false, "None", true
local getsynasset = getsynasset or getcustomasset

shared.sdata = shared.sdata or {Connections = {}, Guis = {}, Data = {}}
local sdata = shared.sdata
if sdata.Connections.Mapper then for i,v in next, sdata.Connections.Mapper do if not v[1] then continue end stepper:Remove(unpack(v)) end end -- {InstDebugId|ConName, FuncName}
if sdata.Guis.Mapper then sdata.Guis.Mapper:cleanup() end 

local function hasprop(inst, prop, pcd)
    return pcd and inst[prop] or pcall(hasprop, inst, prop, true)
end
local function apply(inst, props)
    local parent = props.Parent
    props.Parent = nil
    for i,v in next, props do
        if hasprop(inst, i) then
            inst[i] = v
        end
    end
    if parent then inst.Parent = parent end
    return inst
end
local char, random = string.char, math.random
local function rand(len)
    local result = ""
    for i = 1, len do result = result..char(random(0,255)) end
    return result
end

sdata.Guis.Mapper = require("bell/gui", true) --force recache to make new inst of gui lib
sdata.Connections.Mapper = {}
local module, data = {}, {}
sdata.Data.Mapper = data
local gui = sdata.Guis.Mapper
local lp, plrs = game.Players.LocalPlayer, game.Players
local ts = game:GetService"TweenService"
local map = workspace:WaitForChild"Map"
local max, min, clamp, round, lerp, atan2, abs, wait = math.max, math.min, math.clamp, math.round, gui.Lerp, math.atan2, math.abs, task.wait
local insert, pi = table.insert,math.pi
local camera = workspace.CurrentCamera
local minsize, maxsize
--into module

module.Gui = gui.Gui
function module:Start()
    gui.Gui.Enabled = true
    enabled = true
end
function module:Stop()
    enabled = false
    gui.Gui.Enabled = false
end
module:Stop()

---



local function roundeq(a,b,err)
    return abs(a-b) <= (err or 1e-5)
end
local function atan(x, y)
    local theta = atan2(x, y)
    return theta
end
local function gethum(plr)
    plr = plr and plrs:FindFirstChild(plr) or not plr and lp
    if not plr then return end
    return plr.Character and plr.Character:FindFirstChildWhichIsA"Humanoid"
end
local function getroot(plr)
    local h = gethum(plr)
    return h and h.RootPart
end
local mcontainer = apply(gui:AddBasic("Frame", UDim2.new(0,150,0,150), UDim2.new(0.8,0,1,-150)), {
    BackgroundColor3 = Color3.new(1/3,1/3,1/3),
    ClipsDescendants = false,
    Name = "Map"
})
gui:SetMainMenu(mcontainer)
local deftween = TweenInfo.new(0.2, Enum.EasingStyle.Linear)
local map_boundaryscaler = apply(gui:AddBasic("Frame", UDim2.new(1,0,1,0), nil, mcontainer), {
    Name = "Bounds",
    ClipsDescendants = true
})

local map_extentsbox = apply(gui:AddBasic("Frame", UDim2.new(0,200,0,200),nil, map_boundaryscaler), {
    Name = "Map",
    ClipsDescendants = false
})
local defmapframe = apply(gui:AddBasic("ImageLabel", UDim2.new(0,200,0,200), nil, map_extentsbox), {
    Name = "Terrain",
    BackgroundTransparency = 1
})
local heightcounter_container = apply(gui:AddBasic("Frame", UDim2.new(0.05,0,1,0),UDim2.new(1), mcontainer), {
    Name = "HeightMeasure",
    ZIndex = 68999
})
local heightcountr_indicator = apply(gui:AddBasic("Frame", UDim2.new(1,0,0.025), nil, heightcounter_container), {
    BackgroundColor3 = gui:GetThemeColor"Accent",
    Name = "Indicator",
    ZIndex = 68999
})
local heightcounter_updater = gui:AddTweenLerp(
    heightcountr_indicator,
    {Position = {UDim2.new(), UDim2.new(0,0,0.975)}},
    deftween,
    0.5
)
local posindicator = apply(gui:AddBasic("TextLabel", UDim2.new(0.4,0,0.04), UDim2.new(0.05,0,0.005), mcontainer), {
    TextScaled = true,
    BackgroundTransparency = 1,
    Name = "Position",
    Visible = false
})
local pfolder = apply(Instance.new"Folder", {
    Name = "Players",
    Parent = map_extentsbox
})
local npcfolder = apply(Instance.new"Folder", {
    Name = "NPCs",
    Parent = map_extentsbox
})

minsize, maxsize = Vector2.new(100,100), map_extentsbox.AbsoluteSize

local function makeplayer(name)
    if tostring(name) ~= lp.Name and not (option == 'All' or option == 'Players') then return end
    name = name and plrs:FindFirstChild(tostring(name)) or not name and lp
    local n = tostring(name)
    if not name then return elseif name and pfolder:FindFirstChild(n) then pfolder[n]:Destroy() end
    local folder = apply(Instance.new"Folder", {
        Name = n
    })
    local player = apply(gui:AddBasic("Frame", UDim2.new(0.025,0,0.025), UDim2.new(0.475,0,0.475), folder), {
      Text = "",
      BackgroundColor3 = name == lp and gui:GetThemeColor"Accent" or Color3.new(0.5,0.8,0.6),
      Name = "Player",
      BorderColor3 = Color3.new(0.2,0.4,0.3),
      ZIndex = 68000
    })
    
    apply(gui:AddBasic("Frame", UDim2.new(0.4,0,0.4,0), UDim2.new(0.3,0,-0.4, -1), player), {
        BackgroundColor3 = Color3.new(1,1,1),
        Name = "LookDirection",
        ZIndex = 67999
    })
    apply(gui:AddLerp(player, {
        Rotation = {0, 360}
    }, 0), {Name = "Orientation"})
    local namepopup = gui:DefaultPopup(n)
    gui:MakePopup(player, namepopup, {FollowMouse = false})
    if name == lp then
        player.ZIndex = 69000 --useful code
        player.LookDirection.ZIndex = 68999
        local camera = apply(player:Clone(), {
            Name = "Camera",
            Parent = folder,
            BackgroundTransparency = 1,
        })
        apply(camera.LookDirection, {
            BackgroundColor3 = Color3.new(0.8,0.2,0.2),
            ZIndex = 69001
        })
        camera.Orientation:Destroy()
        apply(gui:AddLerp(camera, {
            Rotation = {0, 360}
        }, 0), {Name = "Orientation"})
    end
    folder.Parent = pfolder
end
local function makenpc(humanoid)
    if not (option == 'All' or option == 'NPCs') or (humanoid.Name ~= "Head" and not (humanoid.Parent and humanoid.RootPart)) then
        return
    end
    local folder = apply(Instance.new"Folder", {
        Name = humanoid:GetDebugId() or "(?)",
    })
    local player = apply(gui:AddBasic("Frame", UDim2.new(0.0125*1.414,0,0.0125*1.414), nil, folder), {
      Text = "",
      BackgroundColor3 = Color3.new(0.5,0.2,0.2),
      Name = 'NPC',
      BorderSizePixel = 1,
      BorderColor3 = Color3.new(0.4,0.1,0.1)
    })
    local namepopup = gui:DefaultPopup(tostring(humanoid.Parent))
    gui:MakePopup(player, namepopup, {FollowMouse = false})
    apply(gui:AddBasic("Frame", UDim2.new(0.2,0,0.2,0), UDim2.new(0.1,0,-0.2, -1), player), {
        BackgroundColor3 = Color3.new(1,1,1),
        Name = "LookDirection"
    })
    apply(gui:AddLerp(player, {
        Rotation = {0, 360}
    }, 0), {Name = "Orientation"})
    apply(Instance.new"ObjectValue", {
        Value = humanoid,
        Name = "Humanoid",
        Parent = folder
    })
    folder.Parent = npcfolder
end
local function removeplayer(name)
    if not enabled then return end
    local x = pfolder:FindFirstChild(tostring(name))
    pcall(game.Destroy, x)
    gui:RemovePopup(x:FindFirstChild"Player")
end
local function removenpc(name)
    if not enabled then return end
    local x = npcfolder:FindFirstChild(name)
    pcall(game.Destroy, x)
    gui:RemovePopup(x:FindFirstChild"NPC")
end

sdata.Connections.Mapper.PlayerJoin = { stepper:Add(plrs, "PlayerAdded", "PlayerJoin", makeplayer) }
sdata.Connections.Mapper.PlayerLeave = { stepper:Add(plrs, "PlayerRemoving", "PlayerLeave", removeplayer) }
sdata.Connections.Mapper.NewHum = { 
    stepper:Add(
        workspace.Disaster,
        "DescendantAdded",
        "NPCAdd",
        function(c)
            if enabled and c.Name == 'Head' and c:IsA"BasePart" then
                makenpc(c)
            end
        end
    )
}

local function formatvector(v)
    return "[ "..tostring(v):gsub("(%-?%d+)%.?%d+", "%1").." ]"
end
local function inbetween(n,a,b)
    return n >= a and n <= b
end
local ploff = 0.0125*0.707 --sqrt2/16

local benchmarker = os.clock
sdata.Connections.Mapper.Main = { stepper:Add(game["Run Service"], "Heartbeat", "UpdateHeight", newcclosure(function()
    if not enabled then return end
    local t = benchmarker()
    local minvis, maxvis = map_boundaryscaler.AbsolutePosition, map_boundaryscaler.AbsolutePosition + map_boundaryscaler.AbsoluteSize
    for i,v in next, pfolder:GetChildren() do
        local root = getroot(v.Name)
        local viewpiece = v.Player
        if not root then viewpiece.Visible = false continue else viewpiece.Visible = true end
        
        viewpiece.Orientation.Value = -1*clamp((root.Orientation.Y)/360,-0.5,0.5)
        local px,py = clamp(0.475 + root.Position.X/400, 0, 0.9875), clamp(0.475 + root.Position.Z/400 , 0, 0.9875)+ 0.0125*0.707
        viewpiece.Position = UDim2.fromScale(
            px + ploff,
            py + ploff
        )
        viewpiece.Visible = inbetween(viewpiece.AbsolutePosition.X, minvis.X, maxvis.X) and inbetween(viewpiece.AbsolutePosition.Y, minvis.Y, maxvis.Y)
        if v.Name == lp.Name then
            local cam = v.Camera
            cam.Visible = viewpiece.Visible
            cam.Position = viewpiece.Position
            cam.Orientation.Value = atan(camera.CFrame.LookVector.X, -camera.CFrame.LookVector.Z)/(2*pi)
            local nextmovepos
            if (mcontainer.AbsoluteSize - maxsize).Magnitude < 10 then
                nextmovepos = UDim2.new()
            else
                local extentsoffset = map_extentsbox.AbsolutePosition - map_boundaryscaler.AbsolutePosition
                local maxoff = maxvis - ((map_extentsbox.AbsolutePosition+map_extentsbox.AbsoluteSize) - extentsoffset)
                local offsettoplayer = (minvis + map_boundaryscaler.AbsoluteSize/2) - (viewpiece.AbsolutePosition + viewpiece.AbsoluteSize/2)
                nextmovepos = map_extentsbox.Position + UDim2.fromOffset(offsettoplayer.X, offsettoplayer.Y)
            end
            ts:Create(map_extentsbox, deftween, {Position = UDim2.new(nextmovepos.X, nextmovepos.Y)}):Play()
        end
    end
    for i,v in next, npcfolder:GetChildren() do
        local root = v:FindFirstChild"Humanoid" and v.Humanoid.Value
        root = root and root:IsDescendantOf(game) and (root.Name == 'Head' and root or root.RootPart)
        if not root then removenpc(tostring(v)) continue end
        local viewpiece = v.NPC
        
        viewpiece.Orientation.Value = -1*clamp((root.Orientation.Y)/360,-0.5,0.5)
        local px,py = clamp(0.475 + root.Position.X/400, 0, 0.9875), clamp(0.475 + root.Position.Z/400, 0, 0.9875)
        --viewpiece.Visible = px <= extents.X and py <= extents.Y
        viewpiece.Position = UDim2.fromScale(
            px + ploff,
            py + ploff
        )
        viewpiece.Visible = inbetween(viewpiece.AbsolutePosition.X, minvis.X, maxvis.X) and inbetween(viewpiece.AbsolutePosition.Y, minvis.Y, maxvis.Y)
    end
    --[[print("Players: "..#pfolder:GetChildren())
    print("NPCs: "..#npcfolder:GetChildren())
    print("Time taken: "..(benchmarker() - t))
    print()]]
    local root = getroot()
    if not root then
        return
    end
    --posindicator.Text = formatvector(root.Position)
    heightcounter_updater.Value = clamp(-1 * ((root.Position.Y+2)/400) + 0.5,0,1)
    if mcontainer.AbsoluteSize == maxsize then return end
    local newcenter = pfolder:FindFirstChild(lp.Name)
    local mc_center = mcontainer.AbsolutePosition + mcontainer.AbsoluteSize/2
end), 0.1) }

data.MapCache = {}
local function loadmap(name, img)
    --local map = data.MapCache[name]
    --if not map then
    local save
    if true or img then --XD!!!!??!!!???
        save = getsynasset("bell/sd2/minimap/"..name..".png", true)
        defmapframe.Image, data.MapCache[name] = save, save
    else --ya for creating new map art (its a dif script)
        defmapframe:ClearAllChildren()
        local map = fetcher.GetSave("bell/sd2/minimap/"..name)
        for i,v in next, map do
            apply(Instance.new"ImageLabel", {
                BackgroundTransparency = v.T,
                Size = UDim2.fromScale(v.S.X,v.S.Y),
                Position = UDim2.fromScale(v.P.X,v.P.Y),
                BackgroundColor3 = Color3.new(v.C.R - 0.098,v.C.G - 0.098,v.C.B - 0.098),
                Rotation = -v.R,
                Parent = defmapframe,
                BorderSizePixel = 0,
                BorderColor3 = Color3.new(v.C.R - 0.05,v.C.G - 0.05,v.C.B - 0.05),
                --Image = v.Tx and "rbxassetid://"..v.Tx:sub(2) or nil
            })
        --if v.Tx then print(v.Tx) end
        end
    end
    --end
    data.LastMap = save
end
local function updatemap(model) --
    if not (mapson and model and model:IsA"Model") then return
    elseif tostring(model) == 'Molten Metal' then
        local lava = model:WaitForChild("Lava", 15)
        if not lava then return warn("lol diff molten?") end
        loadmap(lava.BrickColor.Name == 'Pastel blue-green' and 'Molten Metal Blue' or 'Molten Metal Red')
    elseif tostring(model) == 'Moonbase' then
        local floor = model:WaitForChild("Terrain", 15) and model.Terrain:WaitForChild("Baseplate", 15)
        if not floor then return warn("lol diff moonbase?") end
        loadmap(floor.BrickColor.Name == 'Ghost grey' and 'Moonbase Night' or 'Moonbase Day')
    elseif tostring(model) == 'Galantasy' then
        local healpad = model:WaitForChild("HealPads", 15) and model.HealPads:WaitForChild("Pad", 15) and model.HealPads.Pad:WaitForChild("Union",15)
        if not healpad then return warn("lol diff gala?") end
        loadmap(healpad.BrickColor.Name == 'Bright yellow' and 'Galantasy Blue' or 'Galantasy Purple')
    else 
        loadmap(tostring(model))
    end
    return
end
updatemap(map:FindFirstChildWhichIsA"Model")
sdata.Connections.Mapper.MapSync = { stepper:Add(map, "ChildAdded", "MapSync", updatemap) }
gui:MakeResizable(heightcounter_container, mcontainer, minsize, maxsize).ZIndex = 68999
gui:MakeDraggable(heightcounter_container, mcontainer)
gui:Enable()

local function offplrs()
    pfolder:ClearAllChildren()
    makeplayer(lp)
    return
end
local function offnpcs()
    npcfolder:ClearAllChildren()
    return
end
local function onplrs(addon)
    if not addon then offnpcs() end
    offplrs()
    for i,v in next, plrs:GetPlayers() do if v == lp then continue end makeplayer(v) end
end

local function onnpcs(addon)
    if not addon then offplrs() end
    offnpcs()
    for i,v in next, workspace.Disaster:GetDescendants() do if v.Name == 'Head' and v:IsA"BasePart" then makenpc(v) end end
end
local function allon()
    onplrs(true)
    onnpcs(true)
    return
end
local function alloff()
    offplrs()
    offnpcs()
end
local valids = {All = allon, NPCs = onnpcs, Players = onplrs, None = alloff } --none is only lp
function module:Track(n)
    assert(typeof(n) == 'string' and valids[n], "Invalid option: "..tostring(n))
    
    option = n
    valids[n]()
    
    return n
end
function module:LoadMaps(bool)
    mapson = bool and true --into bool
    if mapson then
        loadmap(map:FindFirstChildWhichIsA"Model")
    else
        loadmap(69)
    end
end

module.Gui = gui.Gui
return module