--[[setfpscap(5)
game.ReplicatedStorage.Remotes.GoToMode:FireServer"Pacifist"
game.ReplicatedStorage.Remotes.GoToMode:FireServer("Pacifist", "Yes")]]
local lp = game.Players.LocalPlayer
game.ReplicatedStorage.Remotes.Ready:FireServer()
if not lp.Character then lp.CharacterAdded:Wait() end

if workspace:FindFirstChild"afker" then workspace.afker:Destroy() end
for i,v in pairs(game.Workspace:GetChildren()) do
    if v.Name == "afker" then
        game.Workspace.afker:Destroy()
        game.CoreGui.afkGui:Destroy()
    end
end

if not isfile("deaths.txt") then
    writefile("deaths.txt", "Deaths: ")
end
wait(0.3)
--variables and functions
local player = game.Workspace[game.Players.LocalPlayer.Name]
local spawned = false
local belowed = false
local aboved = false

--gui
local afkGui = Instance.new("ScreenGui", game.CoreGui)
afkGui.Name = "afkGui"

local sfBtn = Instance.new("TextButton", afkGui)
sfBtn.Name = "SurfaceButton"
sfBtn.BackgroundColor3 = Color3.new(0.333333, 0.333333, 0.333333)
sfBtn.Size = UDim2.new(0, 150, 0, 25)
sfBtn.Font = Enum.Font.SourceSans
sfBtn.Text = "To Surface"
sfBtn.TextColor3 = Color3.new(1, 1, 1)
sfBtn.TextScaled = true
sfBtn.TextSize = 14
sfBtn.TextWrapped = true
sfBtn.Position = UDim2.new(0.5, -75, 1, -25)

local bBtn = sfBtn:Clone()
bBtn.Parent = sfBtn.Parent
bBtn.Name = "LowerButton"
bBtn.Text = "To Below"
bBtn.Position = UDim2.new(0.4, -75, 1, -25)

local aBtn = sfBtn:Clone()
aBtn.Parent = sfBtn.Parent
aBtn.Name = "AboveButton"
aBtn.Text = "To Above"
aBtn.Position = UDim2.new(0.6, -75, 1, -25)

--parts
local main = Instance.new("Folder", game.Workspace)
main.Name = "afker"
local walls = Instance.new("Folder", main)
walls.Name = "Walls"
local platforms = Instance.new("Folder", main)
platforms.Name = "Platforms"

local below = Instance.new("Part", platforms)
below.CanCollide = false
below.Name = "below"
below.Anchored = true
below.Size = Vector3.new(400,1,400)
below.Position  = Vector3.new(0,-130,0)
below.Material = "ForceField"
below.Transparency = 0.25

local bWall = below:Clone()
bWall.Name = "bWall"
bWall.Parent = walls
bWall.Position = bWall.Position + Vector3.new(0,50,-100)
bWall.Size = Vector3.new(150,100,5)

local spawnStop = below:Clone()
spawnStop.Parent = platforms
spawnStop.Name = "Spawn Barrier"
spawnStop.Position = Vector3.new(0,43,82)
spawnStop.Size = Vector3.new(30,1,30)

local above = below:Clone()
above.Parent = platforms
above.Name = "above"
above.CFrame = above.CFrame + Vector3.new(0,250, 0)

local aWall = bWall:Clone()
aWall.Parent = walls
aWall.Name = "aWall"
aWall.CFrame = aWall.CFrame + Vector3.new(0,250,0)

local barrier0 = below:Clone()
barrier0.Parent = platforms
barrier0.Name = "0,0,0 barrier"
barrier0.Position = Vector3.new(0,0,0)
--button functions

sfBtn.MouseButton1Click:Connect(function()
    if aboved then
        aboved = false
        above.CanCollide = false
        aWall.CanCollide = false
    end
    if belowed then
        belowed = false
        below.CanCollide = false
        bWall.CanCollide = false
    end
    if not spawned then
        spawned = true
        spawnStop.CanCollide = true
        game.Workspace[player.Name].HumanoidRootPart.CFrame = spawnStop.CFrame + Vector3.new(0,5,0)
    else if spawned then
        spawned = false
        spawnStop.CanCollide = false
    end
    end
end)

aBtn.MouseButton1Click:Connect(function()
    if spawned then
        spawned = false
        spawnStop.CanCollide = false
    end
    if belowed then
        belowed = false
        below.CanCollide = false
        bWall.CanCollide = false
    end
    if not aboved then
        aboved = true
        above.CanCollide = true
        aWall.CanCollide = true
        game.Workspace[player.Name].HumanoidRootPart.CFrame = above.CFrame + Vector3.new(0,5,0)
    else if aboved then
        aboved = false
        above.CanCollide = false
        aWall.CanCollide = false
    end
    end
end)

bBtn.MouseButton1Click:Connect(function()
    if aboved then
        aboved = false
        above.CanCollide = false
        aWall.CanCollide = false
    end
    if spawned then
        spawned = false
        spawnStop.CanCollide = false
    end
    if not belowed then
        belowed = true
        below.CanCollide = true
        bWall.CanCollide = true
        game.Workspace[player.Name].HumanoidRootPart.CFrame = below.CFrame + Vector3.new(0,5,0)
    else if belowed then
        belowed = false
        below.CanCollide = false
        bWall.CanCollide = false
    end
    end
end)

local belows = {
    "Epic Katana",
    "Volcano",
    "Giant Gun",
    "Fireworks",
    "Sniper",
    "Delinquent", --end of new!
    "Acid Rain",
    "Alexnewtron",
    "Alien Invasion",
    "Avalanche",
    "Beehive",
    "Bombers",
    "Cactoball",
    "Cake",
    "Coil Noobs",
    "Vampires",
    "Coin Balloon",
    "Crazy Robloxian",
    "Crimson Balrog",
    "Doge",
    "Dynamites",
    "Epic Duck",
    "Explosive Noobs",
    "Falling Hoops",
    "Ghosts",
    "Giant Noob",
    "Guest Ambush",
    "Hot Potato",
    "Icicles",
    "Killbots",
    "Korblox Mages",
    "Lumberjack",
    "Meteors",
    "Mine Spawn",
    "Missile Launcher",
    "Missile Strike",
    "Mr. Happy",
    "Murderers",
    "Neon Trooper",
    "Neon Blaster",
    "Ninjas",
    "Noobs",
    "Nuclear Bomb",
    "Overseer Soldiers",
    "Pacman",
    "Poltergeist",
    "Polyhex",
    "Raining Tacos",
    "Redcliff Warriors",
    "Rocket Noobs",
    --"Sandstorm",
    "Shedletsky",
    "Shoop Da Whoop",
    "Sighters",
    "Slenderman",
    "Soccer Balls",
    "Spiked Walls",
    "Stonetroid",
    "Thieves",
    "Thunderstorm",
    "Time Bombs",
    "Tiny Noobs",
    "Tornado",
    "Tsunami",
    "Undyne",
    "Witch",
    "Wolven Footsoldier",
    "Zombies",
    "Counterfeit Coins",
    "Illumina"
    }

local aboves = {
    "Flash Flood",
    "Giant Zombie",
    "Rising Acid",
    "Rising Lava",
    "Oil Spill",
    --"Spiked Walls",
    --"Volcano"
    }

alrRan = false
function checkBelow()
    if #game.Workspace.Disaster:GetChildren() == 0 and alrRan then
        alrRan = false
        aboved = false
        above.CanCollide = false
        aWall.CanCollide = false
        belowed = false
        below.CanCollide = false
        bWall.CanCollide = false

        spawned = true
        spawnStop.CanCollide = true
        game.Workspace[player.Name].HumanoidRootPart.CFrame = spawnStop.CFrame + Vector3.new(0,5,0)
    end
    local custom = false
    if not alrRan then
        for x,e in pairs(game.Workspace.Disaster:GetChildren()) do --for item in disaster list
            for i,v in pairs(belows) do
                if e.Name == v then --if disaster name equals item in list
                    alrRan = true
                    if aboved then
                        aboved = false
                        above.CanCollide = false
                        aWall.CanCollide = false
                    end
                    if spawned then
                        spawned = false
                        spawnStop.CanCollide = false
                    end
                    belowed = true
                    below.CanCollide = true
                    bWall.CanCollide = true
                    game.Workspace[player.Name].HumanoidRootPart.CFrame = below.CFrame + Vector3.new(0,5,0)
                    if e.Name == "Illumina" then
                        game.Workspace[player.Name].HumanoidRootPart.CFrame += Vector3.new(0,0,-95)
                        wait(1)
                        touch(
                            game.Workspace[player.Name].HumanoidRootPart,
                            e:FindFirstChild("TouchInterest", true).Parent
                        )
                    end
                    break
                end
            end
        end
    end
end
local fluxus = identifyexecutor():find'Fluxus' --dude make it so that parts with cantouch can still send events
local function touch(part, optreciever)
    --optreciever = (optreciever and optreciever:IsA"BasePart" and optreciever) or getroot(optreciever) --getroot(nil) = lp
    if not optreciever then return end
    if not fluxus then
        firetouchinterest(part, optreciever, 0)
        firetouchinterest(part, optreciever, 1)
    else
        local prepart, preopt = part.CanTouch, optreciever.CanTouch
        part.CanTouch, optreciever.CanTouch = true, true

        firetouchinterest(part, optreciever, 0)
        firetouchinterest(part, optreciever, 1)
        part.CanTouch, optreciever.CanTouch = prepart, preopt
    end
    
end

function checkAbove()
    if #game.Workspace.Disaster:GetChildren() == 0 and alrRan then
        alrRan = false
        aboved = false
        above.Size = Vector3.new(400,1,400)
        above.CanCollide = false
        aWall.CanCollide = false
        belowed = false
        below.CanCollide = false
        bWall.CanCollide = false

        spawned = true
        spawnStop.CanCollide = true
        game.Workspace[player.Name].HumanoidRootPart.CFrame = spawnStop.CFrame + Vector3.new(0,5,0)
    end
    if not alrRan then
        for x,e in pairs(game.Workspace.Disaster:GetChildren()) do --for item in disaster list
            for i,v in pairs(aboves) do
                if e.Name == v then --if disaster name equals item in list
                    alrRan = true
                    if belowed then
                        belowed = false
                        below.CanCollide = false
                        bWall.CanCollide = false
                    end
                    if spawned then
                        spawned = false
                        spawnStop.CanCollide = false
                    end
                    print(e.Name)
                    aboved = true
                    above.CanCollide = true
                    aWall.CanCollide = true
                    game.Workspace[player.Name].HumanoidRootPart.CFrame = above.CFrame + Vector3.new(0,5,0)
                    if e.Name == 'Oil Spill' then
                        above.Size = Vector3.new(10,1,10)
                        aWall.CanCollide = false
                    end
                end
                
                
            end
        end
    end
end
local wait = task.wait
local insert = table.insert

local step = 10
local boundsX = {-190, 190}
local boundsY = {-90, 120}
local boundsZ = boundsX

local function pointiswithin(x, y, cx, cy, r, ext)
	return ((x-cx)^2 +  (y-cy)^2)^0.5 <= r + (ext or 0)
end

local function linearfindpointwithblacklist(bx, by, s, blacklist)
	for y = by[1], by[2], s do
		for x = bx[1], bx[2], s do --ouch
			
			local valid = true
			for i,v in next, blacklist do
				if pointiswithin(x, y, unpack(v)) then valid = false break end
			end
			
			if valid then return x, y end
		end
	end
	return
end
local function tryvelocityasync(part, delta)
	assert(part:IsA"BasePart", "Not a part")
	if not (part.Anchored or part:IsGrounded()) then return part.Velocity end
	local p1 = part.Position
	delta = wait(delta)
	return (p1 - part.Position)/delta
end

local function getXYatZ(part, z)
	local velocity = tryvelocityasync(part, 0.1)
	local init = part.Position
	--disp = initial + v*t + 1/2at^2 where a = 0
	--z = initial + velocity * t
	--t = (z - initial)/velocity
	if velocity.Z == 0 then return nil end
	local time = (z - init.Z)/velocity.Z
	
	return init.X + velocity.X*time, init.Y + velocity.Y * time
end

local function getnextreapersafespot()
	local balls = {}
	for i,v in next, workspace:GetChildren() do
		if v.Name == 'Fire' and v.BrickColor == BrickColor.new("Really red") and v.Parent then
			local x,y = getXYatZ(v, 195)
			if not x then continue end --err
			
			insert(balls, {x, y, 115})
		end
	end
	
	local x,y = linearfindpointwithblacklist(boundsX, boundsY, step, balls)
	return x and Vector3.new(x,y,195)
end

local function smallpredict(part)
    local lol = part.Position + part.Velocity * game.Stats.PerformanceStats.Ping:GetValue() * 3e-3
    return lol.X, lol.Z
end

local fireworks = {}
local function addfirework(v)
    if not (v) then return end

    fireworks[v] = tick()
end
local function checkfwks()
    for fw, spawn in next, fireworks do
		if tick() - spawn > 7 then rawset(fireworks, fw, nil) end --fuse time 5s + ~1 second explosion (+1s for safety)
    end
    return fireworks
end
local function getnextfireworksafespot()
	local balls = {}
	for fw, spawn in next, checkfwks() do
        local x,z = smallpredict(fw)
        insert(balls, {x, z, 30})
	end
	
	local x,z = linearfindpointwithblacklist(boundsX, boundsZ, step, balls)
	return x and Vector3.new(x,0,z)
end
if _G.fwkcheck then _G.fwkcheck:Disconnect() end
--_G.fwkcheck = workspace.ChildAdded:Connect(addfirework)
--specials
--fireball in workspace
--poison in model
function checkDisasters()
    if #game.Workspace.Disaster:GetChildren() == 0 and alrRan then
        alrRan = false
        aboved = false
        above.CanCollide = false
        aWall.CanCollide = false
        belowed = false
        below.CanCollide = false
        bWall.CanCollide = false

        spawned = true
        spawnStop.CanCollide = true
        game.Workspace[player.Name].HumanoidRootPart.CFrame = spawnStop.CFrame + Vector3.new(0,5,0)
    end
    local hrp = game.Workspace[player.Name].HumanoidRootPart
    hrp.Velocity = Vector3.zero
    for i,v in pairs(game.Workspace.Disaster:GetChildren()) do
        if v.Name == "Black Mage" then
            --game.Workspace.Fireball:Destroy()
            --game:GetService("Workspace").Disaster["Black Mage"]["Black Mage"]:Destroy()
        end
        if v.Name == "Press The Button" then
            alrRan = true
            if game.ReplicatedStorage.Info.Notice.Value == 'Press The Button' then --nonhyper
                hrp.CFrame = CFrame.new(190,-80,190)
            else
                for i,v in pairs(v:GetDescendants()) do
                    if v.Name == "Trigger" then
                        hrp.CFrame = CFrame.new(v.Position) + Vector3.new(0,3,0)
                        hrp.Velocity = Vector3.zero
                    end
                end
            end
        end
        if v.Name == "Caterdriller" then
            for w,f in pairs(v:GetChildren()) do
                f:Destroy()
            end
        end
        if v.Name == 'Epic Katana' then
            hrp.CFrame = CFrame.new(Vector3.new(-190, -50, -190))
        end
        if v.Name == 'Volcano' then
            local posxz = v:WaitForChild"Volcano":WaitForChild"Or".Position.Unit * -Vector3.new(270,0,270)
            
            hrp.CFrame = CFrame.new(posxz + hrp.Position*Vector3.new(0,1,0))
        end
        if v.Name == "Nuclear Bomb" then
            local posxz = v:WaitForChild"Point".Position
            posxz = posxz + Vector3.new(posxz.X <= 0 and 19 or -190, -posxz.Y, posxz.Z <= 0 and 190 or -190)
            hrp.CFrame = CFrame.new(posxz + hrp.Position*Vector3.new(0,1,0))
        end
        if v.Name:find"Sand" then
            alrRan = true
            hrp.CFrame = CFrame.new(59.2,70,193.4)
        end
        if v.Name == 'Sniper' then
            alrRan = true
            hrp.CFrame = CFrame.new(0,-50,0)
        end
        if v.Name == "Green Zone" then
            alrRan = true
            for q,e in pairs(v:GetDescendants()) do
                if e.Name == "Zone" then
                    hrp.CFrame = CFrame.new(e.Part.Position * Vector3.new(1,0,1) - Vector3.new(0,80,0))
                    
                end
            end
        end
        if v.Name == 'Reaper' and v:FindFirstChild("Crimson Reaper") then
            local v = getnextreapersafespot()
            if v then
                alrRan = true
                hrp.CFrame = CFrame.new(v)
                hrp.Velocity = Vector3.zero
            end
        end
    end
end

--fire and wave in workspace
function checkWorkspaceDeletables()
    if true then return end
    for i,v in pairs(game.Workspace:GetChildren()) do
        if v.Name == "EK" or v.Name == "Pizza" or (v.Name == "Part" and v:FindFirstChild("Texture") and v:FindFirstChild("Script")) or v.Name == "Wave" or v.Name == "Fire" or v.Name == "Rock" then
            v:Destroy()
        end
    end
end

--yoji
local comped = false
local part
local baseY
local xd
function complicatedones()
    if #game.Workspace.Disaster:GetChildren() == 0 then
        comped = false
        xd:Destroy()
    end
    if not comped then
        for i,v in pairs(game.Workspace.Disaster:GetChildren()) do
            if v.Name == "Yojimbo" then
                for f,g in pairs(v:GetDescendants()) do
                    if g.Name == "Head" then
                        part = g
                        alrRan = true
                        comped = true
                        xd = Instance.new("Part", game.Workspace)
                        xd.Anchored = true
                        xd.Name = "stool lol"
                        player.HumanoidRootPart.CFrame = below.CFrame + Vector3.new(0,5,0)
                        baseY = part.Position.Y - player.HumanoidRootPart.Position.Y 
                    end
                end
            end
        end
    end
    if comped then
        for i,v in pairs(game.Workspace.Disaster:GetChildren()) do
            if v.Name ~= "Yojimbo" then
                v:Destroy()
                comped = false
            end
        end
        if game.Workspace.Disaster:FindFirstChild("Yojimbo") then
            player.HumanoidRootPart.CFrame = Vector3.new(part.Position.X, -40, part.Position.Z)
            xd.CFrame = player.HumanoidRootPart.CFrame - Vector3.new(0,2.48,0)
        else do
            comped = false
            alrRun = false
            for i,v in pairs(game.Workspace:GetChildren()) do
                if v.Name == "stool lol" then v:Destroy() end
            end
        end
        end
    end
end

local dead = false
function checkdead()
    local txt = "("
    if game:GetService("Players")[player.Name].PlayerGui.Leaderboard.Frame[lp.Name].NameTag.TextColor3 == Color3.new(1,0,0) and not dead then
            for i,v in pairs(game.Workspace.Disaster:GetChildren()) do if v:IsA("Model") then txt = txt..v.Name end end
            txt = txt..") "
            appendfile("deaths.txt", txt.." <- {{ "..os.date().." "..lp.Name.." "..game:GetService("Players")[player.Name].PlayerGui.Leaderboard.Frame[lp.Name].Streak.Text.."}}\n")
            print("Player has died to "..txt)
            dead = true
    else do
        if game:GetService("Players")[player.Name].PlayerGui.Leaderboard.Frame[lp.Name].NameTag.TextColor3 == Color3.new(1,1,1) and dead then
            print("plrRespawn")
            dead = false
        end
    end
    end
end

--spawner blocks
local blockers = Instance.new("Folder", main)
blockers.Name = "Spawner Blockers"

local model = Instance.new("Model", blockers)
model.Name = "Blocker"

local base = Instance.new("Part", model)
model.PrimaryPart = base
base.Name = "Base"
base.Anchored = true
base.CanCollide = false
base.Size = Vector3.new(50,2,50)
base.Material = "ForceField"
base.Transparency = 0.25
base.Position = Vector3.new(0,3,0)

local side1 = base:Clone()
side1.Parent = model
side1.Name = "Side1"
side1.Size = Vector3.new(50,50,2)

local side2 = base:Clone()
side2.Parent = model
side2.Name = "Side2"
side2.Size = Vector3.new(2,50,50)

local side3 = base:Clone()
side3.Parent = model
side3.Name = "Side3"
side3.Size = Vector3.new(50,50,2)

local side4 = base:Clone()
side4.Parent = model
side4.Name = "Side4"
side4.Size = Vector3.new(2,50,50)

local top = base:Clone()
top.Name = "top"
top.Parent = model
function getMap()
    for i,v in pairs(game.Workspace.Map:GetChildren()) do
        if v:IsA("Model") then
            return v
        end
    end
end
function getDis()
    local text = ""
    for i,v in pairs(game.Workspace.Disaster:GetChildren()) do
        if v:IsA("Model") then
            text = text..v.Name.." "
        end
    end
    return text
end
local lastMap = getMap().Name
for i,v in pairs(getMap().EnemySpawns:GetChildren()) do
    local new = model:Clone()
    new.Parent = blockers
    new.PrimaryPart.Position = v.Position
end

--model.Parent = game.ReplicatedStorage

function doSpawners()
    if lastMap ~= getMap().Name then
        wait(3)
        for i,v in pairs(blockers:GetChildren()) do
            v:Destroy()
            lastMap = getMap().Name
        end
        for i,v in pairs(getMap().EnemySpawns:GetChildren()) do
            local new = model:Clone()
            new.Parent = blockers
            new.PrimaryPart = new.Base
            new.PrimaryPart.Position = v.Position
        end
    end
    for i,v in pairs(blockers:GetChildren()) do
        for x,h in pairs(v:GetChildren()) do
            if h.Name == "Base" and (belowed or aboved) or (getDis() == "Yojimbo") then
                h.CanCollide = true
            else do
                h.CanCollide = false
            end
            end
            if h.Name ~= "Base" then
                h.CanCollide = v.Base.CanCollide
            end
        end
        v.Side1.CFrame = v.Base.CFrame + Vector3.new(0,24,24)
        v.Side2.CFrame = v.Base.CFrame + Vector3.new(24,24,0)
        v.Side3.CFrame = v.Base.CFrame + Vector3.new(0,24,-24)
        v.Side4.CFrame = v.Base.CFrame + Vector3.new(-24,24,0)
        v.top.CFrame = v.Base.CFrame + Vector3.new(0,48,0)
    end
end

local last = getDis()
function unanchor()
    if #game.Workspace.Disaster:GetChildren() == 0 then
        alrRan = false
        player.HumanoidRootPart.Anchored = false
    end
end
while game.Workspace:FindFirstChild("afker") do
    task.wait()
    
    --neon and yoji who can shoot hitscan under the map
    --highest priority (because these can kill you very easily)
    --pcall(complicatedones)
    local x = workspace.Disaster:FindFirstChild"Yojimbo"
    if x then
        x = x:FindFirstChild("Head", true)
        if x then
            local y = lp.Character and lp.Character:FindFirstChild"HumanoidRootPart"
            if y then y.CFrame = CFrame.new(Vector3.new(x.Position.X, -40, x.Position.Z)) y.Velocity = Vector3.zero continue end
        end
        
    end
    --high priority
    pcall(checkDisasters) --mage, ptb
    pcall(checkWorkspaceDeletables) --pizza, epic katana, happy

    --low priority
    pcall(checkAbove)
    pcall(checkBelow)
    pcall(unanchor)

    
    pcall(checkdead)
    pcall(doSpawners)
    

    if not spawned and (aboved or belowed) then
        barrier0.CanCollide = true
    else do
        barrier0.CanCollide = false
    end
    end

    if getDis() ~= last then
        alrRan = false
        comped = false
        last = getDis()
    end

    if #game.Workspace.Disaster:GetChildren() == 0 then
        
        pcall(function()
            local hrp = game.Workspace[player.Name].HumanoidRootPart
            if (hrp.Position - spawnStop.Position).Magnitude > 15 then
                spawned = true
                spawnStop.CanCollide = true
                hrp.CFrame = spawnStop.CFrame + Vector3.new(0,5,0)
            end
        end)
    end

    local citypark = workspace.Map:FindFirstChild"City Park"
    if not (citypark and citypark:FindFirstChild"Terrain") then continue end
    for i,v in next, citypark.Terrain:GetChildren() do
        if not (v.Name == 'Part' and v:FindFirstChild'Texture' and v.Position.Y < -20) then continue end
        local diff = -(20 - v.Size.Y) * 0.5
        v.Size = v.Size * Vector3.new(1,0,1) + Vector3.new(0, 20)
        v.Position = v.Position * Vector3.new(1,0,1) + Vector3.new(0,v.Position.Y + diff)
    end
end

afkGui:Destroy()


