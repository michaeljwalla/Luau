local rs = game.ReplicatedStorage
local remotes = rs.Remotes
local orbs = require(rs.Modules.Orbs)

local buyorb = remotes.BuyOrb --remotefunc
local sellorb = remotes.SellOrb --event
local exchangeorb = remotes.ExchangeOrbs --event
local upgear = remotes.UpgradeGear
local downgear = remotes.DeleteUpgrade
local recache = game.ReplicatedStorage.Remotes.ReturnIU --remotefunc

local clr, insert, find = table.clear, table.insert, table.find
local floor = math.floor

local module = setmetatable({Module = orbs, cache = {}, cachegears = {}, cacheformat = {{}, {}, {}, {}, {}}}, {__index = function(self, index)
    if orbs[index] then --normal __index
        return orbs[index]
    elseif orbs.orbTypes[index] then --searching by id
        return orbs.orbTypes[index]
    elseif typeof(index) == 'string' then --searching by name
        for i,v in next, orbs.orbTypes do
            if v.Name ~= index then continue end
            rawset(self, index, setmetatable({ OrbId = i }, { __index = v }))
            return self[index]
        end
    end
end})

function module:recache()
    local new, gears = recache:InvokeServer()
    
    for i,v in next, self.cacheformat do clr(v) end
    clr(self.cache)
    clr(self.cachegears)
    self.cache = new
    self.cachegears = gears

    for i,v in next, new do
        self.cacheformat[ v.Level ][ self[v.OrbId].Name ] = v
    end
    return new, gears
end
--module:recache()
function module:buy1()
    local neworbs = buyorb:InvokeServer(1)
    local new = neworbs[1]
    local lvl, id = new.Level, new.OrbId
    for i,v in next, self.cache do
        if v.OrbId == id and v.Level == lvl then
            v.Quantity = v.Quantity + new.Quantity -- should update cacheformat since tables are linked?
        end
    end
    --insert(self.cache, new) --if no prev entry exists
    self.cacheformat[lvl][self:name(new)] = new
    return neworbs
end
function module:buy5()
    local indxcache = {}
    local neworbs = buyorb:InvokeServer(5)
    for i,v in next, neworbs do
        local id, lvl, quantity = v.OrbId, v.Level, v.Quantity
        local hash--[[xd]] = (id+1)^(lvl^(1/3))
        
        local wascached = indxcache[hash]
        if wascached then
            self.cache[wascached].Quantity = self.cache[wascached].Quantity + quantity
            local x = self.cacheformat[lvl][self:name(v)]

        else
            local found
            
            for i,v in next, self.cache do
                if v.Level == lvl and v.OrbId == id then
                    v.Quantity = v.Quantity + quantity
                    indxcache[hash] = i
                    found = true
                    break
                end
            end
            if found then continue end --if no prev entry exists
            --insert(self.cache, v)
            self.cacheformat[lvl][self:name(v)] = v
            indxcache[hash] = #self.cache
        end
    end

    clr(indxcache)
    return neworbs
end
function module:invformat() return self.cacheformat end
function module:inventory() return self.cache end
function module:gears() return self.cachegears end
--[[

orbentry format
{
    OrbId = <number>,
    Level = <number>,
    <?> Quantity = <number>
}

its stored in inventory
]]
function module:rarity(orbentry)
    return "[ "..self.levelNames[orbentry.Level].." ]"
end
function module:name(orbentry)
    return self[orbentry.OrbId].Name
end
function module:description(orbentry, richrgb)
    local me = self[orbentry.OrbId]
    local check = me.Levels[orbentry.Level]
    return check and me.Description:format( check ) or "(Does not exist)"--"(Rarity nonexistent)"
end

function module:compatible(gearid, orbentry)
    local lookthru = self[gearid] or {}
    self[gearid] = lookthru

    local orbid = orbentry.OrbId
    if lookthru[orbid] == nil then
        lookthru[orbid] = find(self[orbid].Compatible, gearid) and true or false
    end
    return lookthru[orbid]
end


function module:exchange(id, level)
    local name = typeof(id) == 'number' and self[id].Name or id
    local cacheentry = self.cacheformat[ level ][ name ]
    id = typeof(id) == 'number' and id or self[id].OrbId
    exchangeorb:FireServer{
        OrbId = id,
        Level = level
    }
    
    if level == 5 then --random orb was given
        self:recache()
    elseif cacheentry then
        local neworbs = floor(cacheentry / 3)
        cacheentry.Quantity = cacheentry.Quantity % 3
        if cacheentry.Quantity % 3 == 0 then
            rawset(self.cache, find(self.cache, cacheentry), nil) --goodbye
            rawset(self.cacheformat[level], name, nil)
        end
        --add the next level
    end 
    return
end
function module:sell(id, level, amount)
    id = typeof(id) == 'number' and id or self[id].OrbId
    sellorb:FireServer({
        OrbId = id,
        Level = level
    }, amount)
    return
end
--[[

    gearcache is a list like this
    {
        {
            Slots = {
                orbentry,
                orbentry,
                orbentry
            },
            GearId = <number>
        }, {
            Slots = ...
        }
    }
]]
function module:upgrade(gearname, idOrname, level)
    idOrname = typeof(idOrName) == 'string' and idOrName or self[idOrName].Data.Name
    upgear:FireServer(gearname, self.cacheformat[level][idOrName])
end
function module:downgrade(gearname, orbslot) --1/2/3
    downgear:FireServer(gearname, orbslot)
end
function module:getgearupgrades(gearid)
    for i,v in next, self.gearcache do if v.GearId == gearid then return v.Slots end end
    return
end
return module