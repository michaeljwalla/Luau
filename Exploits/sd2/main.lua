print("welcome!")

if getgenv().autoreconnect or isfile"rememberautoreconnect" then
    local x = readfile("bell/sd2/main.lua")
    getgenv().autoreconnectscript = x
    loadfile("bell/autoreconnect.lua")()
end

shared.sdata = shared.sdata or {Connections = {}, Guis = {}, Data = {}}
local sdata = shared.sdata

if sdata.Queued then return end
sdata.Queued = true
while not game:IsLoaded() do task.wait() end
local plrs = game.Players

local getthread, rethread
if syn then
    getthread, rethread = syn.get_thread_identity, syn.set_thread_identity
else
    getthread, rethread = getthreadidentity, setthreadidentity
end

local lp = plrs.LocalPlayer
local function require(d, recache)
    shared.requirecache = shared.requirecache or {}
    if (typeof(d) ~= 'string') then
        local pre = getthread()
        rethread(2)
        local a = getfenv().require(d)
        rethread(pre)
        return a
    elseif d:find"^http" then return loadstring(game:HttpGet(d), d:sub(1,12))()
    else
        if not recache and shared.requirecache[d] then return shared.requirecache[d] end
        local n, a = pcall(readfile, d..".lua") --loadfile lol
        --print(({a:gsub("\n","\n")})[2] + 1)
        assert(n, "No local module '"..d.."'")
        local chunk = loadstring(a, d)
        assert(chunk, "Error in local: "..d)
        shared.requirecache[d] = chunk()
        return shared.requirecache[d]
    end
end
local function hasprop(inst, prop, pcd)
    return pcd and inst[prop] or pcall(hasprop, inst, prop, true)
end
local function apply(inst, props)
    local parent = props.Parent
    props.Parent = nil
    for i,v in next, props do
        if hasprop(inst, i) then
            inst[i] = v
        end
    end
    if parent then inst.Parent = parent end
    return inst
end

local function notify(options) --Title, Text, Duration, Icon
    game.StarterGui:SetCore("SendNotification", options)
end
--[[if tick() - 1689687917 > 86400 then
    game.Players.LocalPlayer:Kick"Trial over."
    return
else
    notify{Title = "Trial Period", Text = ("You have about %d hours left to use this script."):format(math.round((86400 - (tick() - 1689687917)) / 3600))}
end]]
local rs = game.ReplicatedStorage
local remotes = rs.Remotes

if lp.PlayerGui:FindFirstChild"SplashScreenGui" then
    notify{Title = "Delayed Load", Text = "Playscreen detected - will continue loading when sd2 finishes"}
    task.wait(1)
    local cps = game:GetService"ContentProvider"
    while cps.RequestQueueSize > 0 do task.wait() end
    remotes.Ready:FireServer()
end

local datasaver = require("bell/DataSaver")

local gui = require("bell/gui", true) --make a new instance of it
local minimap


local stepper = require"bell/stepper"
local gears = require("bell/sd2/gears")
local orbs = require("bell/sd2/orbs") --orbs:recache() --done later in Shop
local shurikontroltools = require("bell/partmanipulation", true)
local tracer = require("bell/tracers", true)

--i needed more local registers
defer, foreachin = task.defer, table.foreach
pi = math.pi
cos, sin = math.cos, math.sin
cancel, status, running, resume = task.cancel, coroutine.status, coroutine.running, coroutine.resume
insert, spawn, delay = table.insert, task.spawn, task.delay

--unc good?
local request, isnetworkowner, checkcaller =
	syn and syn.request or http_request,
	isnetworkowner or function() return true end,
    checkcaller
--bro why are these env functions getting messed up inside of hooks on non synapse

max = math.max
random, intdiv, floor, clamp, abs, round = math.random, math.modf, math.floor, math.clamp, math.abs, math.round
local getasset = getsynasset or getcustomasset
local wait = task.wait
sync, desync = task.synchronize, task.desynchronize
local clr = table.clear
local cc = workspace.CurrentCamera
local mouse = lp:GetMouse()
local players, contexts = game:GetService"Players", game:GetService"ContextActionService"
local lighting, textservice, tweenservice, inputservice = game:GetService"Lighting", game:GetService"TextService", game:GetService"TweenService", game:GetService"UserInputService"
local disasters, map, lobby = workspace:WaitForChild"Disaster", workspace:WaitForChild"Map", workspace:WaitForChild"Lobby"

local notified
if sdata.Guis.sd2 then
    notified = true
    notify{Title = "Reloading script", Text = "Cleaning up...", Duration = 1}
    sdata.Guis.sd2:cleanup()
end
sdata.Guis.sd2 = gui
if sdata.Data.sd2 then
    
    local d = sdata.Data.sd2
    for i,v in next, d.Functions do
        if typeof(v) == 'string' then
            stepper:RemoveContext(v)
        elseif (v[1] and typeof(v[1]) == 'string' and v[1]:find"|") then
            stepper:Remove(unpack(v))
        end
    end
    for i,v in next, d.Connections do v:Disconnect() end
    for i,v in next, d.Tracers do for section, entry in next, v do entry:Destroy() end end
    if not notified then
        notify{Title = "Reloading script", Text = "Cleaning up...", Duration = 1}
        
        notified = true
    end
    if sdata.Connections.Mapper then for i,v in next, sdata.Connections.Mapper do if v[1] then stepper:Remove(unpack(v)) end end end
    if sdata.Guis.Mapper then sdata.Guis.Mapper:cleanup() end 

    pcall(game.Destroy, workspace:FindFirstChild"afker")
end
minimap = require("bell/sd2/minimap", true) --setmetatable({}, {__index = function(self, index) return function() end end}) -- 
minimap:Track("All")
if notified then
    wait(0.1) -- lol
    notify{Title = "Script reloaded", Text = "Welcome back!", Duration = 1}
end

local data = {
    Tracers = {},
    Connections = {}, --for non-stepper connections (usually once-ran or not-repeated established connections, no reason to use stepper:add)
    Options = (sdata.Data.sd2 and sdata.Data.sd2.Options) or (isfile"bell/sd2/autoload" and datasaver.GetSave"bell/sd2/options") or { MenuColors = {} },
    Functions = {},
    Keybinds = sdata.Data.sd2 and sdata.Data.sd2.Keybinds or {},
    CodeFuncs = {},
    Hooked = sdata.Data.sd2 and sdata.Data.sd2.Hooked or {},
    Settings = sdata.Data.sd2 and sdata.Data.sd2.Settings or {
        Tracers = {Method = "3D", Color = Color3.new(1)},
        Looks = { PopupTransparency = 0 }
    },
    Shared = sdata.Data.sd2 and sdata.Data.sd2.Shared or {},
    Unloaded = false
}
local trashedmt = { __mode = 'kv' }
local function trash(tbl, optreturn, heavy)
    if not type(tbl) == 'table' then
        return optreturn
    elseif not heavy then
        for i, v in next, tbl do
            rawset(tbl, i, nil)
        end
    else
        for i, v in next, tbl do
            if type(v) == 'table' then trash(v) end
            rawset(tbl, i, nil)
        end
    end
    setmetatable(tbl, trashedmt)
    return optreturn
end
local function savesettings()
    local new = {}
    for i,v in next, data.Options do
        new[i] = type(v) == 'userdata' and tostring(v) or v
    end
    datasaver.SetSave("bell/sd2/options", new)
    trash(new)
end
--savesettings()
sdata.Data.sd2 = data
local shareddata = data.Shared
local char, random = string.char, math.random
local function rand(len)
    local result = ""
    for i = 1, len do result = result..char(random(0,255)) end
    return result
end
local gravity = Vector3.new(0,-workspace.Gravity)

local function randomvector(magnitude)
    return Vector3.new(
        cos(2 * pi * random()),
        random() < 0.5 and sin(2 * pi * random()) or cos(2 * pi * random()),
        sin(2 * pi * random())).Unit * magnitude
end

local rbxsettings = settings()
local settings = data.Settings
local options = data.Options

local trsettings = settings.Tracers
local tracers = data.Tracers
local tracerfolder3d = settings.TracerFolder3D and settings.TracerFolder3D.Parent == workspace and settings.TracerFolder3D or apply(Instance.new"Folder", {Parent = workspace, Name = rand(13)})
settings.TracerFolder3D = tracerfolder3d

--togglefuncs is just the gendata func table
--keybinddata for customizing activations
local keybinds = data.Keybinds

local function registerkeybind(keybinddata, func, overwrite)
    local btn, ctrl, alt = typeof(keybinddata.Key) == 'EnumItem' and keybinddata.Key or Enum.KeyCode[keybinddata.Key], keybinddata.Ctrl, keybinddata.Alt
    local format = (ctrl and "Ctrl + " or "")..(alt and "Alt + " or "")..btn.Name
    if (keybinds[format] or keybinds[keybinddata.Info]) and not overwrite then
        return false, keybinds[format]
    end
    local numreps = keybinddata.Repetitions or 1
    local new = {
        Info = keybinddata.Info,
        Format = format..(numreps ~= 1 and " ( x"..numreps.." )" or ""),
        Key = btn,
        Ctrl = ctrl,
        Alt = alt,
        Repetitions = numreps,
        Fire = func,
        LastCall = 0,
        CurRep = 0
    }
    keybinds[format] = new --for controller to index
    keybinds[keybinddata.Info] = new --for others to index
    return true, new
end
local function removekeybind(keybinddata)
    local format = (keybinddata.Ctrl and "Ctrl + " or "")..(keybinddata.Alt and "Alt + " or "")..keybinddata.Key --should be str
    local keybind = keybinds[format]
    if keybind then rawset(keybinds, format, nil) rawset(keybinds, trash(keybind, keybind.Info), nil) return true end
    return false
end
--registerkeybind({Info = "LoL", Key = "Space", Ctrl = true, Alt = true, Repetitions = 3}, print, true)
local lctrl, rctrl, lalt, ralt = Enum.KeyCode.LeftControl,Enum.KeyCode.RightControl,Enum.KeyCode.LeftAlt,Enum.KeyCode.RightAlt
local function isctrling()
    return inputservice:IsKeyDown(lctrl) or inputservice:IsKeyDown(rctrl)
end
local function isalting()
    return inputservice:IsKeyDown(lalt) or inputservice:IsKeyDown(ralt)
end
insert(data.Functions, { stepper:Add(inputservice, "InputBegan", "KeybindController", function(input, wasfocused)
    local name = input.KeyCode.Name
    if (name ~= "Semicolon" and wasfocused) or name == 'Unknown' then return end
    local format = (isctrling() and "Ctrl + " or "")..(isalting() and "Alt + " or "")..name
    local keybind = keybinds[format]
    
    if not keybind then return end
    local cur = tick()
    keybind.CurRep = ((cur - keybind.LastCall > 0.25 and 0 or keybind.CurRep) + 1) % keybind.Repetitions
    keybind.LastCall = cur
    if keybind.CurRep == 0 then keybind.Fire(cur) end
end) })
local function newtracer(towhat, text, section, skipwarn, visibility, overrides)
    section = section or "Unspecified"
    overrides = overrides or {}
    local sect = tracers[section] or {}
    tracers[section] = sect
    if sect[towhat] then  return (not skipwarn and warn("Attempted to create a tracer which already exists to '"..tostring(towhat).."' (returning old tracer...)")) or sect[towhat] end
    local new = tracer.new(towhat)
    new:SetMethod(overrides.Method or trsettings.Method)
    new:SetColor(overrides.Color or trsettings.Color)
    new:SetText(text or tostring(towhat))
    new:SetVisible(visibility)
    
    if new.Method == '3D' then new.Components.Line.Parent = tracerfolder3d end
    tracers[section][towhat] = new
    return new
end
--newtracer(game.Players.InvisibleMissile1, "Lol", "Green Zone", true, true)
local function deltracer(section, obj)
    section = tracers[section]
    if not section then
        return
    elseif not obj then
        for i,v in next, section do
            rawset(section, i, nil)
            v:Destroy()
            trash(v)
        end
        return
    end
    for i,v in next, section do
        if v == obj then
            rawset(section, i, nil)
            v:Destroy()
            trash(v)
        end
    end
end

local fcounter = 0 --used later in Home menu
insert(data.Functions, { stepper:Add(game["Run Service"], "RenderStepped", "TracerDraw", function()
    fcounter = fcounter + 1
    for i,section in next, tracers do
        for a,tracer in next, section do
            if typeof(a) == 'Instance' and not a:IsDescendantOf(game) then
                rawset(section, a, nil)
                tracer:Destroy()
                trash(tracer)
            else
                tracer:Render()
            end
        end
    end
end) })
--maybe change to findfirstchild else childadded
spawn(pcall, function() --no physics kick
    rs:WaitForChild("Remotes", 15):WaitForChild("Test", 5).OnClientInvoke = function() return true end
    lp:WaitForChild("PlayerScripts", 15):WaitForChild("O:", 5).Disabled = true
    lp.PlayerScripts:WaitForChild("AntiFreeze", 5).Disabled = true--no freeze kick
end) 
insert(data.Functions, { stepper:Add(lp:WaitForChild("PlayerGui", 60) or error"no ui?", "ChildAdded", "BuiltInAntiAntiAFK",
    function(v) --no server afk kick
        if v.Name == 'QuestionGui' then
            local x = v:WaitForChild"Notice":WaitForChild"Question".Text
            v.Notice.Visible = false
            local y = v.Notice:WaitForChild"TextBox"
            local z = v.Notice:WaitForChild"Close"
            local numbers = x:match"%d %+ %d":split" + "
            local sum = tonumber(numbers[1]) + tonumber(numbers[2])
            y.Text = tostring(sum)
            wait(6)
            firesignal(z.MouseButton1Down)
        end
    end)
})
local vu = game:GetService("VirtualUser")
insert(data.Functions, { stepper:Add(lp, "Idled", "Anti20MinKick",
    function()
    	vu:CaptureController ()
    	vu:ClickButton2(Vector2.new())
    end)
})
local fontmodule = require(rs:WaitForChild"Modules":WaitForChild"Font")
local setnotice, locktimer = fontmodule.generateText

local timergui = lp:WaitForChild("PlayerGui", 15) and lp.PlayerGui:WaitForChild("TimerGui", 15) or error(notify{Title = "Fatal Error", Text = "Missing component: TimerGui"} or "Fatal error. Script aborted.")
local tframe = timergui:WaitForChild"TimerFrame"

local locktimer
do
    local timerentry = --[[data.Hooked.HideTimerChanged or (false and ]](require"bell/sd2/hooks")
    locktimer = function(t)
        if true then return end
        timerentry.ForcedDown = t
        firesignal(timerentry._signal)
        if t then
            tframe:TweenPosition(UDim2.new(tframe.Position.X, UDim.new()), "InOut", "Quad", 0.4)
            tframe.Visible = true
        end
    end
end

locktimer(false)

local function unpackc3(tbl)
    return tbl and Color3.fromRGB(unpack(tbl))
end

--gui:MakeResizable(gui._main, nil, Vector2.new(150,150), Vector2.new(400,400)).ZIndex = 50
local menu_home = gui:AddMenu("Home", unpackc3(options.MenuColors.Home) or gui:GetThemeColor"Accent")
local menu_undetectables, menu_gameplay, menu_gears, menu_shop, menu_playerstats, menu_cycle, --[[cycle and blox watch --will be part of serverstats]] menu_miscellaneous, menu_settings

local inf = 1/0
local function getmassof(part, ignorelist)
    ignorelist = ignorelist or {}
    ignorelist[part] = true
    local mass = part:GetMass()
    for i,v in next, part:GetConnectedParts() do
        --if anchored then return
        if mass == inf then break elseif not ignorelist[v] then mass = mass + getmassof(v, ignorelist) end
    end
    return mass
end

local function gethum(p)
    p = p or lp
    if p:IsA"Player" then
        return p.Character and p.Character:FindFirstChildWhichIsA"Humanoid"
    end
    return p:FindFirstChildWhichIsA"Humanoid"
end
local function getroot(p)
    local hum = gethum(p)
    return hum and hum.RootPart
end
local board = rs:WaitForChild("Board", 5)
if not board then error(notify{Title = "Fatal Error", Text = "Missing component: Board [ player stats ]"} or "Fatal error. Script aborted.") end

getfenv().statidentifier = {
    ['weekly blox'] = 'WeeklyEnemyExp', --why is weekly blox in xp and not coins?
    ['hc survs'] = 'TotalSurvivals2',
    ['weekly hc survs'] = 'WeeklySurvivals2',
    ['los'] = 'LastOneStanding',
    ['coins'] = 'Coins',
    ['weekly paci pb'] = 'WeeklyStreak3',
    ['hc paci pb'] = 'BestStreak4',
    ['weekly survs'] = 'WeeklySurvivals',
    ['total rounds'] = 'TotalRounds',
    ['weekly pb'] = 'WeeklyStreak',
    ['total survs'] = 'TotalSurvivals',
    ['hc pb'] = 'BestStreak2',
    ['weekly hc paci pb'] = 'BestStreak4',
    ['blox'] = 'TotalEnemyCoins', --double for xp
    ['pb'] = 'BestStreak',
    ['total xp'] = 'TotalExpEarned',
    ['paci pb'] = 'BestStreak3',
    ['gambles'] = 'Gachapon',
    ['weekly hc blox'] = 'WeeklyEnemyExp2', --why is weekly blox in xp and not coins?
    ['hc blox'] = 'TotalEnemyCoins2',
    ['weekly hc pb'] = 'WeeklyStreak2',
    ['pb hc sr'] = 'SkillRatingBest2',
    ['pb sr'] = 'SkillRatingBest',
    ['memos'] = 'MemosCollected',
    ['total coins'] = 'TotalCoinsEarned',
    ['sr'] = 'SkillRating',
    ['hc sr'] = 'SkillRating2'
}
local function getstat(type, plr, yield)
    plr = plr or lp --default to self

    local statsplr = board:FindFirstChild(tostring(plr))
    if not statsplr then return false end

    type = type:lower()

    local stat = statidentifier[type]
    if yield then
        stat = stat and statsplr:WaitForChild(stat, 15) and statsplr[stat].Value
    else
        stat = stat and statsplr:FindFirstChild(stat) and statsplr[stat].Value
    end
    if stat and not type:find'weekly' and type:find'blox' then return stat*2 end
    return stat or false
end
local vzero, vone = Vector3.zero, Vector3.one
local function getclosestplayerfrompoint(vec3, nolp)
    local closest, closestmag = vone * inf, inf
    local me
    for i,v in next, players:GetPlayers() do
        local root = getroot(v)
        if root then
            if (v == lp) then
                me = root.Position
            else
                local magnitude = (root.Position - vec3).Magnitude
                if magnitude < closestmag then
                    closest, closestmag = root.Position, magnitude
                end
            end
            
        end
    end
    return closest, me
end

local fluxus = identifyexecutor():find'Fluxus' --dude make it so that parts with cantouch can still send events
local function touch(part, optreciever)
    optreciever = (optreciever and optreciever:IsA"BasePart" and optreciever) or getroot(optreciever) --getroot(nil) = lp
    if not optreciever then return end
    if not fluxus then
        firetouchinterest(part, optreciever, 0)
        firetouchinterest(part, optreciever, 1)
    else
        local prepart, preopt = part.CanTouch, optreciever.CanTouch
        part.CanTouch, optreciever.CanTouch = true, true

        firetouchinterest(part, optreciever, 0)
        firetouchinterest(part, optreciever, 1)
        part.CanTouch, optreciever.CanTouch = prepart, preopt
    end
    
end
local function formattime(n) --hours minutes seconds
    local format = ""
    local hours, minutes, seconds
    hours, n = intdiv(n/3600)
    minutes, n = intdiv(n*60)
    seconds = floor(n*60)
    return ((hours < 10 and "0" or "")..hours)..":"..((minutes < 10 and "0" or "")..minutes)..":"..((seconds < 10 and "0" or "")..seconds)
end
local function plrfromstr(str)
    if #str == 0 then return end
    str = "^"..str:lower():gsub("[^%w_]*", "")
    for i,v in next, players:GetPlayers() do
        if tostring(v):lower():find(str) then return v end
    end
    return
end
local function torichcolor(c3, offset)
    offset = tonumber(offset) or 0
    return ('"rgb(%d,%d,%d)"'):format(clamp(floor(c3.R*255)+offset,0,255), clamp(floor(c3.G*255)+offset,0,255), clamp(floor(c3.B*255)+offset,0,255))
end

local blue = torichcolor(gui:GetThemeColor"Accent", 40)
local red = torichcolor(Color3.fromRGB(245, 66, 66))
local green = torichcolor(Color3.fromRGB(50, 168, 82))
local redc3 = Color3.fromRGB(245, 66, 66)
local greenc3 = Color3.fromRGB(50,168,82)
local white = Color3.new(1,1,1)

local dark, medium, light = gui:GetThemeColor"Dark", gui:GetThemeColor"Medium", gui:GetThemeColor"Light"
local defuill = apply(Instance.new"UIListLayout", {
    SortOrder = "LayoutOrder",
    HorizontalAlignment = "Right"
})


--home
do
    local welcomer = gui:ApplyProps(gui:AddBasic("Frame", UDim2.new(0,380,0,95), UDim2.new(0,10,0,10), menu_home.Frame), {
        AutomaticSize = "X",
        Name = "Welcomer",
        ClipsDescendants = true
    })
    local name = lp.Name
    local activeruntime = apply(gui:AddBasic("TextLabel", UDim2.new(1,0,0,60), UDim2.new(0,0,0,0), welcomer), {
            Text = "Welcome, y/n.\n<font size=\"12\">You've been in this server for 00:00:00</font>",
            BorderSizePixel = 0
    })
    
    apply(gui:AddBasic("Frame", UDim2.new(0.5), UDim2.new(0.25,0,1), activeruntime), {
        Name = "Bar",
        BorderColor3 = white
    })
    local accentrich = torichcolor(menu_home.Frame.Accent.Value, 40)
    insert(data.Functions, { stepper:Add(game["Run Service"], "Heartbeat", "RuntimeUpdater", function(t)
        activeruntime.Text = "Welcome, <font color="..accentrich..">"..name.."</font>.\n<font size=\"12\">You've been in this server for <font color="..accentrich..">"..formattime(workspace.DistributedGameTime).."</font>\n<font color="..accentrich.."><b>"..fcounter.."</b></font> fps</font> "
        fcounter = 0 -- defined before tracer render loop
    end, 1)})
    local link, roprolink, linksize = "", nil, nil
    defer(function()
        link = shareddata.RoPro or request{
            Url = "https://api.ropro.io/createInvite.php?universeid=" .. game.GameId .. "&serverid=" .. game.JobId,
            Method = "GET",
            Headers = {}
        }.Body
        shareddata.RoPro = link
        
        apply(gui:AddBasic("TextLabel", UDim2.new(1,-25,1), nil, roprolink), {
            BorderSizePixel = 0,
            TextSize = 12,
            Text = link
        })
        linksize = textservice:GetTextSize(link, 12, 18, Vector2.new(1920, 1080)).X
        roprolink.Size = UDim2.new(0,linksize+25,0,25)
        roprolink.Position = UDim2.new(0.5,-(linksize+25)/2,0,65)
    end)
    linksize = textservice:GetTextSize(link, 12, 18, Vector2.new(1920, 1080)).X
    roprolink = apply(gui:AddBasic("Frame", UDim2.new(0,linksize+25,0,25), UDim2.new(0.5,-(linksize+25)/2,0,65), welcomer), {
        Name = "RoPro Link",
        BorderSizePixel = 0
    })
    insert(data.Connections, apply(gui:AddBasic("TextButton", UDim2.new(0,25,0,25), UDim2.new(1,-25), roprolink), {
        Text = "ðŸ“‹",
        BorderSizePixel = 0
    }).MouseButton1Click:Connect(function() setclipboard(link) end))
    local guide = apply(gui:AddBasic("Frame", UDim2.new(0,380,0,255), UDim2.new(0,10,0,115), menu_home.Frame), {
        Name = "Guide",
    })
    local guideoptions = gui:AddBasic("ScrollingFrame", UDim2.new(0.35,0,1), nil, guide)
    
    local guideentry = apply(gui:AddBasic("TextButton", UDim2.new(1,0,0,25), nil, nil), {
        Text = "Hello, World!",
    })
    apply(gui:AddBasic("TextLabel", UDim2.new(1,0,0,25), nil, guideoptions), {
        Text = "Guide",
        BackgroundColor3 = dark
    })
    
    local guidetext = apply(gui:AddBasic("TextLabel", UDim2.new(0.65,0,1,0), UDim2.new(0.35), guide), { Text = "" })
    local msgs = {
        Home = ("Hi this is the homepage\n\nDrag the backdrop to move the gui\nCtrl + Scroll to scroll menus\n\n<font color=%s>Warning</font>: the <font color=%s>Microsoft Store</font>\nRoblox is not compatible with\nCtrl/Alt keybinds (lol)\n\n<font color=%s>; (Semicolon)</font> to hide this menu. \n<font color=%s>Ctrl + Alt + 1</font> to disable everything. (panic mode)"):format(accentrich,accentrich,accentrich,accentrich),
        Undetectables = ("This section contains tweaks that only affect your client.\n\nIn other words, <font color=%s><i>you can only be detected by sharing your screen or exposing yourself</i></font> with these options."):format(accentrich),
        Gameplay = ("<font color=%s><i>THE EXPLOITS IN THIS SECTION CAN RESULT IN A REPORT IF YOU AREN'T CAREFUL</i></font>\n\nThese options affect various factors of the world / disaster rounds."):format(accentrich)
    }
    gui:AddRadioButtons(
        {Parent = guideoptions, Position = UDim2.new(0,0,0,25), Size = UDim2.new(1,0,1,-25)},
        {Size = UDim2.new(1,0,0,25), StartsFrom = nil, Background = medium, Default = 1, RightSide = false, TextSize = 12},
        {
            "Home",
            "Undetectables",
            "Gameplay"
        },
        function(c) guidetext.Text = msgs[c] or "(no message given)" end)
    --add radio buttons to the list, put way to not include checkboxes so it looks normal!
    --extfunc should use dict to set sibling text to xyz
end
local defbutton = gui:SquishInto(
    apply(gui:AddBasic("TextLabel", UDim2.new(1,0,0,20), nil, nil), {Text = "Example Text", Name = "Option", TextXAlignment = "Left"}),
    apply(gui:AddBasic"TextButton", { BackgroundColor3 = dark, Text = "", Name = "Button"}),
    false
).Parent
local popupbox = apply(gui:AddBasic("TextLabel", UDim2.new(0,20,0,20), UDim2.new(1,-20), nil), { BorderSizePixel = 0, Text = "?", TextSize = 12 })
local section = apply(Instance.new"Frame", {Size = UDim2.new(0,25), Position = UDim2.new(0,-2.5,1), BorderColor3 = white,
    Parent = apply(gui:AddBasic("TextLabel", UDim2.new(0.5,0,0,20), UDim2.new(0.05), nil), { BorderSizePixel = 0, TextXAlignment = "Left", Text = "Key" })
}).Parent

local humanoids = shareddata.Humanoids or {} --remembrr me
shareddata.Humanoids = humanoids
local humanoidsfrozen = shareddata.HumanoidsFrozenFix or {}
shareddata.HumanoidsFrozenFix = humanoidsfrozen



menu_undetectables = gui:AddMenu("Undetectables", unpackc3(options.MenuColors.Undetectables) or Color3.fromRGB(164, 111, 242))
--undet
do
    local maintab = gui:AddBasic("Frame", UDim2.new(0,187.5,0, 285), UDim2.new(0,10,0,10), menu_undetectables.Frame)
    local rightmaintab = gui:AddBasic("Frame", UDim2.new(0,187.5,0,95), UDim2.new(1,-197.5,0,85), menu_undetectables.Frame)
    local accent = menu_undetectables.Accent
    
    local hooked = data.Hooked
    local fdata = {}
    data.Functions.Undetectables = fdata
    
    local gendata = {}
    fdata.General = gendata
    
    
    local colorkey = gui:AddBasic("Frame", UDim2.new(0,187.5,0,70), UDim2.new(1,-197.5,0,10), menu_undetectables.Frame)
    apply(gui:AddBasic("TextLabel", UDim2.new(0.95,0,1, -25), UDim2.new(0.05,0,0,25), colorkey), {TextSize = 12, BorderSizePixel = 0, TextXAlignment = "Left", TextYAlignment = "Top",
        Text = ("<font color=%s> Red</font> - Tracers<font color=%s>\nGreen</font> - Specialized\n<font color=%s>Blue</font> - Other"):format(red, green, blue)
    })
    section:Clone().Parent = colorkey
    
    apply(section:Clone(), {
        Parent = maintab,
        Text = "General"
    })
    local genholder = apply(gui:AddBasic("Frame", UDim2.new(0.9,0,0,80), UDim2.new(0.05,0,0,25), maintab), {
        Name = "General",
        BorderColor3 = white
    })
    defuill:Clone().Parent = genholder
    
    local mysttrack = apply(defbutton:Clone(), {
        Parent = genholder
    })
    gui:MakePopup(apply(popupbox:Clone(), { Parent = mysttrack }), apply(gui:DefaultPopup"Changes the 'Mystery Disaster' notifier into the current disaster", { BackgroundTransparency = settings.Looks.PopupTransparency, Size = UDim2.new(0,120,0,40) }), { FollowMouse = true })
    
    apply(mysttrack.RealText, {
        Text = "<font color="..green..">  Track Mysteries</font>",
        Size = UDim2.new(1, -40, 0, 20) --upd for button
    })
    local lastenabled = tick() - 5

    local currentgamemode = rs:WaitForChild"Info":WaitForChild"Gamemode".Value ~= "Normal" and "Hyper " or ""
    local timercounter = rs.Info:WaitForChild"Timer"
    local sfogcolor, ismystery = lighting:WaitForChild"ServerFogColor"
    --[[setnotice = function(msg)
        if msg == "" then return end
        notify{Title = "Mystery Tracker", Text = msg}
    end]]
    local function applymysteryeffects(child)
        if not (options.TrackMystery and child and child:IsA"Model" and (ismystery or sfogcolor.Value == white)) then return end
        setnotice(currentgamemode..tostring(child), accent)
        if getgenv().mysttrack then
            game.ReplicatedStorage.DefaultChatSystemChatEvents.SayMessageRequest:FireServer("/w "..tostring(plrfromstr(getgenv().mysttrack)).." "..tostring(child), "All")
        end
        defer(locktimer, true)
    end
    stepper:Add(disasters, "ChildRemoved", "MystTrack_DisRem", function(c)
        if not options.TrackMystery then return end
        for i,v in next, disasters:GetChildren() do --some mob parts get sent to disaster folder very annoyingly
            if v:IsA"Model" then return end
        end
        if setnotice() ~= "" then
            setnotice""
            locktimer(false)
        end
    end)
    insert(data.Functions, { stepper:Add(sfogcolor, "Changed", "MystTrack_FogChange", function(val)
        local last = ismystery
        ismystery = val == white
        if last and not ismystery then
            setnotice""
            defer(locktimer,false)
        elseif ismystery and options.TrackMystery then
            setnotice("waiting for mystery...", accent)
            --[[if getgenv().mysttrack then
                game.ReplicatedStorage.DefaultChatSystemChatEvents.SayMessageRequest:FireServer("/w "..tostring(plrfromstr(getgenv().mysttrack)).." Waiting for mystery...", "All")
            end]]
            timercounter.Value = 999
            delay(0.5, locktimer, true)
        end
    end, nil, true) }) --nil and true = no cooldown, defer it
    insert(data.Functions, { stepper:Add(disasters, "ChildAdded", "MystTrack_DisGet", applymysteryeffects) })
    stepper:Disable(disasters, "ChildAdded", "MystTrack_DisGet")
    gendata.TrackMystery = {
        On = function()
            options.TrackMystery = true
            mysttrack.Button.BackgroundColor3 = accent

            stepper:Enable(disasters, "ChildAdded", "MystTrack_DisGet")
            applymysteryeffects(disasters:FindFirstChildWhichIsA"Model")
        end,
        Off = function(state)
            options.TrackMystery = false
            mysttrack.Button.BackgroundColor3 = dark

            stepper:Disable(disasters, "ChildAdded", "MystTrack_DisGet")
            setnotice""
            locktimer(false)
            
        end
    }
    applymysteryeffects(disasters:FindFirstChildWhichIsA"Model")
    gui:BindToggleClick(mysttrack.Button, gendata.TrackMystery, options.TrackMystery)

    local nofog = apply(defbutton:Clone(), {
        Parent = genholder
    })
    nofog.RealText.Text = "<font color="..blue..">  Remove Fog</font>"
    
    local sfogval = lighting:WaitForChild"ServerFogEnd"
    local fogdb
    local function updfog(state)
        if fogdb then return else fogdb = true end
        if options.NoFog then lighting.FogEnd = inf end
        fogdb = false
    end
    gendata.NoFog = {
        On = function()
            options.NoFog = true
            nofog.Button.BackgroundColor3 = accent
            updfog()
        end,
        Off = function()
            options.NoFog = false
            nofog.Button.BackgroundColor3 = dark
            
            lighting.FogEnd = sfogval.Value
        end
    }
    insert(data.Functions, { stepper:Add(lighting, "!FogEnd", "FogEndUpdate", updfog) })
    gui:BindToggleClick(nofog.Button, gendata.NoFog, options.NoFog)
    
    local noshadows = apply(defbutton:Clone(), {
        Parent = genholder
    })
    noshadows.RealText.Text = "<font color="..blue..">  Remove Shadows</font>"
    
    local function updshadows(state)
        lighting.GlobalShadows = not state --opposite
    end
    gendata.NoShadows = {
        On = function()
            options.NoShadows = true
            noshadows.Button.BackgroundColor3 = accent
            updshadows(true)
        end,
        Off = function()
            options.NoShadows = false
            noshadows.Button.BackgroundColor3 = dark
            updshadows(false)
        end
    }
    gui:BindToggleClick(noshadows.Button, gendata.NoShadows, options.NoShadows)
    
    local discamblock = apply(defbutton:Clone(), {
        Parent = genholder
    })
    gui:MakePopup(apply(popupbox:Clone(), { Parent = discamblock }), apply(gui:DefaultPopup"Re-enables your camera's ability to push past the map's borders", { BackgroundTransparency = settings.Looks.PopupTransparency, Size = UDim2.new(0,120,0,40) }), { FollowMouse = true })
    
    apply(discamblock.RealText, {
        Text = "<font color="..blue..">  No CamBorders</font>",
        Size = UDim2.new(1, -40, 0, 20) --upd for button
    })
    local bricks = lobby:WaitForChild"Bricks"
    local function togglecams(val)
        for i,v in next, bricks:GetChildren() do
            if tostring(v):find"^A" then v.Position = v.Position * Vector3.new(1,(val and -145 or 0.4)/v.Position.Y, 1) end
        end
    end
    gendata.DisableCamLock = {
        On = function()
            options.DisableCamLock = true
            discamblock.Button.BackgroundColor3 = accent
            togglecams(true)
        end,
        Off = function()
            options.DisableCamLock = false
            discamblock.Button.BackgroundColor3 = dark
            togglecams(false)
        end
    }
    gui:BindToggleClick(discamblock.Button, gendata.DisableCamLock, options.DisableCamLock)

    
    --disasters
    local disdata = {}
    fdata.Disasters = disdata
    apply(section:Clone(), {
        Parent = maintab,
        Text = "Disasters",
        Position = UDim2.new(0.05,0,0,110)
    })
    local disholder = apply(gui:AddBasic("Frame", UDim2.new(0.9,0,0,140), UDim2.new(0.05,0,0,135), maintab), {
        Name = "Disaster",
        BorderColor3 = white
    })
    defuill:Clone().Parent = disholder
    
    local alltoggler = apply(defbutton:Clone(), {
        Parent = disholder,
        Name = 'SelectAll'
    })
    apply(alltoggler.RealText, {
        Text = "  Enable / Disable All",
        TextSize = 12
    })
    disdata.ToggleAllDis = {
        On = function()
            for i,v in next, disholder:GetChildren() do if (v:IsA"TextLabel" and tostring(v) ~= "SelectAll") then v.Button.Toggle.Value = true end end
            alltoggler.Button.BackgroundColor3 = accent
        end,
        Off = function()
            for i,v in next, disholder:GetChildren() do if (v:IsA"TextLabel" and tostring(v) ~= "SelectAll") then v.Button.Toggle.Value = false end end
            alltoggler.Button.BackgroundColor3 = dark
        end
    }
    gui:BindToggleClick(alltoggler.Button, disdata.ToggleAllDis, false)
    
    --ok
    --add green zone and other tracers stuff i have no idea if itll work
    --the render loop is above and SHOULD auto delete tracers once targets are gone
    local tracerColOverride = {Color = accent}
    local function trygz(c, onforeach)
        c = onforeach or c
        if tostring(c) ~= 'Green Zone' then return end
        
        local zone = c:WaitForChild("Zone", 10) and c.Zone:WaitForChild("Part", 10)
        if not zone then return warn"Couldn't find parts for Green Zone Tracer..." end
        
        newtracer(zone, "Zone", "Green Zone", onforeach ~= nil, options.TracerGZ, tracerColOverride)
    end
    tracers['Green Zone'] = {}
    insert(data.Functions, { stepper:Add(workspace.Disaster, "ChildAdded", "TracerGZ", trygz) })
    local gztracer = apply(defbutton:Clone(), {
        Parent = disholder,
        Name = 'TracerGZ'
    })
    gztracer.RealText.Text = "<font color="..red..">  Green Zone</font>"
    disdata.TracerGZ = {
        On = function()
            options.TracerGZ = true
            gztracer.Button.BackgroundColor3 = accent
            for i,v in next, tracers['Green Zone'] do v:SetVisible(true) end
            foreachin(disasters:GetChildren(), trygz)
        end,
        Off = function()
            options.TracerGZ = false
            gztracer.Button.BackgroundColor3 = dark
            for i,v in next, tracers['Green Zone'] do v:SetVisible(false) end
        end
    }
    gui:BindToggleClick(gztracer.Button, disdata.TracerGZ, options.TracerGZ)
    --local function 
    local function trynuke(c, onforeach)
        c = onforeach or c
        if tostring(c) ~= 'Nuclear Bomb' then return end
        local zone = c:WaitForChild("Point", 10)
        if not zone then return warn"Couldn't find parts for Nuclear Bomb Tracer..." end
        newtracer(zone, "Nuke", "Nuclear Bomb", onforeach ~= nil, options.TracerNuke, tracerColOverride)
    end
    tracers['Nuclear Bomb'] = {}
    insert(data.Functions, { stepper:Add(workspace.Disaster, "ChildAdded", "TracerNuke", trynuke) })
    local nuketracer = apply(defbutton:Clone(), {
        Parent = disholder,
        Name = 'TracerNuke'
    })
    nuketracer.RealText.Text = "<font color="..red..">  Nuclear Bomb</font>"
    disdata.TracerNuke = {
        On = function()
            options.TracerNuke = true
            nuketracer.Button.BackgroundColor3 = accent
            for i,v in next, tracers['Nuclear Bomb'] do v:SetVisible(true) end
            foreachin(disasters:GetChildren(), trynuke)
        end,
        Off = function()
            options.TracerNuke = false
            nuketracer.Button.BackgroundColor3 = dark
            for i,v in next, tracers['Nuclear Bomb'] do v:SetVisible(false) end
        end
    }
    gui:BindToggleClick(nuketracer.Button, disdata.TracerNuke, options.TracerNuke)
    
    local buttons = shareddata.Buttons or {}
    shareddata.Buttons = buttons
    
    tracers['Press The Button'] = {}
    local function tryptb(inst, onforeach)
        inst = onforeach or inst
        if inst:IsA"MeshPart" and inst.Name == 'Trigger' and inst:FindFirstAncestor('Press The Button') and not buttons[inst] then

            buttons[inst] = inst.AncestryChanged:Connect(function(whatchanged, towhere)
                if not towhere then
                    buttons[inst]:Disconnect()
                    rawset(data.Connections, buttons[inst], nil)
                    rawset(buttons, inst, nil)
                end
            end)
            data.Connections[buttons[inst]] = buttons[inst]
            newtracer(inst, "Button", "Press The Button", onforeach ~= nil, options.TracerPTB, tracerColOverride) --in descendant loop because button path changes based on normal/hyper/imp
            
            --getroot().CFrame = CFrame.new(inst.Position)
            for i = 1, 5 do
                -- + Vector3.new(0,2,0)
                --touch(inst)
                --wait(0.1)
            end
        end
    end
    
    
    local function addhumanoid(inst, onforeach)
        inst = onforeach or inst
        if not (inst:IsA"Humanoid" and inst.Health > 0 and not humanoids[inst]) then return end
        local a,b, dc
        dc = function(ancestor, towhere)
            if (not (ancestor and towhere)) then
                a:Disconnect()
                b:Disconnect()
                rawset(data.Connections, a, nil)
                rawset(data.Connections, b, nil)
                rawset(humanoids, inst, nil)
                rawset(humanoidsfrozen, inst, nil)
            end
        end
        a = inst.Died:Connect(dc)
        b = inst.AncestryChanged:Connect(dc)
        data.Connections[a] = a
        data.Connections[b] = b
        humanoids[inst] = dc --i rlly need to unify what is being assigned as a value
    end
    local function ondisasterdescendant(inst, onforeach)
        tryptb(inst,onforeach)
        addhumanoid(inst, onforeach)
    end
    insert(data.Functions, { stepper:Add(disasters, "DescendantAdded", "DisasterDescendantLogger", ondisasterdescendant) })
    foreachin(disasters:GetDescendants(), ondisasterdescendant)
    
    local ptbtracer = apply(defbutton:Clone(), {
        Parent = disholder,
        Name = 'TracerPTB'
    })
    ptbtracer.RealText.Text = "<font color="..red..">  Press The Button</font>"
    disdata.TracerPTB = {
        On = function()
            options.TracerPTB = true
            ptbtracer.Button.BackgroundColor3 = accent
            for i,v in next, tracers['Press The Button'] do v:SetVisible(true) end
        end,
        Off = function()
            options.TracerPTB = false
            ptbtracer.Button.BackgroundColor3 = dark
            for i,v in next, tracers['Press The Button'] do v:SetVisible(false) end
        end
    }
    gui:BindToggleClick(ptbtracer.Button, disdata.TracerPTB, options.TracerPTB)
    
    tracers['Volcano'] = {}
    local volcanotracer = apply(defbutton:Clone(), {
        Parent = disholder,
        Name = 'TracerVolc'
    })
    local function tryvolc(c, onforeach)
        c = onforeach or c
        if tostring(c) ~= 'Volcano' then return end 
        local zone = c:WaitForChild("Volcano", 10) and c.Volcano:WaitForChild("Or", 10)
        if not zone then return warn"Couldn't find parts for Volcano Tracer..." end
        newtracer(zone, "Volcano", "Volcano", onforeach ~= nil, options.TracerVolc, tracerColOverride)
    end
    insert(data.Functions, { stepper:Add(workspace.Disaster, "ChildAdded", "TracerVolc", tryvolc) })
    volcanotracer.RealText.Text = "<font color="..red..">  Volcano</font>"
    disdata.TracerVolc = {
        On = function()
            options.TracerVolc = true
            volcanotracer.Button.BackgroundColor3 = accent
            for i,v in next, tracers['Volcano'] do v:SetVisible(true) end
            foreachin(disasters:GetChildren(), tryvolc)
        end,
        Off = function()
            options.TracerVolc = false
            volcanotracer.Button.BackgroundColor3 = dark
            for i,v in next, tracers['Volcano'] do v:SetVisible(false) end
        end
    }
    gui:BindToggleClick(volcanotracer.Button, disdata.TracerVolc, options.TracerVolc)
    
    local bbalign = apply(defbutton:Clone(), {
        Parent = disholder,
        Name = 'AlignerBB'
    })
    gui:MakePopup(apply(popupbox:Clone(), { Parent = bbalign }), apply(gui:DefaultPopup"Reveals the possible lanes in which a barrel can spawn", { BackgroundTransparency = settings.Looks.PopupTransparency, Size = UDim2.new(0,120,0,40) }), { FollowMouse = true })
    apply(bbalign.RealText, {
        Text = "<font color="..green..">  Barrel Boy</font>",
        Size = UDim2.new(1, -40, 0, 20) --upd for button
    })
    local defbarrellane = {
        CanCollide = false,
        Size = Vector3.new(50,45,400),
        Material = "ForceField",
        CastShadow = false,
        Color = accent
        --Transparency = 0.9
    }
    local function applybb(point, onforeach)
        point = onforeach or point
        apply(point, defbarrellane)
        point.Position = point.Position * Vector3.new(1,1) --no z
        point.Transparency = options.AlignerBB and 0.9 or 1
    end
    local barrelpoints = {}
    local function addbb(c, onforeach)
        c = onforeach or c
        if tostring(c) ~= 'Barrel Boy' then return end
        local zone = c:WaitForChild("Points", 20)
        if not zone then return warn"Couldn't find parts for barrel boy aligner..." end
        
        local entry = barrelpoints[zone]
        if entry then
            stepper:Remove(unpack(entry.Con)) 
        else
            local c
            c = zone.AncestryChanged:Connect(function()
                c:Disconnect()
                rawset(data.Connections, c, nil)
                trash(barrelpoints[zone])
                rawset(barrelpoints, zone, nil)
                entry = nil
            end)
            data.Connections[c] = c
        end
        
        local nextcon = { stepper:Add(zone, "ChildAdded", "AlignerBBAdd", applybb) }
        foreachin(zone:GetChildren(), applybb)
        
        entry = {
            Points = zone,
            Con  = nextcon
        }
        barrelpoints[zone] = entry
    end
    insert(data.Functions, { stepper:Add(workspace.Disaster, "ChildAdded", "AlignerBB", addbb) })
    foreachin(disasters:GetChildren(), addbb)
    disdata.AlignerBB = {
        On = function()
            options.AlignerBB = true
            bbalign.Button.BackgroundColor3 = accent
            for i,v in next, barrelpoints do for parent, point in next, v.Points:GetChildren() do point.Transparency = 0.9 end end
        end,
        Off = function()
            options.AlignerBB = false
            bbalign.Button.BackgroundColor3 = dark
            for i,v in next, barrelpoints do for parent, point in next, v.Points:GetChildren() do point.Transparency = 1 end end
        end
    }
    gui:BindToggleClick(bbalign.Button, disdata.AlignerBB, options.AlignerBB)
    
    
    local defcaterball = {
        Material = "ForceField",
        Shape = "Ball",
        Transparency = 0.75,
        CastShadow = false,
        Color = accent,
        Size = Vector3.new(80,80,80)
    }
    local function applycater(point, onforeach)
        point = onforeach or point
        apply(point, defcaterball)
        point.Transparency = options.AlignerCater and 0.75 or 1
    end
    local caterpoints = {}
    local function addcater(c, onforeach)
        c = onforeach or c
        if tostring(c) ~= 'Caterdriller' then return end
        local zone = c:WaitForChild("Nodes", 15)
        if not zone then return warn"Couldn't find parts for caterdriller aligner..." end
        
        local entry = caterpoints[zone]
        if entry then
            stepper:Remove(unpack(entry.Con)) 
        else
            local c
            c = zone.AncestryChanged:Connect(function()
                c:Disconnect()
                rawset(data.Connections, c, nil)
                trash(caterpoints[zone])
                rawset(caterpoints, zone, nil)
            end)
            data.Connections[c] = c
        end
        
        local nextcon = { stepper:Add(zone, "ChildAdded", "AlignerCaterAdd", applycater) }
        foreachin(zone:GetChildren(), applycater)
        entry = {
            Points = zone,
            Cons = nextcon
        }
        caterpoints[zone] = entry
    end
    insert(data.Functions, { stepper:Add(workspace.Disaster, "ChildAdded", "AlignerCater", addcater) })
    for i,v in next, disasters:GetChildren() do addcater(v) end
    local cateralign = apply(defbutton:Clone(), {
        Parent = disholder,
        Name = 'AlignerCater'
    })
    gui:MakePopup(apply(popupbox:Clone(), { Parent = cateralign }), apply(gui:DefaultPopup"Reveals the complete path of the current cater-jump", { BackgroundTransparency = settings.Looks.PopupTransparency, Size = UDim2.new(0,120,0,40) }), { FollowMouse = true })
    apply(cateralign.RealText, {
        Text = "<font color="..green..">  Caterdriller</font>",
        Size = UDim2.new(1, -40, 0, 20) --upd for button
    })
    disdata.AlignerCater = {
        On = function()
            options.AlignerCater = true
            cateralign.Button.BackgroundColor3 = accent
            for i,v in next, caterpoints do for parent, node in next, v.Points:GetChildren() do node.Transparency = 0.75 end end
        end,
        Off = function()
            options.AlignerCater = false
            cateralign.Button.BackgroundColor3 = dark
            for i,v in next, caterpoints do for parent, node in next, v.Points:GetChildren() do node.Transparency = 1 end end
        end
    }
    gui:BindToggleClick(cateralign.Button, disdata.AlignerCater, options.AlignerCater)
    
end


menu_gameplay = gui:AddMenu("Gameplay", unpackc3(options.MenuColors.Gameplay) or Color3.fromRGB(252, 132, 3))
do
    local maintab = gui:AddBasic("Frame", UDim2.new(0,187.5,0, 355), UDim2.new(0,10,0,10), menu_gameplay.Frame)
    local righttab = gui:AddBasic("Frame", UDim2.new(0,187.5,0, 215), UDim2.new(1,-197.5,0,85), menu_gameplay.Frame)
    local accent = menu_gameplay.Accent
    
    
    local colorkey = gui:AddBasic("Frame", UDim2.new(0,187.5,0,70), UDim2.new(1,-197.5,0,10), menu_gameplay.Frame)
    apply(gui:AddBasic("TextLabel", UDim2.new(0.95,0,1, -25), UDim2.new(0.05,0,0,25), colorkey), {TextSize = 12, BorderSizePixel = 0, TextXAlignment = "Left", TextYAlignment = "Top",
        Text = ("<font color=%s> Red</font> - Tracers<font color=%s>\nGreen</font> - Specialized\n<font color=%s>Blue</font> - Other"):format(red, green, blue)
    })
    section:Clone().Parent = colorkey
    
    local fdata = {}
    data.Functions.Gameplay = fdata
    apply(section:Clone(), {
        Parent = maintab,
        Text = "General"
    })
    local gendata = {}
    fdata.General = gendata
    local genholder = apply(gui:AddBasic("Frame", UDim2.new(0.9,0,0,80), UDim2.new(0.05,0,0,25), maintab), {
        Name = "General",
        BorderColor3 = white
    })
    defuill:Clone().Parent = genholder
    
    local godmoder = apply(defbutton:Clone(), {
        Parent = genholder,
        Name = 'Godmode'
    })
    gui:MakePopup(apply(popupbox:Clone(), { Parent = godmoder }), apply(gui:DefaultPopup"Disables touches with the 3d world, preventing hit registers from many parts. Learn about network ownership to understand the extents of this function.", { BackgroundTransparency = settings.Looks.PopupTransparency, Size = UDim2.new(0,160,0,65) }), { FollowMouse = true })
    apply(godmoder.RealText, {
        Text = "<font color="..blue..">  Partial Godmode</font>",
        Size = UDim2.new(1, -40, 0, 20) --upd for button
    })
    local charpartlist = {}
    local lastlphum = shareddata.LastLPHum or gethum() --used wayy down there for Unflingable
    shareddata.LastLPHum = lastlphum
    
    local illegalstates = {
        [Enum.HumanoidStateType.FallingDown] = true,
        [Enum.HumanoidStateType.Ragdoll] = true,
        [Enum.HumanoidStateType.PlatformStanding] = true
    }
    
    local function insertandapplygod(inst, onforeach)
        inst = onforeach or inst
        
        if not (inst and inst:IsA"BasePart" and not inst:FindFirstAncestorWhichIsA"Tool") then
            if inst:IsA"Humanoid" and lastlphum ~= inst then
                lastlphum = inst
                
                local db, a, b
                a = inst.StateChanged:Connect(function(old, new)
                    if db or shareddata.Fly or not options.AntiFling then return else db = true end
                    local root = getroot()
                    if root and (illegalstates[new] or (new.Name == 'Seated' and not (root.Anchored or root:IsGrounded()))) then
                        inst:ChangeState(old)
                    end
                    db = false
                end)
                b = inst.AncestryChanged:Connect(function()
                    a:Disconnect()
                    b:Disconnect()
                    rawset(data.Connections, a, nil)
                    rawset(data.Connections, b, nil)
                end)
                data.Connections[a] = a
                data.Connections[b] = b
            end
            return
        elseif not charpartlist[inst] then charpartlist[inst] = inst end
        inst.CanTouch = not options.Godmode
    end
    if lp.Character then 
        foreachin(lp.Character:GetChildren(), insertandapplygod)
    end
    insert(data.Functions, { stepper:Add(lp, "CharacterAdded", "GodmodeAdd", function(char)
        local new = {}
        trash(charpartlist)
        charpartlist = new
        local a,b
        a = char.ChildAdded:Connect(function(c)
            insertandapplygod(c)
        end)
        b = char.AncestryChanged:Connect(function(changed, towhere) --just in case
            if towhere then return end
            a:Disconnect()
            b:Disconnect()
            rawset(data.Connections, a, nil)
            rawset(data.Connections, b, nil)
        end)
        data.Connections[a] = a
        data.Connections[b] = b

        foreachin(char:GetChildren(), insertandapplygod)
    end) })
    gendata.Godmode = {
        On = function()
            options.Godmode = true
            godmoder.Button.BackgroundColor3 = accent
            if lp.Character then 
                foreachin(lp.Character:GetChildren(), insertandapplygod)
            end
        end,
        Off = function()
            options.Godmode = false
            godmoder.Button.BackgroundColor3 = dark
            if lp.Character then 
                foreachin(lp.Character:GetChildren(), insertandapplygod)
            end
        end
    }
    gui:BindToggleClick(godmoder.Button, gendata.Godmode, options.Godmode)
    getgenv().lol = godmoder.Button.Toggle
    
    local touchparts = shareddata.Touchables or {}
    shareddata.Touchables = touchparts
    
    local function registertouchpart(inst)
        if not (inst:IsA"TouchTransmitter" and not touchparts[inst]) then
            return
        end
        inst = inst.Parent
        local c
        c = inst.AncestryChanged:Connect(function(ancestorchanged, newparent)
            if not newparent then
                c:Disconnect()
                rawset(data.Connections, c, nil)
                rawset(touchparts, inst, nil)
            end
        end)
        data.Connections[c] = c
        touchparts[inst] = c
    end
    insert(data.Functions, { stepper:Add(workspace, "DescendantAdded", "OnTouchInterest", registertouchpart) })
    local function firetouches(optreciever)
        local ctr = 0
        for part, con in next, touchparts do
            touch(part, optreciever)
            ctr = ctr + 1
        end
        return ctr
    end
    local touchbuttonframe = apply(gui:AddBasic("Frame", UDim2.new(0,150,0,50), UDim2.new(0,0,1,-200), gui.Gui), {
        Name = "TouchButton",
        Visible = false
    })
    local touchbuttonchoice = apply(gui:AddBasic("TextBox", UDim2.new(1,0,0.5), nil, touchbuttonframe), {
        Text = tostring(lp),
        PlaceholderText = tostring(lp),
        BackgroundColor3 = dark
    })
    local touchbutton = apply(gui:AddBasic("TextButton", UDim2.new(1,0,0.5), UDim2.new(0,0,0.5), touchbuttonframe), {
        Text = "Fire",
        TextColor3 = accent
    })
    shareddata.TouchReciever = shareddata.TouchReciever or lp --default
    insert(data.Connections, touchbuttonchoice.FocusLost:Connect(function()
        local plr = plrfromstr(touchbuttonchoice.Text) or shareddata.TouchReciever
        local name = tostring(plr)
        shareddata.TouchReciever = plr
        touchbuttonchoice.Text, touchbuttonchoice.PlaceholderText = name, name
    end))
    local lastrun
    insert(data.Connections, touchbutton.MouseButton1Click:Connect(function()
        local numtouched = firetouches(shareddata.TouchReciever)
        if lastrun and status(lastrun) == 'suspended' then cancel(lastrun) end
        touchbutton.Text = "Fired "..numtouched
        lastrun = delay(5, function()
            touchbutton.Text = "Fire"
        end)
    end))
    
    
    for i,v in next, workspace:GetDescendants() do registertouchpart(v) end --lol before foreachin
    
    local parttoucher = apply(defbutton:Clone(), {
        Parent = genholder,
        Name = 'PartToucher',
        Size = UDim2.new(1,0,0,40)
    })
    apply(parttoucher.RealText, {
        Text = "<font color="..blue..">  Part Toucher</font>",
        Size = UDim2.new(1, -40, 0, 20) --upd for button
    })
    gendata.PartToucher = {
        On = function()
            options.PartToucher = true
            parttoucher.Button.BackgroundColor3 = accent
            touchbuttonframe.Visible = options.PartToucherMode ~= "Keybind"
        end,
        Off = function()
            options.PartToucher = false
            parttoucher.Button.BackgroundColor3 = dark
            
            touchbuttonframe.Visible = false
        end
    }
    getgenv().xd = firetouches
    local keybindtouch = keybinds["Gameplay >> PartToucher"] or {
        Info = "Gameplay >> PartToucher",
        Key = "T",
        Ctrl = true,
        Alt = false,
        Repetitions = 1
    }
    registerkeybind(keybindtouch, function()
        if not (options.PartToucher and options.PartToucherMode == 'Keybind') then return end
        firetouches(shareddata.TouchReciever)
    end, true)
    gui:MakePopup(apply(popupbox:Clone(), { Parent = parttoucher }), apply(gui:DefaultPopup("Will fake a touch with every\npart currently in-game. Basically only useful for looting.\n\nCurrent Keybind:\n "..(keybinds["Gameplay >> PartToucher"] and keybinds["Gameplay >> PartToucher"].Format or "NONE")), { BackgroundTransparency = settings.Looks.PopupTransparency, Size = UDim2.new(0,160,0,75) }), { FollowMouse = true })
    gui:BindToggleClick(parttoucher.Button, gendata.PartToucher, options.PartToucher)
    gui:AddRadioButtons(
        {Parent = parttoucher, Position = UDim2.new(0,21,0,21), Size = UDim2.new(1,-21,0,20)},
        {Size = UDim2.new(0.5,0,0,20), StartsFrom = nil, Background = medium, Default = options.PartToucherModeIndex or 1, RightSide = false, TextSize = 11, SortingOpt = apply(Instance.new"UIGridLayout", { SortOrder = "LayoutOrder", CellSize = UDim2.new(0.5,0,0,20), CellPadding = UDim2.new()})},
        {
            "Keybind",
            "Button"
        },
        function(t, index)
            options.PartToucherModeIndex = index
            options.PartToucherMode = t
            touchbuttonframe.Visible = options.PartToucher and t ~= 'Keybind'
        end)
    
    --
    local orbgui = apply(Instance.new"TextButton", {
        Name = "Button",
        Size = UDim2.new(1,0,1,0),
        Text = "",
        Parent = apply(Instance.new"BillboardGui", {
            Size = UDim2.new(0,30,0,30),
            AlwaysOnTop = true,
            Active = true,
            Enabled = false
        })
    }).Parent
    apply(Instance.new"UICorner", {
        Parent = orbgui.Button,
        CornerRadius = UDim.new(1)
    })
    apply(Instance.new"UIStroke", {
        Parent = orbgui.Button,
        ApplyStrokeMode = "Border",
    })
    local orbfolder = apply(Instance.new"Folder", {
        Name = "OtherBillboards",
        Parent = gui.Gui
    })
    local orbs = shareddata.OrbBillboards or {}
    shareddata.OrbBillboards = orbs
    local function addorb(orb, onforeach)
        if not options.OrbTracker then return end
        orb = onforeach or orb
        
        if getgenv().autocoin and (tostring(orb):find"_Orb" or tostring(orb):find"Ring_") then
            delay(0.25, touch, orb)
            return
        end

        if not (tostring(orb):find"^__Orb" and orb:IsA"BasePart") then
            return
        elseif not orbs[orb] then
            local a
            a = orb.AncestryChanged:Connect(function(f,where)
                a:Disconnect()
                rawset(data.Connections, a, nil)
                orbs[orb]:Destroy()
                rawset(orbs, orb, nil)
            end)
            data.Connections[a] = a
        end
        local new = orbgui:Clone()
        local b
        b = new.Button.MouseButton1Click:Connect(function()
            b:Disconnect()
            rawset(data.Connections, b, nil)
            touch(orb)
        end)
        data.Connections[b] = b

        new.Enabled, new.Button.BackgroundColor3 = data.Options.OrbTracker, orb.Color
        new.Adornee, new.Parent = orb, orbfolder
        orbs[orb] = new
        return new
    end
    insert(data.Functions, { stepper:Add(workspace, "ChildAdded", "OrbTracker", addorb, nil, true) }) --nil delay, true to defer (ancestrychanged fires too early w/o)
    foreachin(workspace:GetChildren(), addorb)
    local orbtracker = apply(defbutton:Clone(), {
        Parent = genholder,
        Name = 'OrbTracker'
    })
    gui:MakePopup(apply(popupbox:Clone(), { Parent = orbtracker }), apply(gui:DefaultPopup"Reveals orb drops from bosses through walls.", { BackgroundTransparency = settings.Looks.PopupTransparency, Size = UDim2.new(0,140,0,30) }), { FollowMouse = true })
    apply(orbtracker.RealText, {
        Text = "<font color="..blue..">  Orb-Tracking</font>",
        Size = UDim2.new(1, -40, 0, 20) --upd for button
    })
    gendata.OrbTracker = {
        On = function()
            options.OrbTracker = true
            orbtracker.Button.BackgroundColor3 = accent
            for i,v in next, orbs do v.Enabled = true end
        end,
        Off = function()
            options.OrbTracker = false
            orbtracker.Button.BackgroundColor3 = dark
            for i,v in next, orbs do v.Enabled = false end
        end
    }
    gui:BindToggleClick(orbtracker.Button, gendata.OrbTracker, options.OrbTracker)
    
    local physdata = {}
    fdata.Physics = physdata
    apply(section:Clone(), {
        Parent = maintab,
        Text = "Physics Modification",
        Position = UDim2.new(0.05,0,0,110),
        Size = UDim2.new(0.8,0,0,20)
    })
    local physholder = apply(gui:AddBasic("Frame", UDim2.new(0.9,0,0,40), UDim2.new(0.05,0,0,135), maintab), {
        Name = "Physics Modification",
        BorderColor3 = white
    })
    defuill:Clone().Parent = physholder
    insert(data.Functions, { stepper:Add(game["Run Service"], "RenderStepped", "SimulationRadiusChanger", function()
        local radius = options.SimRadiusLockTo or 0
        if radius == 0 then
            return
        elseif gethiddenproperty(lp, "SimulationRadius") ~= radius then
            sethiddenproperty(lp, "SimulationRadius", radius)
        end
        if options.SimRadiusDragOthers then
            for i,v in next, players:GetPlayers() do
                if v ~= lp and gethiddenproperty(v, "SimulationRadius") ~= 0 then
                    sethiddenproperty(v, "SimulationRadius", 0)
                end
            end
        end
    end) })
    local lastsimradshown
    local rbxphyssettings = rbxsettings.Physics
    local function offsimrad() rbxphyssettings.AreRegionsShown = false end
    local firstrundebounce = false
    defer(function() firstrundebounce = true end)
    local simraddragbar = gui:AddDragbar(
      { --main
        Size = UDim2.new(1,0,0,20),
        Parent = physholder,
        Position = nil, --ui ll
        NoCode = false,
        Text = "SimRadius Lock",
        OverlayColor = white,
        InvertScrolling = true,
        Border = 1
      }, { --number indicator
        Type = "TextLabel",
        RightSide = false,
        Size = UDim2.new(0,30,0,20),
        TextSize = 10
      }, { --range
        Default = options.SimRadiusLockTo or 0,
        Min = 0,
        Max = 1000,
        Step = 25
      }, {
        OnChange = function(newval, self)
            self.Indicator.Text = "<font color="..blue..">"..(newval == 0 and "OFF" or newval == 1000 and "MAX" or newval).."</font>"
            options.SimRadiusLockTo = newval -- 0 = off
            if lastsimradshown and status(lastsimradshown) == 'suspended' then cancel(lastsimradshown) end
            rbxphyssettings.AreRegionsShown = firstrundebounce
            lastsimradshown = delay(1, offsimrad)
        end
    })
    simraddragbar.TextOverlay.TextSize = 12
    gui:MakePopup( simraddragbar.Indicator, apply(gui:DefaultPopup("Affects the area around your character where you control part physics. Having this set higher will help with physics-based exploits, but can cause performance lag.\n\nWhen off, roblox fluctuates this value to avoid frame-drops."), { BackgroundTransparency = settings.Looks.PopupTransparency, Size = UDim2.new(0,200,0,90) }), { FollowMouse = true, MouseOffset = Vector2.new(-205,-95) })
    
    local simraddragothers = apply(defbutton:Clone(), {
        Parent = physholder,
        Name = 'SimRadiusDragOthers',
        Position = UDim2.new(0,30,0,0)
    })
    apply(simraddragothers.RealText, {
        Text = "<font color="..blue..">  Lower Others' Radius</font>",
        TextSize = 13,
        Size = UDim2.new(1, -20, 0, 20) --upd for button
    })
    physdata.SimRadiusDragOthers = {
        On = function()
            options.SimRadiusDragOthers = true
            simraddragothers.Button.BackgroundColor3 = accent
        end,
        Off = function()
            options.SimRadiusDragOthers = false
            simraddragothers.Button.BackgroundColor3 = dark
        end
    }
    gui:BindToggleClick(simraddragothers.Button, physdata.SimRadiusDragOthers, options.SimRadiusDragOthers)
    
    local demobheader = apply(section:Clone(), {
        Parent = maintab,
        Text = "Demobilization",
        Position = UDim2.new(0.05,0,0,180),
        Size = UDim2.new(0.65,0,0,20)
    })
    gui:MakePopup(apply(popupbox:Clone(), { Parent = demobheader }), apply(gui:DefaultPopup("Demobilizes NPCs/mobs in humanoid disasters. Requires network ownership to work.\n\n*Cloak will follow your mouse if\nthere are no other players in the server."), { BackgroundTransparency = settings.Looks.PopupTransparency, Size = UDim2.new(0,200,0,70) }), { FollowMouse = true })
    
    local demobdata = {}
    fdata.Demobilization = demobdata
    local demobholder = apply(gui:AddBasic("Frame", UDim2.new(0.9,0,0,120), UDim2.new(0.05,0,0,205), maintab), {
        Name = "Demobilization",
        --BorderColor3 = white
    })
    defuill:Clone().Parent = demobholder
    
    --put me (below) in my own section
    local demobilizerdata = shareddata.DemobilizerCache or {}
    shareddata.DemobilizerCache = demobilizerdata
    
    local demobilizerfuncs = {}
    demobilizerfuncs.Sit = {
        [true] = function(hum, root) hum.Sit = true end,
        [false] = function(hum, root) hum.Sit = false end
    }
    demobilizerfuncs.Freeze = {
        [true] = function(hum, root)
            hum.PlatformStand = true
            root.Anchored = true
            humanoidsfrozen[hum] = true
        end,
        [false] = function(hum, root)
            if not humanoidsfrozen[hum] then return end
            rawset(humanoidsfrozen, hum, nil)

            hum.PlatformStand = false
            root.Anchored = false

        end
    }
    demobilizerfuncs.Fling = {
        [true] = function(hum, root)
            hum.PlatformStand = true
            if root.RotVelocity.Magnitude < 50 then
                root.Velocity = randomvector(Vector3.new(400,800,400))
                root.RotVelocity = randomvector(200)
            end
        end,
        [false] = function(hum, root)
            hum.PlatformStand = false
        end
    }
    --local masscache = {} --nvm bc of desync replication (rip processing speed)
    local gravcache = {}
    local gravity = workspace.Gravity
    demobilizerfuncs.AntiGrav = {
        [true] = function(hum, root)
            local cached = gravcache[root]
            if (cached) then
                if cached:IsDescendantOf(workspace) then return end
            else
                local a
                a = hum.AncestryChanged:Connect(function(v)
                    a:Disconnect()
                    rawset(data.Connections, a, nil)
                    rawset(gravcache, root, nil)
                end)
                data.Connections[a] = a
            end
            hum.PlatformStand = true
            for i,v in next, hum.Parent:GetDescendants() do if v:IsA"BodyForce" then v:Destroy() end end
            local bf = Instance.new"BodyForce"
            bf.Force = Vector3.new(0, getmassof(root) * gravity) --doesnt account for other bodyforces ex coil noobs xd dnc
            gravcache[root] = bf
            bf.Parent = root
            root.Velocity, root.RotVelocity = root.Velocity + randomvector(5), root.RotVelocity +  randomvector(5)
        end,
        [false] = function(hum, root)
            local cached = gravcache[root]
            if cached and cached.Parent then cached:Destroy() end
            hum.PlatformStand = false
        end
    }
    demobilizerfuncs.Cloak = {
        [true] = function(hum, root)
            local closest, me = getclosestplayerfrompoint(root.Position)
            if closest ~= me then
                hum:MoveTo(closest)
            else
                hum:MoveTo(mouse.Hit.p)
            end
        end,
        [false] = function() end
    }
    local function doremove(root)
        root.CFrame = CFrame.new(Vector3.new(600,-125,0), Vector3.new(0,-1000,0))
        root.Velocity = Vector3.new(0,-400,0)
        root.RotVelocity = randomvector(500)
    end
    demobilizerfuncs.Remove = {
        [true] = function(hum, root)
            hum.PlatformStand = true
            if root.Position.Y <= -60 then return end
            defer(doremove, root) 
        end,
        [false] = function(hum, root)
            hum.PlatformStand = false
        end
    }
    demobilizerfuncs.Mouse = {
        [true] = function(hum, root)
            hum:MoveTo(mouse.Hit.p)
        end,
        [false] = function() end
    }
    demobilizerfuncs["(Nothing)"] = { --to just ctrl click
        [true] = function() end,
        [false] = function() end
    }
    local demobtracers = {}
    tracers['Demobilizer'] = demobtracers
    
    local movedirs = {
        [Enum.KeyCode.W] = function(cframe)
            return cframe.LookVector
        end,
        [Enum.KeyCode.A] = function(cframe)
            return -cframe.RightVector
        end,
        [Enum.KeyCode.S] = function(cframe)
            return -cframe.LookVector
        end,
        [Enum.KeyCode.D] = function(cframe)
            return cframe.RightVector
        end
    }
    local spacebar = Enum.KeyCode.Space
    
    local lastpos, lastroot = CFrame.new()
    insert(data.Functions, { stepper:Add(game["Run Service"], "Stepped", "Demobilizer", function(lifetime, lastelapsed)
        local me = gethum()
        if not me then return elseif options.OverrideMovement then
            me.WalkSpeed = options.PreferredWalkSpeed
            me.JumpPower = options.PreferredJumpPower
        end
        local root = me.RootPart --le 1 to prevent accidental rubber banding from freezing on purpose
        if root and lastelapsed <= 1 and  options.AntiFling and (not shareddata.Fly or root.Position.Y < workspace.FallenPartsDestroyHeight + 25) and options.AntiFlingMode == 'Active' then
            
            local pos = root.Position
            if pos.Y < workspace.FallenPartsDestroyHeight + 25 then
                root.CFrame = CFrame.new(pos +  Vector3.new(0,workspace.FallenPartsDestroyHeight + 50 - pos.Y))
                root.Velocity = vzero
                root.RotVelocity = vzero
            end
            local poscondition = (abs(pos.X) <= 200 and abs(pos.Y) <= 200 and abs(pos.Z) <= 200)
            if lastroot == root and (not poscondition or root.Velocity.Magnitude > 300 or root.RotVelocity.Magnitude > 150) then
                root.Velocity = vzero
                root.RotVelocity = vzero
                root.CFrame = lastpos + Vector3.new(0,5,0)
                --notify{Title = "AntiFling Triggered",Text = "Returning to last recorded safe-spot", Duration = 1}
            end
            lastroot = root
            if root.Velocity.Magnitude <= 50 and me.FloorMaterial.Name ~= 'Air' and poscondition then lastpos = root.CFrame end
        end
        local flying = shareddata.Fly
        if flying and not inputservice:GetFocusedTextBox() then
            local isvehicle = me.SeatPart
            local lastgyro, lastfly = shareddata.FlyRotateInst, shareddata.FlyInst

            local newparent = isvehicle and isvehicle.Parent and (isvehicle.Parent:IsA"Model" and isvehicle.Parent.PrimaryPart or isvehicle) or root

            if lastgyro then
                lastgyro.Parent = newparent

                lastgyro.CFrame = cc.CFrame
            end
            if lastfly then
                lastfly.Parent = newparent

                local finalvel, relcframe = vzero, cc.CFrame
                local speed = options.FlySpeed or 50
                for i,v in next, inputservice:GetKeysPressed() do
                    local validmove = movedirs[v.KeyCode]
                    if validmove then finalvel = finalvel + validmove(relcframe) end
                end
                finalvel = finalvel.Magnitude ~= 0 and (finalvel.Unit * speed) or vzero
                if inputservice:IsKeyDown(spacebar) then
                    finalvel = finalvel + Vector3.new(0,speed/2 * (isctrling() and -1 or 1))
                end
                lastfly.Velocity = finalvel

                local hum = gethum()
                if isvehicle and hum then
                    cc.CameraSubject = hum
                end
            end
            
            me.PlatformStand = not isvehicle
        end
        local char = lp.Character
        if char:FindFirstChild"Head" then
            char.Head.CanCollide = not (options.NoclipFly and (options.NoclipModeIndex == 1 or shareddata.Fly))
        end
        if char:FindFirstChild"Torso" then
            char.Torso.CanCollide = not (options.NoclipFly and options.NoclipModeIndex == 1 or shareddata.Fly)
        end
        me = me.RootPart
        
        if not (me and options.Demobilizer) then return end
        for humanoid, disable in next, humanoids do
            local rootpart = humanoid.RootPart
            if rootpart then
                local maxdist = options.DemobilizationRadius
                local tracer = newtracer(rootpart, "", "Demobilizer", true, false, {Color = accent, Method = "2D"}) --will return old cached tracer so this is ok
                if not
                    (((humanoidsfrozen[humanoid] or not (rootpart.Anchored or rootpart:IsGrounded())) and isnetworkowner(rootpart)) --part isnt anchored,  part is owned
                    and (
                        maxdist == 200
                        or (rootpart.Position - me.Position).Magnitude <= maxdist)
                    )
                then
                    tracer:SetVisible(false)
                    demobilizerfuncs[options.DemobilizerMode][false](humanoid, rootpart)
                else
                    tracer:SetVisible(options.DemobVisualTargets)
                    demobilizerfuncs[options.DemobilizerMode][true](humanoid, rootpart)
                end
                
            end
        end
    end, 0) }) --maybe add a delay? hmm
    
    local lastorb = shareddata.DemobRangeVisualizer --used after this section
    
    
    local simraddragbar = gui:AddDragbar(
      { --main
        Size = UDim2.new(1,0,0,20),
        Parent = demobholder,
        Position = nil, --ui ll
        NoCode = false,
        Text = "Activation Radius",
        OverlayColor = white,
        InvertScrolling = true,
        Border = 1
      }, { --number indicator
        Type = "TextLabel",
        RightSide = false,
        Size = UDim2.new(0,30,0,20),
        TextSize = 10
      }, { --range
        Default = options.DemobilizationRadius or 0,
        Min = 0,
        Max = 200,
        Step = 5
      }, {
        OnChange = function(newval, self)
            self.Indicator.Text = "<font color="..green..">"..(newval == 0 and "OFF" or newval == 200 and "ALL" or newval).."</font>"
            options.DemobilizationRadius = newval -- 0 = off
            if newval == 0 then
                options.Demobilizer = false
                for i,v in next, demobilizerfuncs do
                    for humanoid, disable in next, humanoids do
                        local rootpart = humanoid.RootPart
                        if (rootpart and isnetworkowner(rootpart)) then
                            v[false](humanoid, rootpart)
                        end
                    end
                end
                if lastorb then lastorb.Size = vzero end
            else
                options.Demobilizer = true
                if lastorb then
                    lastorb.Size = (options.DemobVisualRange and newval ~= 200) and vone * (2 * newval) or vzero
                end
            end
        end
    })
    simraddragbar.TextOverlay.TextSize = 12
    --oops
    apply(gui:AddBasic("Frame", UDim2.new(0,0,0,60), nil, demobholder), {Name = "(oops)", BackgroundTransparency = 1})
    --
    --gui:MakePopup( simraddragbar.Indicator, apply(gui:DefaultPopup("The map is 400x300x400 studs."), { BackgroundTransparency = settings.Looks.PopupTransparency, Size = UDim2.new(0,200,0,90) }), { FollowMouse = true, MouseOffset = Vector2.new(-205,-95) })
    gui:AddRadioButtons(
        {Parent = simraddragbar, Position = UDim2.new(0,21,0,21), Size = UDim2.new(1,-21,0,60)},
        {Size = UDim2.new(0.5,0,0,20), StartsFrom = nil, Background = medium, Default = options.DemobilizerModeIndex or 1, RightSide = false, TextSize = 11, SortingOpt = apply(Instance.new"UIGridLayout", { SortOrder = "LayoutOrder", CellSize = UDim2.new(0.5,0,0,20), CellPadding = UDim2.new()})},
        {
            "Sit",
            "Freeze",
            "Fling",
            "AntiGrav",
            "Cloak",
            "Remove",
            "Mouse",
            "(Nothing)"
        },
        function(t, index)
            options.DemobilizerModeIndex = index
            options.DemobilizerMode = t
            for i,v in next, demobilizerfuncs do
                for humanoid, disable in next, humanoids do
                    local rootpart = humanoid.RootPart
                    if not (rootpart and isnetworkowner(rootpart)) then
                        v[false](humanoid, rootpart)
                    end
                end
            end
        end)
    
    local keybindDemobTP = keybinds["Gameplay >> DemobKeybindTP"] or {
        Info = "Gameplay >> DemobKeybindTP",
        Key = "T",
        Ctrl = false,
        Alt = false,
        Repetitions = 3,
    }
    registerkeybind(keybindDemobTP, function()
        if not options.InfJump then return end
        local me = gethum()
        me = me and me.RootPart
        if not me then return end
        for humanoid, disable in next, humanoids do
            local rootpart = humanoid.RootPart
            if rootpart then
                local maxdist = options.DemobilizationRadius
                if (isnetworkowner(rootpart) and (maxdist == 200 or (rootpart.Position - me.Position).Magnitude <= maxdist)) then
                    rootpart.CFrame = CFrame.new(mouse.Hit.p)
                end
            end
        end
    end, true)
    local demobkeybindtp = apply(defbutton:Clone(), {
        Parent = demobholder,
        Name = 'DemobKeybindTP',
        Position = UDim2.new(0,30,0,0)
    })
    gui:MakePopup(apply(popupbox:Clone(), { Parent = demobkeybindtp }), apply(gui:DefaultPopup("Current Keybind:\n "..(keybinds["Gameplay >> DemobKeybindTP"] and keybinds["Gameplay >> DemobKeybindTP"].Format or "NONE")), { BackgroundTransparency = settings.Looks.PopupTransparency, Size = UDim2.new(0,120,0,35) }), { FollowMouse = true })
    
    apply(demobkeybindtp.RealText, {
        Text = "<font color="..blue..">  Keybind TP</font>",
        TextSize = 13,
        Size = UDim2.new(1, -20, 0, 20) --upd for button
    })
    demobdata.DemobKeybindTP = {
        On = function()
            options.DemobKeybindTP = true
            demobkeybindtp.Button.BackgroundColor3 = accent
        end,
        Off = function()
            options.DemobKeybindTP = false
            demobkeybindtp.Button.BackgroundColor3 = dark
        end
    }
    gui:BindToggleClick(demobkeybindtp.Button, demobdata.DemobKeybindTP, options.DemobKeybindTP)

    local baseorb = apply(Instance.new"Part", {
        Massless = true,
        Material = "ForceField",
        CanCollide = false,
        Transparency = 0.4, --0.4
        Color = accent,
        CastShadow = false,
        Shape = "Ball",
        Name = "RangeBall"
    })
    
    local function orbonnewchar(char)
        if not char then return end
        local root
        while not root and char.Parent do root = char:WaitForChild("HumanoidRootPart", 5) end

        if not char.Parent then
            return
        elseif lastorb and lastorb.Parent then
            lastorb:Destroy()
        end
        lastorb = baseorb:Clone()
        lastorb.Size = (options.DemobVisualRange and vone * (2 * options.DemobilizationRadius)) or vzero

        local w = Instance.new"Weld"
        w.Part0 = root
        w.Part1 = lastorb
        w.Parent = lastorb
        
        shareddata.DemobRangeVisualizer = lastorb
        lastorb.Parent = tracerfolder3d
    end
    insert(data.Functions, { stepper:Add(lp, "CharacterAdded", "VisualizeDemobRangeOrb", orbonnewchar) })
    defer(orbonnewchar, lp.Character)
    local demobvisualizerange = apply(defbutton:Clone(), {
        Parent = demobholder,
        Name = 'DemobVisualRange',
        Position = UDim2.new(0,30,0,0)
    })
      
    apply(demobvisualizerange.RealText, {
        Text = "<font color="..blue..">  Visualize Range</font>",
        TextSize = 13,
        Size = UDim2.new(1, -20, 0, 20) --upd for button
    })
    demobdata.DemobVisualRange = {
        On = function()
            options.DemobVisualRange = true
            demobvisualizerange.Button.BackgroundColor3 = accent
            if lastorb then
                lastorb.Size = (options.DemobVisualRange and vone * (2 * options.DemobilizationRadius)) or vzero
            end
        end,
        Off = function()
            options.DemobVisualRange = false
            demobvisualizerange.Button.BackgroundColor3 = dark
            if lastorb then lastorb.Size =  vzero end
        end
    }
    gui:BindToggleClick(demobvisualizerange.Button, demobdata.DemobVisualRange, options.DemobVisualRange)
    
    local demobvisualizetargets = apply(defbutton:Clone(), {
        Parent = demobholder,
        Name = 'DemobVisualTargets',
        Position = UDim2.new(0,30,0,0)
    })
    gui:MakePopup(apply(popupbox:Clone(), { Parent = demobvisualizetargets }), apply(gui:DefaultPopup"May cause lag if many humanoids are present.", { BackgroundTransparency = settings.Looks.PopupTransparency, Size = UDim2.new(0,120,0,40) }), { FollowMouse = true })
      
    apply(demobvisualizetargets.RealText, {
        Text = "<font color="..red..">  Visualize Targets</font>",
        TextSize = 13,
        Size = UDim2.new(1, -20, 0, 20) --upd for button
    })
    demobdata.DemobVisualTargets = {
        On = function()
            options.DemobVisualTargets = true
            demobvisualizetargets.Button.BackgroundColor3 = accent
            for i,v in next, tracers['Demobilizer'] do v:SetVisible(true) end
        end,
        Off = function()
            options.DemobVisualTargets = false
            demobvisualizetargets.Button.BackgroundColor3 = dark
            for i,v in next, tracers['Demobilizer'] do v:SetVisible(false) end
        end
    }
    gui:BindToggleClick(demobvisualizetargets.Button, demobdata.DemobVisualTargets, options.DemobVisualTargets)
    
    
    local movedata = {}
    fdata.Movement = movedata
    apply(section:Clone(), {
        Parent = righttab,
        Text = "Movement"
    })
    
    local moveholder = apply(gui:AddBasic("Frame", UDim2.new(0.9,0,0,140), UDim2.new(0.05,0,0,25), righttab), {
        Name = "Movement",
        BorderColor3 = white
    })
    defuill:Clone().Parent = moveholder
    
    local overridemovement = apply(defbutton:Clone(), {
        Parent = moveholder,
        Name = 'OverrideMovement',
        Position = UDim2.new(0,30,0,0)
    })
    apply(overridemovement.RealText, {
        Text = "<font color="..blue..">  Override Movement</font>",
        TextSize = 13,
        Size = UDim2.new(1, -20, 0, 20) --upd for button
    })
    movedata.OverrideMovement = {
        On = function()
            options.OverrideMovement = true
            overridemovement.Button.BackgroundColor3 = accent
            
            local hum = gethum()
            if hum then hum.WalkSpeed, hum.JumpPower = 16, 50 end
        end,
        Off = function()
            options.OverrideMovement = false
            overridemovement.Button.BackgroundColor3 = dark
            
            local hum = gethum()
            if hum then hum.WalkSpeed, hum.JumpPower = 16, 50 end
        end
    }
    gui:BindToggleClick(overridemovement.Button, movedata.OverrideMovement, options.OverrideMovement)
    
    local movespeeddragbar = gui:AddDragbar(
      { --main
        Size = UDim2.new(1,0,0,20),
        Parent = moveholder,
        Position = nil, --ui ll
        NoCode = false,
        Text = "Walkspeed",
        OverlayColor = white,
        InvertScrolling = true,
        Border = 1
      }, { --number indicator
        Type = "TextBox",
        RightSide = false,
        Size = UDim2.new(0,30,0,20),
        TextSize = 10
      }, { --range
        Default = options.PreferredWalkSpeed or 16,
        Min = 16,
        Max = 220,
        Step = 1
      }, {
        OnChange = function(newval, self)
            options.PreferredWalkSpeed = newval
        end
    })
    movespeeddragbar.Indicator.TextColor3 = gui:GetThemeColor"Accent"
    movespeeddragbar.TextOverlay.TextSize = 12
    local jumppowerdragbar = gui:AddDragbar(
      { --main
        Size = UDim2.new(1,0,0,20),
        Parent = moveholder,
        Position = nil, --ui ll
        NoCode = false,
        Text = "JumpPower",
        OverlayColor = white,
        InvertScrolling = true,
        Border = 1
      }, { --number indicator
        Type = "TextBox",
        RightSide = false,
        Size = UDim2.new(0,30,0,20),
        TextSize = 10
      }, { --range
        Default = options.PreferredJumpPower or 50,
        Min = 50,
        Max = 160,
        Step = 1
      }, {
        OnChange = function(newval, self)
            options.PreferredJumpPower = newval
        end
    })
    jumppowerdragbar.Indicator.TextColor3 = gui:GetThemeColor"Accent"
    jumppowerdragbar.TextOverlay.TextSize = 12
    
    local basefly, basegyro = apply(Instance.new"BodyVelocity", { MaxForce = vone * 9e29, Velocity = vzero }), apply(Instance.new"BodyGyro", { MaxTorque = vone * 4e6, P = 50000 })
    local lastfly = shareddata.FlyInst
    local lastgyro = shareddata.FlyRotateInst
    local freefallstate, physicsstate
    local function dofly(char)
        if lastfly and lastfly.Parent then lastfly:Destroy() lastfly = nil end
        if lastgyro and lastgyro.Parent then lastgyro:Destroy() lastgyro = nil end
        if not (shareddata.Fly and char) then
            local hum = gethum()
            if hum then
                hum.PlatformStand = false
                --if hum:GetState().Name == 'Physics' then hum:ChangeState("Freefall") end
                if hum.RootPart then hum.RootPart.CFrame = CFrame.new(hum.RootPart.Position) end --fixes stumble when facing toof ar up/down
            end
            return
        end
        local root
        while not root and char.Parent do root = char:WaitForChild("HumanoidRootPart", 5) end
        if not char.Parent then return end
        lastfly = basefly:Clone()
        lastgyro = basegyro:Clone()
        
        shareddata.FlyInst = lastfly
        shareddata.FlyRotateInst = lastgyro
        
        lastgyro.Parent = root
        lastfly.Parent = root
    end
    insert(data.Functions, { stepper:Add(lp, "CharacterAdded", "NewFlyInstance", dofly) })
    
    local flyspeeddragbar = gui:AddDragbar(
      { --main
        Size = UDim2.new(1,0,0,20),
        Parent = moveholder,
        Position = nil, --ui ll
        NoCode = false,
        Text = "Fly",
        OverlayColor = white,
        InvertScrolling = true,
        Border = 1
      }, { --number indicator
        Type = "TextLabel",
        RightSide = false,
        Size = UDim2.new(0,30,0,20),
        TextSize = 10
      }, { --range
        Default = options.FlySpeed or 45,
        Min = 45,
        Max = 250,
        Step = 5
      }, {
        OnChange = function(newval, self)
            if newval == 45 then
                shareddata.Fly = false
                dofly(lp.Character)
                self.Indicator.Text = "<font color="..green..">OFF</font>"
            else
                self.Indicator.Text = "<font color="..green..">"..newval.."</font>"
            end
            options.FlySpeed = newval
        end
    })
    local keybindfly =  keybinds["Gameplay >> Fly"] or  {
        Info = "Gameplay >> Fly",
        Key = "F",
        Ctrl = true,
        Alt = false,
        Repetitions = 2
    }
    registerkeybind(keybindfly, function() if options.FlySpeed == 45 then return end shareddata.Fly = not shareddata.Fly dofly(lp.Character) end, true) --true overwrites old

    gui:MakePopup( flyspeeddragbar.Indicator, apply(gui:DefaultPopup("Keybind-only.\n\nCurrent Keybind:\n"..(keybinds["Gameplay >> Fly"] and keybinds["Gameplay >> Fly"].Format or "NONE")), { BackgroundTransparency = settings.Looks.PopupTransparency, Size = UDim2.new(0,160,0,50) }), { FollowMouse = true })
    
    local noclipfly = apply(defbutton:Clone(), {
        Parent = moveholder,
        Name = 'Noclip',
        Size = UDim2.new(1,0,0,40)
    })
    gui:MakePopup(apply(popupbox:Clone(), { Parent = noclipfly }), apply(gui:DefaultPopup"Turns off character collisions while flying.", { BackgroundTransparency = settings.Looks.PopupTransparency, Size = UDim2.new(0,180,0,65) }), { FollowMouse = true })
     
    apply(noclipfly.RealText, {
        Text = "<font color="..blue..">  Noclip</font>",
        Size = UDim2.new(1, -20, 0, 20) --upd for button
    })
    movedata.NoclipFly = {
        On = function()
            options.NoclipFly = true
            noclipfly.Button.BackgroundColor3 = accent
        end,
        Off = function()
            options.NoclipFly = false
            noclipfly.Button.BackgroundColor3 = dark
        end
    }
    gui:BindToggleClick(noclipfly.Button, movedata.NoclipFly, options.NoclipFly)
    gui:AddRadioButtons(
        {Parent = noclipfly, Position = UDim2.new(0,21,0,21), Size = UDim2.new(1,-21,0,20)},
        {Size = UDim2.new(0.5,0,0,20), StartsFrom = nil, Background = medium, Default = options.NoclipModeIndex or 1, RightSide = false, TextSize = 11, SortingOpt = apply(Instance.new"UIGridLayout", { SortOrder = "LayoutOrder", CellSize = UDim2.new(0.5,0,0,20), CellPadding = UDim2.new()})},
        {
            "Always",
            "Fly Only"
        },
        function(t, index)
            options.NoclipModeIndex = index
            options.NoclipMode = t
        end)
    insert(data.Functions, { stepper:Add(game["Run Service"], "Heartbeat", "BHopApply", function()
        if (shareddata.Fly or not options.BHop) then return end
        local me = gethum()
        local root = me and me.RootPart
        if not (me and root) then return end
        --prevents slowdowns when changing direction (no force impulse)
        --also makes you return to zero instantly (no sliding when releasing wasd)
        local forcevel = me.MoveDirection * me.WalkSpeed
        root.Velocity = root.Velocity * Vector3.new(0,1,0) + forcevel
    end) })


    local bhoptoggle = apply(defbutton:Clone(), {
        Parent = moveholder,
        Name = 'BHop',
        Position = UDim2.new(0,30,0,0)
    })
    gui:MakePopup(apply(popupbox:Clone(), { Parent = bhoptoggle }), apply(gui:DefaultPopup"Forces your character to instantly change directions/stop when pressing/releasing WASD keys\n\n(Prevents sliding at high speeds)", { BackgroundTransparency = settings.Looks.PopupTransparency, Size = UDim2.new(0,180,0,65) }), { FollowMouse = true })
     
    apply(bhoptoggle.RealText, {
        Text = "<font color="..blue..">  BHop Movement</font>",
        TextSize = 13,
        Size = UDim2.new(1, -20, 0, 20) --upd for button
    })
    movedata.BHop = {
        On = function()
            options.BHop = true
            bhoptoggle.Button.BackgroundColor3 = accent
        end,
        Off = function()
            options.BHop = false
            bhoptoggle.Button.BackgroundColor3 = dark
        end
    }
    gui:BindToggleClick(bhoptoggle.Button, movedata.BHop, options.BHop)
    
    local keybindinfjump = keybinds["Gameplay >> InfJump"] or {
        Info = "Gameplay >> InfJump",
        Key = "Space",
        Ctrl = false,
        Alt = false,
        Repetitions = 1,
    }
    local jumping = Enum.HumanoidStateType.Jumping
    registerkeybind(keybindinfjump, function()
        if not options.InfJump then return end
        local hum = gethum()
        local root = hum and hum.RootPart
        local state = hum and hum:GetState().Name
        if not (root and (state == 'Freefall')) then return end
        local speed = ((options.OverrideMovement and options.PreferredJumpPower or hum.JumpPower))
        if root.Velocity.Y > speed then return end
        root.Velocity = root.Velocity * Vector3.new(1,0,1)
        hum:ChangeState(jumping)
    end, true)
    local infinitejumptoggle = apply(defbutton:Clone(), {
        Parent = moveholder,
        Name = 'InfJump',
        Position = UDim2.new(0,30,0,0)
    })
    apply(infinitejumptoggle.RealText, {
        Text = "<font color="..blue..">  Infinite Jump</font>",
        TextSize = 13,
        Size = UDim2.new(1, -20, 0, 20) --upd for button
    })
    movedata.InfJump = {
        On = function()
            options.InfJump = true
            infinitejumptoggle.Button.BackgroundColor3 = accent
        end,
        Off = function()
            options.InfJump = false
            infinitejumptoggle.Button.BackgroundColor3 = dark
        end
    }
    gui:BindToggleClick(infinitejumptoggle.Button, movedata.InfJump, options.InfJump)
    
    
    local antifling = apply(defbutton:Clone(), {
        Parent = moveholder,
        Name = 'AntiFling',
        Size = UDim2.new(1,0,0,40)
    })
    apply(antifling.RealText, {
        Text = "<font color="..green..">  Unflingable</font>",
        TextSize = 13,
        Size = UDim2.new(1, -20, 0, 20) --upd for button
    })
    
    movedata.AntiFling = {
        On = function()
            options.AntiFling = true
            antifling.Button.BackgroundColor3 = accent
        end,
        Off = function()
            options.AntiFling = false
            antifling.Button.BackgroundColor3 = dark
        end
    }
    gui:BindToggleClick(antifling.Button, movedata.AntiFling, options.AntiFling)
    gui:AddRadioButtons(
        {Parent = antifling, Position = UDim2.new(0,21,0,21), Size = UDim2.new(1,-21,0,20)},
        {Size = UDim2.new(0.5,0,0,20), StartsFrom = nil, Background = medium, Default = options.AntiFlingIndex or 1, RightSide = false, TextSize = 11, SortingOpt = apply(Instance.new"UIGridLayout", { SortOrder = "LayoutOrder", CellSize = UDim2.new(0.5,0,0,20), CellPadding = UDim2.new()})},
        {
            "Passive",
            "Active"
        },
        function(t, index)
            options.AntiFlingIndex = index
            options.AntiFlingMode = t
        end)
    gui:MakePopup(antifling.RadioButtons.Passive, apply(gui:DefaultPopup"Prevents your character from ragdolling.", { BackgroundTransparency = settings.Looks.PopupTransparency, Size = UDim2.new(0,120,0,40) }), { FollowMouse = true })
    gui:MakePopup(antifling.RadioButtons:FindFirstChild"Active", apply(gui:DefaultPopup"Does the latter and rubber-bands you if you get launched too quickly.\nExperimental.", { BackgroundTransparency = settings.Looks.PopupTransparency, Size = UDim2.new(0,140,0,50) }), { FollowMouse = true })
end


menu_gears = gui:AddMenu("Gears", unpackc3(options.MenuColors.Gears) or Color3.fromRGB(66, 245, 66), 0, 0)
do
    local maintab = gui:AddBasic("Frame", UDim2.new(0,187.5,0, 155), UDim2.new(0,10,0,10), menu_gears.Frame)
    local maintab2 = gui:AddBasic("Frame", UDim2.new(0,187.5,0, 135), UDim2.new(0,10,0,170), menu_gears.Frame)
    local rightmaintab = gui:AddBasic("Frame", UDim2.new(0,187.5,0,255), UDim2.new(1,-197.5,0,85), menu_gears.Frame)
    
    local accent = menu_gears.Accent
    
    local colorkey = gui:AddBasic("Frame", UDim2.new(0,187.5,0,70), UDim2.new(1,-197.5,0,10), menu_gears.Frame)
    apply(gui:AddBasic("TextLabel", UDim2.new(0.95,0,1, -25), UDim2.new(0.05,0,0,25), colorkey), {TextSize = 12, BorderSizePixel = 0, TextXAlignment = "Left", TextYAlignment = "Top",
        Text = ("<font color=%s> Red</font> - Tracers<font color=%s>\nGreen</font> - Specialized\n<font color=%s>Blue</font> - Other"):format(red, green, blue)
    })
    section:Clone().Parent = colorkey
    
    local hooked = data.Hooked
    local fdata = {}
    data.Functions.Gears = fdata
    
    local gendata = {}
    fdata.General = gendata
    apply(section:Clone(), {
        Parent = maintab,
        Text = "General",
        Size = UDim2.new(0.8,0,0,20)
    })
    local genholder = apply(gui:AddBasic("Frame", UDim2.new(0.9,0,0,120), UDim2.new(0.05,0,0,25), maintab), {
        Name = "General",
        BorderColor3 = white
    })
    defuill:Clone().Parent = genholder
    local swords = {
        ["Game Master's Sword"] = true,
        ["Darkheart"] = true,
        ["Epic Katana"] = true,
        ["Battle Sword"] = true
    }

    local activesword, activemedkit, lastmedkit = nil, nil, shareddata.LastMedkit
    local fire
    local buycooldown = tick()-0.5
    local bluetoothcooldown = tick()-0.1
    function overridemedkitfire(name, state, obj)
        local current = gears:current()
        if state.Name == 'Begin' and (current and current.Name ~= 'First Aid Kit') then
            current:Activate()
            if not options.EnableSwordReach
                or (not activesword or activesword ~= current)
                or tick() - bluetoothcooldown < 0.1
                or not (activesword:FindFirstChild"Handle")
            then
                if current.Name == 'Trowel' then
                    local event = current:WaitForChild("FireWeapon", 5)
                    if not event then return end
                    event:FireServer(mouse.Hit.p)
                end
                return
            end
            local handle = activesword.Handle
            local pos = handle.Position
            local skipmagcheck = options.SwordReachRadius == 200
            for humanoid, disable in next, humanoids do
                local root = humanoid.RootPart
                if  (root and (skipmagcheck or (pos - root.Position).Magnitude <= options.SwordReachRadius)) then touch(root, handle) end
            end
            bluetoothcooldown = tick()
        elseif state.Name ~= 'Begin' then return end
        local handle = activemedkit and activemedkit:WaitForChild("Handle", 5)
        local event = handle and activemedkit:WaitForChild"FireWeapon"
        if not event then return end
        if handle.Transparency ~= 0.5 then
            event:FireServer(mouse.Hit.p)
            buycooldown = tick()
            return
        elseif options.DisableMedkitCooldown and getstat'coins' >= 900 and tick() - buycooldown >= 0.3 then
            buycooldown = tick()
            local cur = activemedkit
            gears:buy"First Aid Kit"
            local t = tick()
            while tick() - t < 10 and wait() do
                local next = gears:has"First Aid Kit"
                if next and cur ~= next then
                    if lp.Character then
                        local tool = lp.Character:FindFirstChildWhichIsA"Tool"
                        if tool then tool.Parent = lp.Backpack end
                        next.Parent = lp.Character
                        defer(overridemedkitfire, name, state, obj)
                    end
                    return
                end
            end
        end
    end
    insert(data.Functions, { stepper:AddContext("MedkitTouch", overridemedkitfire, false, 2001, Enum.UserInputType.MouseButton1) })
    local function addsword(c, onforeach)
        c = onforeach or c
        local name = tostring(c)
        if swords[name] then
            activesword = c
            local char = lp.Character
            local x
            x = c.AncestryChanged:Connect(function(instupd, newparent)
                if newparent == char then return end
                x:Disconnect()
                if activesword == c then activesword = nil end
            end)
        elseif name == 'First Aid Kit' then
            activemedkit = c
            if not activemedkit then return end
            if activemedkit ~= lastmedkit then
                lastmedkit = activemedkit
                shareddata.LastMedkit = activemedkit
            end
            local char = lp.Character
            local x
            local self = activemedkit
            x = c.AncestryChanged:Connect(function(instupd, newparent)
                if newparent == char then return end
                x:Disconnect()
                if activemedkit == self then activemedkit = nil end
            end) 
        end
        return
        
    end
    insert(data.Functions, { stepper:Add(lp, "CharacterAdded", "LinkedSwordRegister", function(char)
        char.ChildAdded:Connect(addsword)
    end) })
    insert(data.Functions, { stepper:Add(lp.Character, "ChildAdded", "LinkedSwordRegisterStartup", addsword)})
    for i,v in next, lp.Character:GetChildren() do addsword(i,v) end
    
    
    local swordreacher = apply(defbutton:Clone(), {
        Parent = genholder,
        Size = UDim2.new(1,0,0,41)
    })
    apply(swordreacher.RealText, {
            Text = "<font color="..green..">  Sword Range</font>",
            Size = UDim2.new(1, -40, 0, 20) --upd for button
        })
    gui:MakePopup(apply(popupbox:Clone(), { Parent = swordreacher }), apply(gui:DefaultPopup"Makes any sword you have equipped reach farther than normal.", { BackgroundTransparency = settings.Looks.PopupTransparency, Size = UDim2.new(0,120,0,40) }), { FollowMouse = true })
    
    gendata.EnableSwordReach = {
        On = function()
            options.EnableSwordReach = true
            swordreacher.Button.BackgroundColor3 = accent
        end,
        Off = function()
            options.EnableSwordReach = false
            swordreacher.Button.BackgroundColor3 = dark
        end
    }
    gui:BindToggleClick(swordreacher.Button, gendata.EnableSwordReach, options.EnableSwordReach)
    local swordreachdragbar = gui:AddDragbar(
      { --main
        Size = UDim2.new(1,-21,0,20),
        Parent = swordreacher,
        Position = UDim2.new(0,21,0,21), --ui ll
        NoCode = false,
        Text = "Radius",
        OverlayColor = white,
        InvertScrolling = true,
        Border = 1
      }, { --number indicator
        Type = "TextLabel",
        RightSide = false,
        Size = UDim2.new(0,30,0,20),
        TextSize = 10
      }, { --range
        Default = options.SwordReachRadius or 10,
        Min = 5,
        Max = 200,
        Step = 15
      }, {
        OnChange = function(newval, self)
            self.Indicator.Text = "<font color="..green..">"..((newval == 200 and "ALL") or newval).."</font>"
            options.SwordReachRadius = newval
        end
    })
    local medkits = shareddata.Medkits or {}
    shareddata.Medkits = medkits
    local rockets = shareddata.Rockets or {}
    shareddata.Rockets = rockets
    local enemyrockets = shareddata.EnemyRockets or {}
    shareddata.EnemyRockets = enemyrockets

    insert(data.Functions, { stepper:Add(workspace, "ChildAdded", "MiscGearsRegister", function(c)
        if
            tostring(c) == 'Handle'
            and c.Size == Vector3.new(1, 0.4, 1)
            and not medkits[c]
        then
            local pellet = c:WaitForChild("PelletScript", 5)
            pellet = pellet and pellet:WaitForChild("Player", 5)
            if not pellet then return end
            local x;
            x = c.AncestryChanged:Connect(function()
                x:Disconnect()
                rawset(medkits, c, nil)
            end)
            medkits[c] = pellet.Value
        elseif
            tostring(c) == 'Rocket'
            and not rockets[c]
        then
            local owner = c:WaitForChild("creator", 0.5)
            local rocketp = c:WaitForChild("RocketPropulsion", 5)
            if not (rocketp and owner and owner.Value:IsA"Player") then enemyrockets[c] = c return end
            x = c.AncestryChanged:Connect(function()
                x:Disconnect()
                rawset(rockets, c, nil)
            end)
            c.CanTouch = not options.DisableRocketTouch
            rockets[c] = { tick(), owner.Value, rocketp }
            options.InternalReadyToRocketRide = not shareddata.Fly
        elseif
            tostring(c) == 'Missile'
            and c:IsA"BasePart"
        then
            enemyrockets[c] = c
        end

        
    end) })

    registerkeybind({
        Info = "MedkitTPSecret",
        Key = "N",
        Ctrl = true,
        Alt = false,
        Repetitions = 1
    }, function()
        if settings.Panicked then return end
        local root = getroot(shareddata.MedkitFTouchTarget)
        if not root then return end
        for med,owner in next, medkits do
            if isnetworkowner(med) then
                med.Velocity = root.Velocity + Vector3.new(0,5,0)
                med.CFrame = root.CFrame
            end
        end
    end)
    local currocket
    insert(data.Functions, { stepper:Add(game['Run Service'], "Heartbeat", "MiscGearsUpdate", function()
        if options.EnableMedkitFTouch then
            local hum, root = gethum(shareddata.MedkitFTouchTarget)
            root = hum and hum.RootPart
            if (hum and root and hum.Health > 0 --[[and hum.Health ~= hum.MaxHealth]]) then
                local filtermine = options.MedkitFTouchModeIndex == 1
                for med, owner in next, medkits do
                    if (not filtermine) or owner == lp then touch(med, root) end
                end
            end
        end
        if options.EnableRocketControl then
            local target
            if shareddata.RocketChoice == nil or not shareddata.RocketChoice.Parent then
                target = mouse.Hit.p + Vector3.new(0,2)
            else
                local hum = gethum(shareddata.RocketChoice)
                local root = hum and hum.RootPart
                if not root then return end
                target = root and root.Position or target
            end
            local newestrocket, newestspawn
            for rocket, data in next, rockets do
                if rocket.Anchored then
                    firesignal(rocket.AncestryChanged)
                else
                    if (data[2] == lp and (not newestrocket or (data[1] > newestspawn))) then
                        newestrocket, newestspawn = rocket, data[1]
                    end
                    local rp = data[3]
                    rp.TargetOffset = target
                    rp.MaxSpeed = options.RocketMaxSpeed
                end
            end
            if options.EnableRocketRide and not shareddata.Fly and newestrocket then
                currocket = newestrocket
            end
        end
    end, 0.05) })
    local radian = math.pi/180
    insert(data.Functions, { stepper:Add(game["Run Service"], "Heartbeat", "RocketRide", function()
        local hum = gethum()
        local root = hum and hum.RootPart --terribly ugly code
        if options.AntiFling and not shareddata.Fly and root then
            root.CFrame = CFrame.new(root.Position) * CFrame.Angles(0,root.Orientation.Y*radian, 0)
        end
        if not (options.InternalReadyToRocketRide and currocket and currocket.Parent and not currocket.Anchored) then return end

        

        if not root then
            return
        elseif hum.Jump then
            options.InternalReadyToRocketRide = false
            return
        end
        root.CFrame = CFrame.new(currocket.Position + Vector3.new(0,3)) * CFrame.Angles(0,radian * currocket.Orientation.Y, 0)
        root.Velocity = currocket.Velocity
    end) })
    local medkitftouch = apply(defbutton:Clone(), {
        Parent = genholder,
        Size = UDim2.new(1,0,0,60)
    })
    apply(medkitftouch.RealText, {
            Text = "<font color="..green..">  Medkit Auto-Touch</font>",
            Size = UDim2.new(1, -20, 0, 20), --upd for button
            TextSize = 13
        })
    gui:MakePopup(apply(popupbox:Clone(), { Parent = medkitftouch }), apply(gui:DefaultPopup"Uses medkits from any distance away.", { BackgroundTransparency = settings.Looks.PopupTransparency, Size = UDim2.new(0,120,0,40) }), { FollowMouse = true })
    
    gendata.EnableMedkitFTouch = {
        On = function()
            options.EnableMedkitFTouch = true
            medkitftouch.Button.BackgroundColor3 = accent
        end,
        Off = function()
            options.EnableMedkitFTouch = false
            medkitftouch.Button.BackgroundColor3 = dark
        end
    }
    gui:BindToggleClick(medkitftouch.Button, gendata.EnableMedkitFTouch, options.EnableMedkitFTouch)

    shareddata.MedkitFTouchTarget = shareddata.MedkitFTouchTarget and plrs:FindFirstChild(tostring(shareddata.MedkitFTouchTarget)) or lp
    local medkitftouchtarget = apply(gui:AddBasic("TextBox", UDim2.new(1,-21,0,20), UDim2.new(0,21,0,40), medkitftouch), {
        Text = tostring(shareddata.MedkitFTouchTarget),
        PlaceholderText = tostring(shareddata.MedkitFTouchTarget),
        BackgroundColor3 = medium,
        TextSize = 12
    })
    insert(data.Connections, medkitftouchtarget.FocusLost:Connect(function()
        local plr = plrfromstr(medkitftouchtarget.Text) or shareddata.MedkitFTouchTarget
        local name = tostring(plr)
        shareddata.MedkitFTouchTarget = plr
        medkitftouchtarget.Text, medkitftouchtarget.PlaceholderText = name, name
    end))
    gui:AddRadioButtons(
        {Parent = medkitftouch, Position = UDim2.new(0,21,0,21), Size = UDim2.new(1,-21,0,20)},
        {Size = UDim2.new(0.5,0,0,20), StartsFrom = nil, Background = medium, Default = options.MedkitFTouchModeIndex or 1, RightSide = false, TextSize = 11, SortingOpt = apply(Instance.new"UIGridLayout", { SortOrder = "LayoutOrder", CellSize = UDim2.new(0.5,0,0,20), CellPadding = UDim2.new()})},
        {
            "Mine",
            "All"
        },
        function(t, index)
            options.MedkitFTouchModeIndex = index
            options.MedkitFTouchMode = t
        end)
    
    local medkitnocd = apply(defbutton:Clone(), {
        Parent = genholder
    })
    apply(medkitnocd.RealText, {
            Text = "<font color="..blue..">  No Medkit CD</font>",
            Size = UDim2.new(1, -20, 0, 20), --upd for button
        })
    gui:MakePopup(apply(popupbox:Clone(), { Parent = medkitnocd }), apply(gui:DefaultPopup"Disables medkit use-cooldown. Costs 900c each time (it just rebuys the gear).", { BackgroundTransparency = settings.Looks.PopupTransparency, Size = UDim2.new(0,160,0,40) }), { FollowMouse = true })
    
    gendata.DisableMedkitCooldown = {
        On = function()
            options.DisableMedkitCooldown = true
            medkitnocd.Button.BackgroundColor3 = accent
        end,
        Off = function()
            options.DisableMedkitCooldown = false
            medkitnocd.Button.BackgroundColor3 = dark
        end
    }
    gui:BindToggleClick(medkitnocd.Button, gendata.DisableMedkitCooldown, options.DisableMedkitCooldown)
    

    local defaultpartshapes = {}
    defaultpartshapes.Circle = function(self, degree, ...) --globals defined in (obj):update()
        local args = {...}
        local offsetperc = args[1]/args[2]
        degree = degree * torad + (offsetperc * tau)
        return Vector3.new(sin(degree), cos(args[3].degrps(0.1)*torad + offsetperc*tau)/15, cos(degree)) * self.Radius
    end
    defaultpartshapes.Heart = function(self, degree, ...) 
        local args = {...}
        local offsetperc = args[1]/args[2]
        degree = degree * torad + (offsetperc * tau)
        return Vector3.new(
            sin(degree)^3,
            0,
            ( 13*cos( degree ) - 5*cos( 2*degree ) - 2*cos( 3*degree ) - cos( 4*degree ) )/16
        ) * self.Radius
    end
    defaultpartshapes.Figure8 = function(self, degree, ...)
        local args = {...}
        local cache = args[3]
        local offsetperc = args[1]/args[2]
        degree = degree * torad + (offsetperc * tau)
        
        local x, y = sin(degree), 0.5 * sin(2 * degree)
        local rot2 = cache.degrps(0.0167) * torad
        local offs, offc = sin(rot2), cos(rot2)
        return Vector3.new(x*offc - y*offs, 0, x*offs + y*offc) * self.Radius
    end
    defaultpartshapes.Flower = function(self, degree, ...) --overrides rps to a fifth of the speed
        local args = {...}
        local cache = args[3]
        local chooseshape = floor(cache.degrps(0.05)*4/360)+2 --1/(4shapes * 5s each)
        local offsetperc = args[1]/args[2]
        degree = cache.degrps(self.RPS * 0.2) * torad + (offsetperc * tau)
        
        local x, y = sin(chooseshape * degree) * cos(degree), sin(chooseshape * degree) * sin(degree)
        local rot2 = cache.degrps(0.0167) * torad
        local offs, offc = sin(rot2), cos(rot2)
        return Vector3.new(x*offc - y*offs,0,y*offc + x*offs) * self.Radius
    end
    defaultpartshapes.Lightning = function(self, degree, ...) --125d
        local args = {...}
        local cache = args[3]
        local offsetperc = args[1]/args[2]
        degree = degree * torad + (offsetperc * tau)
        
        local x,y = cos(degree), sin(degree)
        local rot2 = cache.degrps(random()*5) * torad
        local offs, offc = sin(rot2), cos(rot2)
        return Vector3.new(
            x*offc - y*offs,
            0,
            y*offc + x*offs
        ) * self.Radius + Vector3.new(0,75 * cos(cache.degrps(3*random())) + 40)
    end
    defaultpartshapes.Nova = function(self, degree, ...) --125d
        local args = {...}
        local cache = args[3]
        local offsetperc = args[1]/args[2]
        degree = degree * torad + (offsetperc * tau)

        local x,y = cos(2*degree)*cos(degree), cos(2*degree) * sin(degree)
        local rot2 = cache.degrps(5) * torad
        local offs, offc = sin(rot2), cos(rot2)

        local x = Vector3.new(
            x*offc - y*offs,
            cos(3*degree * random())*cos(5*degree * random()) + x*offs,
            y*offc + x*offs
        ).Unit * self.Radius + Vector3.new(0,self.Radius/2)
        return x
    end
    defaultpartshapes.Cube = function(self, degree, ...) --tween
        local args = {...}
        local power = args[3].cube
        local spot = args[1]-1
        local x, y, z = (spot % power), floor(spot/power^2), floor(spot / power) % power
        return Vector3.new(x - power/2,y,z - power/2) * self.Radius + Vector3.new(0,5) --Vector3.new(x*2, 3 + 0.5 * y, z*2)
    end
    defaultpartshapes.Smiley = function(self, degree, ...)
        local args = {...}
        local place = args[1]
        local cache = args[3]
        local x,y
        if place <= 2 then
            degree = degree * torad + (place/args[2] * tau)
            x = (2*place - 3) * 0.25 --x/2 - 3/4
            y = 0.25 + sin(cache.degrps(5)) * 0.25
        elseif place <= 5 then
            degree = degree * torad + ((place-2) * 0.25 * tau)
            x = cos(degree) * 0.5
            y = -abs(sin(degree)) * 0.25 - 0.25
        else
            degree = degree * torad + ((place-5)/(args[2]-5) * tau)
            x = cos(degree)
            y = sin(degree)
        end
        local degree2 = cache.root and -cache.root.Orientation.Y*torad or 0
        return Vector3.new(x * cos(degree2), y, x * sin(degree2)) * self.Radius
    end
    defaultpartshapes['8==D'] = function(self, degree, ...) 
        local args = {...}
        local cache = args[3]
        local offsetperc = args[1]/args[2]
        degree = (degree * torad +(offsetperc * tau)) % tau
        
        local denominator = 1/(4.92228456446 * self.Radius) --4.9 is the r=1 perimeter of the shape
        local percentage = degree/tau
        --piecewise lol
        --the values are ratios of the "piece's" perimeter to the total perimeter
        local x,y
        if percentage < 0.235577115725 then
            degree = degree/0.235577115725
            
            x = 2 * cos(degree)/3 - 7/6
            y = 2 * sin(degree)/3
        elseif percentage < 0.404296796737 then
            local last = 0.235577115725 * tau
            degree = (degree - last)/(0.404296796737*tau - last) * tau
            
            x = -0.5
            y = degree/2
        elseif percentage < 0.507361784866 then
            local last = 0.404296796737 * tau
            degree = (degree - last)/(0.507361784866*tau - last) * tau
            
            x = -cos(degree/2)/2
            y = abs((2 * sin(degree/2))/3) + 3
        elseif percentage < 0.676081465878 then
            local last = 0.507361784866 * tau
            degree = (degree - last)/(0.676081465878*tau - last) * tau
            
            x = 0.5
            y = 3 - degree/2
        elseif percentage < 0.911658581603 then
            local last = 0.676081465878 * tau
            degree = (degree - last)/(0.911658581603*tau - last) * tau
            
            x = -2 * cos(degree)/3 + 7/6
            y = 2 * sin(degree)/3
        else
            local last = 0.911658581603 * tau
            degree = (degree - last)/(tau-last) * tau

            x = cos(degree/2)/2
            y = -sin(degree)/2
        end
        local degree2 = cache.root and -cache.root.Orientation.Y*torad or 0
        return Vector3.new(x*cos(degree2), y, x*sin(degree2)) * self.Radius * 3/11 --scales to r=1 (i made the shape at an 11/3 factor in desmos)
    end
    defaultpartshapes.Orbit = function(self, degree, ...) 
        local args = {...}
        local cache = args[3]
        local offsetperc = args[1]/args[2]
        
        randomseed(args[1]*12345) --to make predictable orbit patterns
        degree = (cache.degrps(self.RPS * (random() + 0.1)) * torad +((random()) * tau)) % tau
        
        return Vector3.new(
            cos(degree),
            0,
            sin(degree)
        ) * (args[1]/args[2] + 5/self.Radius) * self.Radius
    end
    defaultpartshapes.Wings = function(self, degree, ...)
        local args = {...}
        local cache = args[3]
        local offsetperc = args[1]/args[2]
        degree = degree * torad + (offsetperc * tau)
        
        local x,y = sin(2*degree)
        y = 2*x*cos(degree)
        local degree2 = -cache.root.Orientation.Y*torad
        return -cache.root.CFrame.LookVector + Vector3.new(
            x*cos(degree2),
            y,
            x*sin(degree2)
        ) * self.Radius
    end


    --
    for i,v in next, defaultpartshapes do shurikontroltools.updatefenv(v) end

    local connectedparts = shareddata.ShurikontrolConnected or {}
    shareddata.ShurikontrolConnected = connectedparts
    local plen = 0
    local function removepart(obj)
        if not connectedparts[obj] then return end
        rawset(connectedparts, obj, nil)
    end
    local zero, czero = Vector3.zero, CFrame.identity
    local defdata =  shareddata.ShurikontrolSettings or {
        rps = 1,
        radius = 5,
        P = 10000,
        D = 1250, --125 for lightning rememebr this
        mode = "normal", --normal/tweening/tp (tween does not actually replicate so not practical)
        offset = Vector3.new(0,0,0),
        method = defaultpartshapes.Wings,
        setup = function(self)
            local part = self.Part
            part.CanTouch = false
            while not isnetworkowner(part) do wait() end
            local bvel = part:WaitForChild("BodyVelocity", 5)
            if not bvel then self:unregister() return end
            bvel:Destroy()
            local con
            con = part.AncestryChanged:Connect(function()
                con:Disconnect()
                rawset(data.Connections, con, nil)
                self:unregister()
            end)
            data.Connections[con] = con
            if self.Mode == 'tweening' then
                self.Part.Position = (getroot() or czero).Position
            end
            self.Part.RotVelocity = zero
            connectedparts[self] = true
        end,
        unregister = removepart
    }
    shareddata.ShurikontrolSettings = defdata
    
    insert(data.Functions, { stepper:Add(workspace, "ChildAdded", "ShurikontrolRegister", function(v)
        if not options.Shurikontrol then return end
        local root = getroot()
        if not (root
            and v.Name ==  'Handle'
            and v.Size == Vector3.new(1.2,0.2,1.2)
            and (root.Position - v.Position).Magnitude <= options.ShurikontrolRegisterRadius)
        then
            return 
        end
        shurikontroltools.register(v, defdata, true)
    end)})
    local function newdegcache(n)
        local next = self.degs[n]
        if not next then
            next = getfenv(2).degreeAtRPS(n)
            self.degs[n] = next
        end
        return next
    end
    local plen = 1
    local cachefuncs = {
        cube = function(self)
            local pow = plen^(1/3)
            local pcheck = floor(pow)
            pow = (pow == pcheck and pow) or pcheck + 1
            rawset(self, 'cube', pow)
            return pow
        end,
        root = function(self)
            local root = getroot()
            if root then
                rawset(self, 'root', root)
                return root
            end
        end,
        degrps = function(self)
            if not self.degs then
                self.degs = {}
                getfenv(newdegcache)['self'] = self
            end
            return newdegcache
        end,
    }
    local cachemt = {}
    local cache = setmetatable({}, cachemt)
    cachemt.__index = function(self, index)
        local x = cachefuncs[index]
        return x and x(self)
    end
    stepper:Add(game["Run Service"], "Heartbeat", "Shurikontrol", function()
        if not options.Shurikontrol then return end
        --desync()
        local root = getroot()
        if not root then return end
        root = root.Position
        
        local ctr = 0
        local tbl = {}
        for i,v in next, connectedparts do
            if not isnetworkowner(i.Part) then
                i:unregister()
            else
                ctr = ctr + 1
                tbl[i] = not options.ShurikontrolDoPatterns and root or i:nextupdate(root, ctr, plen, cache)
            end
            
        end
        plen = ctr > 0 and ctr or 1
        
        --sync()
        for i,v in next, tbl do
            i:update(v, true)
        end
        clr(cache)
        clr(tbl)
        local closestpart, closestdist = nil, 1/0
        local root = getroot()
        if not root then return end
        root = root.Position
        for humanoid,v in next, humanoids do
            local totouch = humanoid.Parent and humanoid.Parent:FindFirstChild"Head" or humanoid.RootPart
            if totouch then
                local dist = (root-totouch.Position).Magnitude
                if (totouch and dist < closestdist) then closestpart, closestdist = totouch, dist end
            end
        end
        if not closestpart then return end
        for i,v in next, connectedparts do
            if i.Part then touch(i.Part, closestpart) end
            
        end
    end)
    

    local shurikontrolheader = apply(section:Clone(), {
        Parent = rightmaintab,
        Text = "Shurikontrol",
        Size = UDim2.new(0.55,0,0,20)
    })
    gui:MakePopup(apply(popupbox:Clone(), { Parent = shurikontrolheader }), apply(gui:DefaultPopup("Manipulates shurikens around you to form patterns and instantly damage enemies. Always hits headshots."), { BackgroundTransparency = settings.Looks.PopupTransparency, Size = UDim2.new(0,200,0,50) }), { FollowMouse = true })
    
    local shurikontrolholder = apply(gui:AddBasic("Frame", UDim2.new(0.9,0,0,220), UDim2.new(0.05,0,0,25), rightmaintab), {
        Name = "Shurikontrol",
        BorderColor3 = white
    })
    defuill:Clone().Parent = shurikontrolholder

    local shurikontrol = apply(defbutton:Clone(), {
        Parent = shurikontrolholder,
        Size = UDim2.new(1,0,0,40)
    })
    apply(shurikontrol.RealText, {
            Text = "<font color="..green..">  Shurikontrol</font>",
            Size = UDim2.new(1,0,0,20)
    })
    
    gendata.Shurikontrol = {
        On = function()
            options.Shurikontrol = true
            shurikontrol.Button.BackgroundColor3 = accent
        end,
        Off = function()
            options.Shurikontrol = false
            shurikontrol.Button.BackgroundColor3 = dark
        end
    }
    gui:BindToggleClick(shurikontrol.Button, gendata.Shurikontrol, options.Shurikontrol)

    gui:AddRadioButtons(
        {Parent = shurikontrol, Position = UDim2.new(0,21,0,21), Size = UDim2.new(1,-21,0,60)},
        {Size = UDim2.new(0.5,0,0,20), StartsFrom = nil, Background = medium, Default = options.ShurikontrolDrawIndex or 1, RightSide = false, TextSize = 11, SortingOpt = apply(Instance.new"UIGridLayout", { SortOrder = "LayoutOrder", CellSize = UDim2.new(0.5,0,0,20), CellPadding = UDim2.new()})},
        {
            "Normal",
            "TP"
        },
        function(t, index)
            options.ShurikontrolDrawIndex = index
            defdata.mode = t:lower()
        end)

    local shurikontrolregisterdragbar = gui:AddDragbar(
      { --main
        Size = UDim2.new(1,0,0,20),
        Parent = shurikontrolholder,
        Position = nil, --ui ll
        NoCode = false,
        Text = "Register Radius",
        OverlayColor = white,
        InvertScrolling = true,
        Border = 1
      }, { --number indicator
        Type = "TextLabel",
        RightSide = false,
        Size = UDim2.new(0,30,0,20),
        TextSize = 10
      }, { --range
        Default = options.ShurikontrolRegisterRadius or 25,
        Min = 25,
        Max = 300,
        Step = 25
      }, {
        OnChange = function(newval, self)
            self.Indicator.Text = "<font color="..blue..">"..newval.."</font>"
            options.ShurikontrolRegisterRadius = newval
        end
    })
    gui:MakePopup(
        shurikontrolregisterdragbar.Indicator,
        apply(
            gui:DefaultPopup("Determines how far away a shuriken can spawn before being ignored (lower radius affects your stars)"),
            { BackgroundTransparency = settings.Looks.PopupTransparency, Size = UDim2.new(0,160,0,50) }
        ),
        { FollowMouse = true }
    )

    local shurikontroldopatterns = apply(defbutton:Clone(), {
        Parent = shurikontrolholder,
        Size = UDim2.new(1,0,0,80)
    })
    apply(shurikontroldopatterns.RealText, {
            Size = UDim2.new(1,0,0,20),
            Text = "<font color="..blue..">  Draw Patterns</font>",
        })
    
    gendata.ShurikontrolDoPatterns = {
        On = function()
            options.ShurikontrolDoPatterns = true
            shurikontroldopatterns.Button.BackgroundColor3 = accent
        end,
        Off = function()
            options.ShurikontrolDoPatterns = false
            shurikontroldopatterns.Button.BackgroundColor3 = dark
        end
    }
    gui:BindToggleClick(shurikontroldopatterns.Button, gendata.ShurikontrolDoPatterns, options.ShurikontrolDoPatterns)

    gui:AddRadioButtons(
        {Parent = shurikontroldopatterns, Position = UDim2.new(0,21,0,21), Size = UDim2.new(1,-21,0,60)},
        {Size = UDim2.new(0.5,0,0,20), StartsFrom = nil, Background = medium, Default = options.ShurikontrolModeIndex or 1, RightSide = false, TextSize = 11, SortingOpt = apply(Instance.new"UIGridLayout", { SortOrder = "LayoutOrder", CellSize = UDim2.new(0.5,0,0,20), CellPadding = UDim2.new()})},
        {
            "Circle",
            "Cube",
            "Figure8",
            "Flower",
            "Heart",
            "Lightning",
            "Nova",
            "Orbit",
            "Smiley",
            "Wings",
            "8==D"
        },
        function(t, index)
            options.ShurikontrolModeIndex = index
            defdata.method = defaultpartshapes[t]
        end)
    
    local shurikontrolrpsdraw = gui:AddDragbar(
      { --main
        Size = UDim2.new(1,0,0,20),
        Parent = shurikontrolholder,
        Position = nil, --ui ll
        NoCode = false,
        Text = "RPS",
        OverlayColor = white,
        InvertScrolling = true,
        Border = 1
      }, { --number indicator
        Type = "TextLabel",
        RightSide = false,
        Size = UDim2.new(0,30,0,20),
        TextSize = 10
      }, { --range
        Default = defdata.rps*4 or 4,
        Min = 2,
        Max = 12,
        Step = 1
      }, {
        OnChange = function(newval, self)
            newval = newval * 0.25
            self.Indicator.Text = "<font color="..blue..">"..newval.."</font>"
            defdata.rps = newval
        end
    })

    local shurikontrolradiusdraw = gui:AddDragbar(
      { --main
        Size = UDim2.new(1,0,0,20),
        Parent = shurikontrolholder,
        Position = nil, --ui ll
        NoCode = false,
        Text = "Radius",
        OverlayColor = white,
        InvertScrolling = true,
        Border = 1
      }, { --number indicator
        Type = "TextLabel",
        RightSide = false,
        Size = UDim2.new(0,30,0,20),
        TextSize = 10
      }, { --range
        Default = defdata.radius or 5,
        Min = 1,
        Max = 100,
        Step = 1
      }, {
        OnChange = function(newval, self)
            self.Indicator.Text = "<font color="..blue..">"..newval.."</font>"
            defdata.radius = newval
        end
    })
    local shurikontroldampening = gui:AddDragbar(
      { --main
        Size = UDim2.new(1,0,0,20),
        Parent = shurikontrolholder,
        Position = nil, --ui ll
        NoCode = false,
        Text = "Dampening",
        OverlayColor = white,
        InvertScrolling = true,
        Border = 1
      }, { --number indicator
        Type = "TextLabel",
        RightSide = false,
        Size = UDim2.new(0,30,0,20),
        TextSize = 10
      }, { --range
        Default = defdata.D or 5,
        Min = 125,
        Max = 1250,
        Step = 125
      }, {
        OnChange = function(newval, self)
            self.Indicator.Text = "<font color="..blue..">"..newval.."</font>"
            defdata.D = newval
        end
    })
    local shurikontrolyoffset = gui:AddDragbar(
      { --main
        Size = UDim2.new(1,0,0,20),
        Parent = shurikontrolholder,
        Position = nil, --ui ll
        NoCode = false,
        Text = "Y-Offset",
        OverlayColor = white,
        InvertScrolling = true,
        Border = 1
      }, { --number indicator
        Type = "TextLabel",
        RightSide = false,
        Size = UDim2.new(0,30,0,20),
        TextSize = 10
      }, { --range
        Default = defdata.offset and defdata.offset.Y or 0,
        Min = -25,
        Max = 25,
        Step = 1
      }, {
        OnChange = function(newval, self)
            self.Indicator.Text = "<font color="..blue..">"..newval.."</font>"
            defdata.offset = Vector3.new(0,newval)
        end
    })

    local rocketheader = apply(section:Clone(), {
        Parent = maintab2,
        Text = "Homing Missiles",
        Size = UDim2.new(0.7,0,0,20)
    })
    gui:MakePopup(apply(popupbox:Clone(), { Parent = rocketheader }), apply(gui:DefaultPopup("Lets you control rockets from player Rocket Launchers."), { BackgroundTransparency = settings.Looks.PopupTransparency, Size = UDim2.new(0,160,0,40) }), { FollowMouse = true })
    
    local rocketholder = apply(gui:AddBasic("Frame", UDim2.new(0.9,0,0,100), UDim2.new(0.05,0,0,25), maintab2), {
        Name = "Homing Missiles",
        BorderColor3 = white
    })
    defuill:Clone().Parent = rocketholder

    local rocketcontroltoggle = apply(defbutton:Clone(), {
        Parent = rocketholder,
        Size = UDim2.new(1,0,0,40)
    })
    apply(rocketcontroltoggle.RealText, {
            Size = UDim2.new(1,0,0,20),
            Text = "<font color="..green..">  Homing Missiles</font>",
        })
    
    gendata.EnableRocketControl = {
        On = function()
            options.EnableRocketControl = true
            rocketcontroltoggle.Button.BackgroundColor3 = accent
        end,
        Off = function()
            options.EnableRocketControl = false
            rocketcontroltoggle.Button.BackgroundColor3 = dark
        end
    }
    gui:BindToggleClick(rocketcontroltoggle.Button, gendata.EnableRocketControl, options.EnableRocketControl)

    
    local rocketcontrolchoice = apply(gui:AddBasic("TextBox", UDim2.new(1,-21,0,19), UDim2.new(0,21,1,-19), rocketcontroltoggle), {
        Text = shareddata.RocketChoice and tostring(shareddata.RocketChoice) or "",
        PlaceholderText = "(blank for mouse)",
        BackgroundColor3 = dark,
        TextSize = 12
    })
    insert(data.Connections, rocketcontrolchoice.FocusLost:Connect(function()
        local text = rocketcontrolchoice.Text
        if #text == 0 then
            shareddata.RocketChoice = nil
            rocketcontrolchoice.Text = "FollowMouse"
            return
        end
        local plr = plrfromstr(text) or shareddata.RocketChoice
        shareddata.RocketChoice = plr
        rocketcontrolchoice.Text = plr and tostring(plr) or "FollowMouse"
    end))
    firesignal(rocketcontrolchoice.FocusLost) --lol

    local rocketcontrolspeed = gui:AddDragbar(
        { --main
          Size = UDim2.new(1,0,0,20),
          Parent = rocketholder,
          Position = nil, --ui ll
          NoCode = false,
          Text = "Rocket Speed",
          OverlayColor = white,
          InvertScrolling = true,
          Border = 1
        }, { --number indicator
          Type = "TextLabel",
          RightSide = false,
          Size = UDim2.new(0,30,0,20),
          TextSize = 10
        }, { --range
          Default = options.RocketMaxSpeed or 80,
          Min = 70,
          Max = 250,
          Step = 5
        }, {
          OnChange = function(newval, self)
              self.Indicator.Text = "<font color="..blue..">"..newval.."</font>"
              options.RocketMaxSpeed = newval
          end
      })
    
    local rocketridetoggle = apply(defbutton:Clone(), {
        Parent = rocketholder,
        Size = UDim2.new(1,0,0,20)
    })
    apply(rocketridetoggle.RealText, {
            Size = UDim2.new(1,0,0,20),
            Text = "<font color="..blue..">  Rocket Ride</font>",
        })
    gendata.EnableRocketRide = {
        On = function()
            options.EnableRocketRide = true
            rocketridetoggle.Button.BackgroundColor3 = accent
        end,
        Off = function()
            options.EnableRocketRide = false
            rocketridetoggle.Button.BackgroundColor3 = dark
        end
    }
    gui:BindToggleClick(rocketridetoggle.Button, gendata.EnableRocketRide, options.EnableRocketRide)

    local rockettouchtoggle = apply(defbutton:Clone(), {
        Parent = rocketholder,
        Size = UDim2.new(1,0,0,20)
    })
    gui:MakePopup(apply(popupbox:Clone(), { Parent = rockettouchtoggle }), apply(gui:DefaultPopup"Attempts to prevent the rocket from exploding. Network ownership makes it unreliable.", { BackgroundTransparency = settings.Looks.PopupTransparency, Size = UDim2.new(0,160,0,40) }), { FollowMouse = true })
    
    apply(rockettouchtoggle.RealText, {
            Size = UDim2.new(1,0,0,20),
            Text = "<font color="..blue..">  Don't Explode</font>",
        })
    gendata.DisableRocketTouch = {
        On = function()
            options.DisableRocketTouch = true
            rockettouchtoggle.Button.BackgroundColor3 = accent
            for i,v in next, rockets do i.CanTouch = false end
        end,
        Off = function()
            options.DisableRocketTouch = false
            rockettouchtoggle.Button.BackgroundColor3 = dark
            for i,v in next, rockets do i.CanTouch = true end
        end
    }
    gui:BindToggleClick(rockettouchtoggle.Button, gendata.DisableRocketTouch, options.DisableRocketTouch)
end


menu_shop = gui:AddMenu("Shop", unpackc3(options.MenuColors.Shop) or Color3.fromRGB(66, 245, 227), 0, 215)
do
    local loadouttab = gui:AddBasic("Frame", UDim2.new(1,-20,0, 60), UDim2.new(0,10,0,10), menu_shop.Frame)
    local accent = menu_shop.Accent
    local accentrich = torichcolor(accent)

    local fdata = {}
    data.Functions.Gears = fdata
    
    local gendata = {}
    fdata.General = gendata
    apply(section:Clone(), {
        Parent = loadouttab,
        Text = "Loadout",
        Size = UDim2.new(0.8,0,0,20)
    })

    local hotbar = game:GetService("CoreGui").RobloxGui.Backpack.Hotbar
    local function getcurgearorder()
        local ls = {}
        for i = 1, 10 do
            ls[i] = hotbar[i].ToolName.Text
        end
        return ls
    end
    
    local loadoutorder = shareddata.LoadoutOrder or {}
    local cachelastsaved = {}
    local function saveloadout()
        datasaver.SetSave("bell/sd2/loadout", loadoutorder)
    end
    local function getsavedloadout()
        cachelastsaved = datasaver.GetSave("bell/sd2/loadout") or {}
        return cachelastsaved
    end
    getsavedloadout()
    local loadoutsavebtn, lastsaved = apply(gui:AddBasic("TextButton", UDim2.new(0,30,0,12), UDim2.new(1,-75,1,-48), loadouttab), {
        Text = "Save",
        TextSize = 10,
        BackgroundColor3 = dark
    })
    local loadoutloadbtn = apply(gui:AddBasic("TextButton", UDim2.new(0,30,0,12), UDim2.new(1,-45,1,-48), loadouttab), {
        Text = "Load",
        TextSize = 10,
        BackgroundColor3 = dark
    })
    local cansave = true
    

    local function reordergears(data, dodefault)
        if not lp:FindFirstChild"Backpack" then return end
        data = dodefault and loadoutorder or data
        local currentlayout = getcurgearorder()

        local startindex = 1
        while data[startindex] and data[startindex] == currentlayout[startindex] do
            startindex = startindex + 1
        end
        if startindex == 11 then return end --nothing changed
        local cache = {}
        local activegear
        for i = startindex, 10 do
            local gear = gears:has(currentlayout[i])
            if gear then
                cache[currentlayout[i]] = gear
                if gear.parent == lp.Character then activegear = gear end
                gear.Parent = lp.Backpack
            end
        end
        for i,v in next, cache do v.Parent = lp end
        for i = startindex, 10 do
            local gear = cache[data[i]]
            if gear then gear.Parent = lp.Backpack end
        end
        if activegear then activegear.Parent = lp.Character end
        trash(cache)

        cansave = false
        for i,v in next, cachelastsaved do
            if v ~= data[i] then
                cansave = true
                break
            end
        end
        loadoutsavebtn.Text = cansave and "Save" or "ðŸŸ¢"
        
        return
    end

    local loadoutcontainer = gui:AddDragAndDrop(
        apply(
            gui:AddBasic("Frame", UDim2.new(1,-10,0,30), UDim2.new(0,5,1,-35), loadouttab),
            {BackgroundColor3 = medium}
        ),
        {
            Type = "Image",
            Amount = 10,
            Sorting = {
                SortOrder = "LayoutOrder", --dont change off of it
                FillDirection = "Horizontal",
                Type = "List"
            },
            Properties = {
                Size = UDim2.new(0,37,0,30),
                BackgroundColor3 = medium,
                ScaleType = "Fit"
            }
        },
        {
            --(placeholder, images get populated later)
        },
        {
            UpdateTable = loadoutorder,
            OnChange = reordergears
        }
    )
    local function populateloadout()
        local data = getcurgearorder()
        cansave = false
        for i,v in next, data do
            loadoutcontainer[i].Image = gears[v] and 'rbxassetid://'..gears[v].Data.Image or ""
            loadoutorder[i] = v
            if v ~= cachelastsaved[i] then
                cansave = true
            end
        end
        loadoutsavebtn.Text = cansave and "Save" or "ðŸŸ¢"
    end
    populateloadout()
    if #cachelastsaved > 0 then
        cansave = false
        for i,v in next, cachelastsaved do
            if v ~= loadoutorder[i] then
                cansave = true
                break
            end
        end
        loadoutsavebtn.Text = cansave and "Save" or "ðŸŸ¢"
    end
    insert(data.Connections, loadoutsavebtn.MouseButton1Click:Connect(function()
        if not cansave then return end
        cansave = false
        loadoutsavebtn.Text = "ðŸŸ¢"
        savedb = tick()
        saveloadout()
    end))
    local loaddb = false
    insert(data.Connections, loadoutloadbtn.MouseButton1Click:Connect(function()
        if loaddb then return else loaddb = true end
        getsavedloadout()
        if #cachelastsaved < 1 then laoddb = false return end
        local cost = 0
        local keepcache = {}
        for i,v in next, cachelastsaved do
            if gears[v] then
                if gears:has(v) then
                    keepcache[v] = i
                else
                    cost = cost + gears[v].Data.Price
                end
            end
        end
        if cost > getstat'coins' then
            loadoutloadbtn.Text = "ðŸ’°âŒ" --broke ass
            loaddb = false
            return
        end
        loadoutloadbtn.Text = "..."
        for i,v in next, getcurgearorder() do
            if not keepcache[v] then gears:sell(v) end
        end
        for i,v in next, cachelastsaved do gears:buy(v, 0.1, true) end
        for i = 1, 10 do
            loadoutorder[i] = cachelastsaved[i] or ""
        end
        reordergears(cachelastsaved)
        populateloadout()
        loadoutloadbtn.Text = "Load"
        loaddb = false
    end))
    local sgear = lp.StarterGear
    insert(data.Functions, { stepper:Add(sgear, "ChildAdded", "LoadoutPopulator", populateloadout, nil, true) })
    insert(data.Functions, { stepper:Add(sgear, "ChildRemoved", "LoadoutPopulator", populateloadout, nil, true) })
    insert(data.Functions, { stepper:Add(lp, "CharacterAdded", "FixGears", function()
        local t = tick()
        local gearsishouldhave = sgear:GetChildren()
        local len = #gearsishouldhave
        if len == 0 then trash(gearsishouldhave) return end
        for i,v in next, gearsishouldhave do gearsishouldhave[i] = tostring(v) end
        local index = 1
        while tick() - t < 15 and gearsishouldhave[index] do
            if gears:has(gearsishouldhave[index]) then
                index = index + 1
            end
            wait()
        end
        trash(gearsishouldhave)
        if index <= len then return end --failed!
        reordergears(nil, true)
    end)})

    local shoptab = gui:AddBasic("Frame", UDim2.new(1,-20,0, 130), UDim2.new(0,10,0,75), menu_shop.Frame)

    apply(section:Clone(), {
        Parent = shoptab,
        Text = "Shop",
        Size = UDim2.new(0.8,0,0,20)
    })

    local gearpreviewname = apply(gui:AddBasic("TextLabel", UDim2.new(0,100,0,20), UDim2.new(1,-112,1,-125), shoptab), {
        TextSize = 12,
        Text = "",
        BorderSizePixel = 0
    })
    local gearpreviewimg = apply(gui:AddBasic("ImageLabel", UDim2.new(0,50,0,50), UDim2.new(1,-85,1,-105), shoptab), {
        BackgroundTransparency = 1
    })
    local gearpreviewcost = apply(gui:AddBasic("TextLabel", UDim2.new(0,100,0,20), UDim2.new(1,-112,1,-54), shoptab), {
        TextSize = 12,
        Text = "",
        BorderSizePixel = 0,
        TextColor3 = Color3.fromRGB(255, 255, 127)
    })
    local gearpreviewbuy = apply(gui:AddBasic("TextButton", UDim2.new(0,50,0,25), UDim2.new(1,-85,1,-30), shoptab), {
        Text = "Buy",
        BackgroundColor3 = medium,
        Visible = false
    })
    local gearorder = gears.Module.orderedGear
    local gearassets = {}
    for i,v in next, gearorder do
        gearassets[i] = 'rbxassetid://'..gears[v].Data.Image
    end
    local indexchosen = 1
    local shopholder = gui:AddClickMenu(
        apply(
            gui:AddBasic("Frame", UDim2.new(0,250,0,100), UDim2.new(0,5,1,-105), shoptab),
            {BackgroundColor3 = medium, BackgroundTransparency = 1}
        ),{
            Type = "Image",
            Amount = #gearorder,
            Default = indexchosen,
            Sorting = {
                SortOrder = "LayoutOrder", --dont change off of it
                --FillDirection = "Horizontal",
                Type = "Grid",
                CellPadding = UDim2.new(),
                CellSize = UDim2.fromOffset(25,25)
            },
            Properties = {
                Size = UDim2.new(0,37,0,30),
                BackgroundColor3 = medium,
                ScaleType = "Fit"
            }
        },
        gearassets,
        {
            OnChange = function(self, indxclicked, btn)
                indexchosen = indxclicked

                local me = gearorder[indxclicked] 
                local data = gears[me].Data
                gearpreviewname.Text = data.Name
                gearpreviewimg.Image = 'rbxassetid://'..data.Image
                gearpreviewcost.Text = data.Price.." Coins"

                gearpreviewbuy.Visible = true
                if me == 'Random Gear' or not gears:has(me) then
                    gearpreviewbuy.Text = "Buy"
                    gearpreviewbuy.BackgroundColor3 = medium
                else
                    gearpreviewbuy.Text = "Sell"
                    gearpreviewbuy.BackgroundColor3 = redc3
                end
            end
        }
    )
    local function saferesume(thread)
        if status(thread) == 'suspended' then resume(thread) end
        return
    end
    local db
    insert(data.Connections, gearpreviewbuy.MouseButton1Click:Connect(function()
        if db then return else db = true end
        local gear = gearorder[indexchosen]
        if gears:has(gear) then
            local prev = sgear:FindFirstChild(gear)
            gears:sell(gear)
            local t = tick()
            local tmp = indexchosen
            while tick() - t < 5 and prev.Parent do wait() end
            firesignal(shopholder[tmp].MouseButton1Click)
        else
            if getstat'coins' < gears[gear].Data.Price then
                notify{Title = "Not enough coins", Text = "broke ass", Duration = 1}
                wait(1)
            elseif #sgear:GetChildren() >= 10 then
                notify{Title = "Too many gears", Text = "Trash some items first.", Duration = 1}
                wait(1)
            else
                if gear == 'Random Gear' then
                    gears:buy(gear)
                    delay(5, saferesume, running())
                    sgear.ChildAdded:Wait()
                else
                    gears:buy(gear)
                    local tmp = indexchosen
                    sgear:WaitForChild(gear, 5)
                    firesignal(shopholder[tmp].MouseButton1Click)
                end
            end
        end
        db = false
    end))

    local gachapontab = gui:AddBasic("Frame", UDim2.new(0,310,0, 250), UDim2.new(0,10,0,210), menu_shop.Frame)
    gachapontab.ClipsDescendants = true

    apply(section:Clone(), {
        Parent = gachapontab,
        Text = "Gachapon",
        Size = UDim2.new(0.8,0,0,20)
    })
    apply(gui:AddBasic("ImageLabel", UDim2.new(0,75,0,100), UDim2.new(1,-75,1,-100), gachapontab), { ScaleType = "Fit", BackgroundTransparency = 1, ImageTransparency = 0.7,ImageRectSize = Vector2.new(307, 425), Image = "rbxassetid://5163410440"})

    local function capitalizefirst(str)
        return str:sub(1,1):upper()..str:sub(2):lower()
    end
    local function countrarity(lvl)
        if not lvl then
            local new = {0,0,0,0,0}
            for i,v in next, orbs:inventory() do
                local rarity = v.Level
                new[rarity] = new[rarity] + v.Quantity
            end
            return new
        end

        local ctr = 0
        for i,v in next, orbs:inventory() do
            if v.Level == lvl then
                ctr = ctr + v.Quantity
            end
        end
        return ctr
    end

    local curorbframe = apply(gui:AddBasic("Frame", UDim2.new(0,150,0,60), UDim2.new(0,155,0,31), gachapontab), {Visible = false})
    local curorbtxt = gui:AddBasic("TextLabel", UDim2.new(1,0,0,20),nil,curorbframe)
    local curorbdesc = gui:AddBasic("TextLabel", UDim2.new(1,0,0,40),UDim2.new(0,0,0,20),curorbframe)
    curorbtxt.TextSize, curorbdesc.TextSize = 9, 9
    local gachainvswitcher = apply(gui:AddBasic("TextButton", UDim2.new(0,40,0,15), UDim2.new(0,115,0,10), gachapontab), {Text = "Rarity", TextSize = 12, BackgroundColor3 = medium})
    
    local gachadefaultinvholder = apply(gui:AddBasic("ScrollingFrame", UDim2.new(0,150,0,220), UDim2.new(0,5,0,25), gachapontab), {Name = "Default"})
    Instance.new("UIListLayout", gachadefaultinvholder).SortOrder = "LayoutOrder"
    local gacha2ndaryinvholder = apply(gachadefaultinvholder:Clone(), {Parent = gachapontab, Visible = false, Name = "Secondary"})
    gacha2ndaryinvholder.UIListLayout.SortOrder = "Name"

    local switchmenudb
    insert(data.Connections, gachainvswitcher.MouseButton1Click:Connect(function()
        if switchmenudb then return else switchmenudb = true end
        gachainvswitcher.Text = gachadefaultinvholder.Visible and "Total" or "Rarity"

        gachadefaultinvholder.Visible = not gachadefaultinvholder.Visible
        gacha2ndaryinvholder.Visible = not gacha2ndaryinvholder.Visible
        switchmenudb = false
    end))

    
    
    

    local lvnames = orbs.levelNames
    local lvcolors = orbs.orbColors
    local otypes = orbs.orbTypes
    local refreshorbui, updateorbnotif, orbnotifholder
    
    local richlvcolors = {White = torichcolor(white)}
    for i,v in next, lvcolors do richlvcolors[i] = torichcolor(lvcolors[i]) end

    local defgcbutton = apply(gui:AddBasic("TextButton", UDim2.new(1,0,0,20)), {TextSize = 12, BackgroundColor3 = medium})
    do
        local defbutton = defgcbutton --whoopps
        local defcontainer = apply(gui:AddBasic("Frame", UDim2.new(1)), {Visible = false, AutomaticSize = "Y",BackgroundTransparency = 1})
        Instance.new("UIListLayout", defcontainer) --sort by name

        

        local capitalizecache = {}

        --setup
        for i = 1, 5 do --common un rare epic leg
            local curRarity = capitalizefirst(lvnames[i])
            capitalizecache[i] = curRarity
            local indicator, frame = apply(defbutton:Clone(), {BackgroundColor3 = dark, Parent = gachadefaultinvholder, Name = i.."Label"}), apply(defcontainer:Clone(), {Visible = false, Parent = gachadefaultinvholder, Name = i})

            indicator.Text = ("<font color=%s>%s</font> <font size=\"8\">x</font><font size=\"9\">%d</font>"):format(richlvcolors[i], curRarity, 0)
            insert(data.Connections, indicator.MouseButton1Click:Connect(function()
                frame.Visible = not frame.Visible
            end))
        end

        local function updatecurorb(entry)
            curorbframe.Visible = true
            curorbtxt.Text = ("%s <font color=%s>%s</font>"):format(orbs:name(entry), richlvcolors[entry.Level], orbs:rarity(entry))
            curorbdesc.Text = orbs:description(entry)
        end

        defcontainer.UIListLayout.SortOrder = "LayoutOrder"
        defbutton.TextXAlignment = "Right"
        local gachasize = gacha2ndaryinvholder.AbsoluteSize.Y
        for i,v in next, otypes do --all orb names
            
            local name = v.Name
            local newentry = defbutton:Clone()

            apply(newentry, {
                Text = ("%s <font size=\"8\">x</font><font size=\"9\">%d</font>"):format(name, 0),
                Parent = gacha2ndaryinvholder,
                Name = name,
                TextXAlignment = "Center",
                BackgroundColor3 = dark
            })

            local newcontainer = defcontainer:Clone()
            newcontainer.Name = name.."Holder"
            for a = 1, 5 do
                local minientry = defbutton:Clone()
                minientry.Text = ("<font color=%s>%s</font> <font size=\"8\">x</font><font size=\"9\">%d</font>    "):format(richlvcolors[a], capitalizecache[a], 0)
                minientry.Name = a
                minientry.Parent = newcontainer

                local pseudoentry = {
                    OrbId = i,
                    Level = a
                }
                data.Connections[minientry] = minientry.MouseButton1Click:Connect(function()
                    updatecurorb(pseudoentry)
                end)
            end

            newentry.MouseButton1Click:Connect(function()
                newcontainer.Visible = not newcontainer.Visible
                local diffy = (newcontainer.AbsolutePosition.Y + newcontainer.AbsoluteSize.Y) - (gacha2ndaryinvholder.AbsolutePosition.Y + gachasize)
                if diffy > 0 then
                    gacha2ndaryinvholder.CanvasPosition = gacha2ndaryinvholder.CanvasPosition + Vector2.new(0,diffy)
                end
            end)
            newcontainer.Parent = gacha2ndaryinvholder
        end
        --end setup
        
        
        
        --rolls popups
        --for the notification
        do
            local basegachanotification = gui:AddNotification("Gachapon Total Rolls", {Size = UDim2.new(0,150,0,220)}, resetfunc)
            local basegachafilternotification = gui:AddNotification(("Gachapon Filtered Rolls"):format(), {Size = UDim2.new(0,150,0,220)}, resetfunc)
            gui:GetNotification("Gachapon Filtered Rolls").Object.Top.Text = ("Gachapon <font color=%s>Filtered</font> Rolls"):format(accentrich)
            --apply(gacha2ndaryinvholder:Clone(), {Visible = true, Parent = basegachanotification})
            
            apply(gacha2ndaryinvholder:Clone(), {Visible = true,Parent = basegachafilternotification, Position = UDim2.new()})
            
            --local secondary = basegachanotification.Secondary
            local secondaryfilter = basegachafilternotification.Secondary
            for i,v in next, otypes do

                local newentry = secondaryfilter[v.Name]
                local newcontainer = secondaryfilter[v.Name.."Holder"]
                insert(data.Connections, newentry.MouseButton1Click:Connect(function()
                    newcontainer.Visible = not newcontainer.Visible
                    local diffy = (newcontainer.AbsolutePosition.Y + newcontainer.AbsoluteSize.Y) - (secondaryfilter.AbsolutePosition.Y + gachasize)
                    if diffy > 0 then
                        secondaryfilter.CanvasPosition = secondaryfilter.CanvasPosition + Vector2.new(0,diffy)
                    end
                end))
            end
        end

        refreshorbui = function(soft, ui1, ui2, refreshlist)
            ui1 = ui1 or gachadefaultinvholder
            ui2 = ui2 or gacha2ndaryinvholder

            if not soft then sdata.Queued = true orbs:recache() sdata.Queued = false end
            local orbcount = countrarity()
            local defmsg = "<font color=%s>%s</font> <font size=\"8\">x</font><font size=\"9\">%d</font>"
            local defmsgrightside = defmsg.."    "

            defbutton.TextXAlignment = "Right"
            
            --update gachadefmenu
            local myquantityiszero = {}
            for i = 1, 5 do 
                --rarity labels
                ui1[i.."Label"].Text = defmsg:format(richlvcolors[i], capitalizecache[i], orbcount[i])
                local uinotfound = true
                for i,v in next, ui1[i]:GetChildren() do
                    if uinotfound and v:IsA"UIListLayout" then
                        uinotfound = false
                    else
                        myquantityiszero[v] = true
                    end
                end
                --wait() -- ~every 30
            end

            local orbssum = {}
            local orbsindiv = {}
            for i,v in next, (refreshlist or orbs:inventory()) do --update/add to default Com/Unc/Rare/Epic/Leg list
                local lv, quantity, name = v.Level, v.Quantity, orbs:name(v)

                local namebtn = ui1[lv]:FindFirstChild(name)
                if not namebtn then --if previous quantity was zero (buy/exchange)
                    namebtn = apply(defbutton:Clone(), {
                        Name = name,
                        Parent = ui1[lv]
                    })
                    data.Connections[namebtn] = namebtn.MouseButton1Click:Connect(function()
                        updatecurorb(v)
                    end)
                else
                    rawset(myquantityiszero, namebtn, nil)
                end
                namebtn.Text = defmsgrightside:format(richlvcolors[lv], name, quantity)

                --for gacha2menu
                orbssum[name] = (orbssum[name] or 0) + quantity
                orbsindiv[name] = orbsindiv[name] or {}
                orbsindiv[name][lv] = quantity
            end

            for i,v in next, myquantityiszero do --remove orbs with new quantity of 0 (ex sell/upgrade/exchange)
                if data.Connections[i] then
                    data.Connections[i]:Disconnect()
                    rawset(data.Connections, i, nil)
                end
                i:Destroy()
            end

            --update gacha2menu
            for i,v in next, orbs.orbTypes do
                local name = v.Name
                local btn = ui2[name]
                
                btn.Text = defmsg:format(richlvcolors.White, name, orbssum[name] or 0)

                local container = ui2[name.."Holder"]
                local countindiv = orbsindiv[name]
                for i = 1, 5 do
                    container[i].Text = defmsgrightside:format(richlvcolors[i], capitalizecache[i], countindiv and countindiv[i] or 0)
                end
                --if i % 6 == 0 then wait() end -- ~every 30
            end

            trash(myquantityiszero)
            trash(orbssum)
            trash(orbsindiv)
            return
        end

        orbnotifholder = gui:GetNotification"Gachapon Filtered Rolls".Body.Secondary
        for i,v in next, orbnotifholder:GetChildren() do
            if v.Name:find"Holder$" then
                v.Size = UDim2.new(1)
                v.AutomaticSize = "Y"
            end
        end
        updateorbnotif = function(tbl)
            for i,v in next, orbnotifholder:GetChildren() do
                if not v:IsA"UIListLayout" then
                    v.Visible = false
                    if v.Name:find"Holder$" then
                        for i = 1, 5 do v[i].Visible = false end
                    end
                end
            end
            local counter = {}
            for i,orb in next, tbl do
                local name, quant, lv = orbs:name(orb), orb.Quantity, orb.Level
                counter[name] = (counter[name] or 0) + quant
                local me = orbnotifholder[name.."Holder"]
                me[lv].Text = ("<font color=%s>%s</font> <font size=\"8\">x</font><font size=\"9\">%d</font>    "):format(richlvcolors[lv], capitalizecache[lv], quant)
                me[lv].Visible = true
                me.Visible = true
            end
            for i,v in next, counter do
                local cur = orbnotifholder[i]
                cur.Text = ("<font color=%s>%s</font> <font size=\"8\">x</font><font size=\"9\">%d</font>"):format(richlvcolors.White, i, v)
                cur.Visible = true
            end
        end
        
    end
    defer(refreshorbui)

    do
        local forceorbupd = apply(gui:AddBasic("TextButton", UDim2.new(0,70,0,15), UDim2.new(1,-75,0,5), gachapontab), {
            Text = "ForceUpdate",
            TextSize = 10,
            BackgroundColor3 = dark
        })
        local t = tick()
        insert(data.Connections, forceorbupd.MouseButton1Click:Connect(function()
            if sdata.Queued or tick() - t < 2 then return end
            t = -inf
            refreshorbui()
            notify{Title = "Force Update", Text = "Orbs have been recached", Duration = 1}
            t = tick()
        end))
    end

    local function resultsinsert(towhere, buy5)
        for i,v in next, (buy5 and orbs:buy5() or orbs:buy1()) do
            insert(towhere, v)
        end
        return towhere
    end
    local function buyorbs(n)
        n = floor(n)
        if n > 250 or n < 1 then return false, "You can only buy orbs in the range 1-250"
        else
            local coins, cost = getstat'coins', n * 1000
            if coins < cost then return false, ("Need %d more coins to purchase %d orbs"):format(cost - coins, n) end
        end

        local num5s = floor(n/5)
        local num1s = n % 5

        local queuelast --this one will not be spawn()'d, and the server handles these linearly so once it's done every other one was finished too
        if num1s == 0 then
            queuelast = true
            num5s = num5s - 1
        else
            queuelast = false
            num1s = num1s - 1
        end

        local neworbs = {}
        for i = 1, num5s do
            spawn(resultsinsert, neworbs, true)
            --if i % 5 == 0 then wait() end --idk maybe your pc sucks
        end
        for i = 1, num1s do
            spawn(resultsinsert, neworbs, false)
        end

        resultsinsert(neworbs, queuelast)-- final one, yields async
        refreshorbui(true) --no :recache()

        return neworbs
    end

    local nanmt = {__index = function() return 0/0 end}
    local function buyorbswithfilter(filter, oneatatime, maxtries) -- success = {orbtbl}, fail = false, "message"
        local coins, cost = getstat'coins', maxtries * 1000
        if cost > coins then return false, ("Need %d more coins to afford the worst-case num. of uses (%d)"):format(cost - coins, maxtries) end
        
        local invert = setmetatable({[-1] = {}}, nanmt)
        for i,v in next, filter do
            if v.OrbId == -1 then
                invert[-1][v.Level] = true
            else
                invert[v.OrbId] = v.Level
            end
        end

        local tries = 0
        if not oneatatime then
            while floor(maxtries / 5) > 0 do
                maxtries = maxtries - 5
                tries = tries + 5

                
                local winners = {}
                for i,v in next, orbs:buy5() do
                    if invert[-1]
                    [v.Level]
                    or v.Level >= invert[v.OrbId] then --if orb is in "Any" rarity or if rarity >= filtered value (invert[v.OrbId] for nil -> inf, meaning unfiltered orbs wont fall thru)
                        insert(winners, v)
                    end
                end
                if #winners > 0 then --get5 adds to list because there could be multiple filter matches in the group of 5
                    trash(invert, nil, true)
                    refreshorbui(true)
                    return winners, tries
                end
            end
        end
        for i = 1, maxtries do
            tries = tries + 1

            local try = orbs:buy1()[1]
            if invert[-1]
            [try.Level]
            or try.Level >= invert[try.OrbId] then --if orb is in "Any" rarity or if rarity >= filtered value (invert[v.OrbId] for nil -> inf, meaning unfiltered orbs wont fall thru)
                trash(invert, nil, true)
                refreshorbui(true)
                return { try }, tries
            end
        end
        
        trash(invert, nil, true)
        refreshorbui(true)
        
        return false, "Failed to find match with given orb filter"
    end

    local gachaponrollertab = gui:AddBasic("Frame", UDim2.new(0,100,0, 60), UDim2.new(0,170,0,375), menu_shop.Frame) --resizes to 90 with CONFIRM if rolls > 50
    defuill:Clone().Parent = gachaponrollertab

    apply(section:Clone(), {
        Parent = gachaponrollertab,
        Text = "Auto-Roll",
        Size = UDim2.new(0.8,0,0,20)
    })

    local numrollsinput = apply(gui:AddBasic("TextBox", UDim2.new(1,0,0,20), nil, gachaponrollertab), {
        Text = '',
        PlaceholderText = "[ 1-250 ]",
        TextSize = 12,
        BackgroundColor3 = dark
    })
    local requireconfirminput = apply(gui:AddBasic("TextBox", UDim2.new(1,0,0,20), nil, gachaponrollertab), {
        Text = "",
        PlaceholderText = "type [ CONFIRM ]",
        BackgroundColor3 = dark,
        TextSize = 10 ,
        Visible = false
    })
    local sendrollsbutton = apply(gui:AddBasic("TextButton", UDim2.new(1,0,0,20), nil, gachaponrollertab), {
        Text = "Begin",
        TextSize = 12,
        BackgroundColor3 = medium,
        Visible = true
    })
    local lastnum = 0
    insert(data.Connections, numrollsinput.Focused:Connect(function()
        requireconfirminput.Text = ""
        requireconfirminput.Visible = false
    end))
    
    insert(data.Connections, numrollsinput.FocusLost:Connect(function()
        local response = tonumber(numrollsinput.Text)
        if not (response and (response < inf or response == inf)) then numrollsinput.Text = "" return end
        lastnum = floor(clamp(response, 1, 250))
        numrollsinput.Text = lastnum

        requireconfirminput.Visible = lastnum >= 50
    end))
    insert(data.Connections, requireconfirminput.FocusLost:Connect(function() 
        local msg = requireconfirminput.Text:gsub("%s", ""):upper()
        requireconfirminput.Text = msg == 'CONFIRM' and msg or ""
    end))
    local sendrolldb = tick()-0.5
    local sendrollprocessing = false
    
    local filter = options.OrbFilter or {}
    options.OrbFilter = filter
    
    insert(data.Connections, sendrollsbutton.MouseButton1Click:Connect(function()
        if sendrollprocessing or tick() - sendrolldb < 0.5 then
            return
        elseif lastnum >= 50 and requireconfirminput.Text ~= "CONFIRM" then
            sendrolldb = tick()
            notify{Title = "Gamble Error", Text = "Please type CONFIRM in the given input to continue.", Duration = 1}
            return
        end
        sendrollprocessing = true
        sdata.Queued = true

        requireconfirminput.Text = ""
        --requireconfirminput.Visible = false

        
        if next(filter) then --if at least 1 value in filter
            local response, message = buyorbswithfilter(filter, false, lastnum)
            sendrollprocessing = false
            sdata.Queued = false
            sendrolldb = tick()

            if not response then
                notify{Title = "Gamble Error", Text = message, Duration = 3}
                return
            else
                notify{Title = "Filter Accepted", Text = ("Found orb match(es) in %d tries"):format(message), Duration = 3}
            end

            --refreshorbui(true)
            updateorbnotif(response)
            orbnotifholder.Parent = gui:GetNotification"Gachapon Filtered Rolls".Body
            gui:ToggleNotification("Gachapon Filtered Rolls", true)
        else
            local resp, msg = buyorbs(lastnum)
            sendrollprocessing = false
            sdata.Queued = false
            sendrolldb = tick()

            if not resp then
                notify{Title = "Gamble Error", Text = msg, Duration = 1}
                return
            end
            updateorbnotif(resp)
            
            

            orbnotifholder.Parent = gui:GetNotification"Gachapon Total Rolls".Body
            gui:ToggleNotification("Gachapon Total Rolls", true)
        end
    end))

    
    

    local removefromfilter
    local function addtofilter(id, level)
        if id == -1 then --"any" category
            filter["-1 "..level] = {
                OrbId = id,
                Level = level
            }
            return
        end

        for i = 1, 5 do
            removefromfilter(id, i)
        end
        filter[id.." "..level] = {
            OrbId = id,
            Level = level
        }
        return
    end
    removefromfilter = function(id, level)
        local key = id.." "..level
        if not filter[key] then return end
        
        trash(filter[key])
        rawset(filter, key, nil)
    end

    local gachafiltertab = gui:AddBasic("Frame", UDim2.new(0,380,0, 120), UDim2.new(0,5,0,465), menu_shop.Frame)
    
    apply(section:Clone(), {
        Parent = gachafiltertab,
        Text = "Orb Filter",

        Size = UDim2.new(0.8,0,0,20)
    })
    local gftype, gflvl = 1, 1 --auto heal common default
    local gachafiltertype = apply(gui:AddBasic("TextBox", UDim2.new(0,120,0,20), UDim2.new(0,5,0,30), gachafiltertab), {
        Text = "Auto-Heal",
        PlaceholderText = "Orb Type",
        BackgroundColor3 = dark,
        TextSize = 12
    })

    local gachafilterlevel = apply(gui:AddBasic("TextBox", UDim2.new(0,120,0,20), UDim2.new(0,125,0,30), gachafiltertab), {
        Text = "COMMON",
        PlaceholderText = "Orb Rarity ( >= )",
        BackgroundColor3 = dark,
        TextSize = 12
    })

    local function invert(ls)
        local new = {}
        for i,v in next, ls do new[v] = i end
        return new
    end
    do
        local orbnames = {"(Any)"}
        for i,v in next, otypes do if not v.Name:find"^Witch" then insert(orbnames, v.Name) end end
        gui:AddSearchDropdown(gachafiltertype, {
            Size = UDim2.new(1,0,0,60),
            Color = medium,
            SortOrder = "Name",
            ChoiceSize = UDim2.new(1,0,0,20)
        }, orbnames, {
            OnChange = function(self, new)
                gftype = new == "(Any)" and -1 or orbs[new].OrbId
            end
        })

        local reversedlvnames = invert(lvnames)
        gui:AddSearchDropdown(gachafilterlevel, {
            Size = UDim2.new(1,0,0,60),
            Color = medium,
            ChoiceSize = UDim2.new(1,0,0,20),
            SortOrder = "LayoutOrder"
        }, lvnames, {
            OnChange = function(self, new)
                gflvl = reversedlvnames[new]
            end
        })
        
    end

    local gachafilteradd = apply(gui:AddBasic("TextButton", UDim2.new(0,120,0,20), UDim2.new(0,245,0,30), gachafiltertab), {
        Text = "Add Filter",
        TextSize = 12,
        BackgroundColor3 = medium
    })
    
    

    local gachafilternotif
    do
        local defbutton = apply(gui:AddBasic("TextButton", UDim2.new(1,0,0,25)), {
            TextSize = 12
        })
        local defmsg = "%s\n<font color=%s>%s</font> or >"
        local anymsg = "Anything <font color=%s>%s</font>"
        gachafilternotif = gui:AddNotification("RClick = remove", {Size = UDim2.fromOffset(150,220)}, {
            OnOpen = function(self)
                local scroller = self.Scroll
                for i,v in next, scroller:GetChildren() do
                    if not (v:IsA"UIListLayout" or v.Name == 'ClickBlocker') then
                        v:Destroy()
                        data.Connections[v]:Disconnect()
                        rawset(data.Connections, v, nil)
                    end
                end
                for i,v in next, filter do
                    local new = defbutton:Clone()
                    if v.OrbId == -1 then
                        new.Text = anymsg:format(richlvcolors[v.Level], orbs:rarity(v))
                    else
                        new.Text = defmsg:format(orbs:name(v), richlvcolors[v.Level], orbs:rarity(v))
                    end
                    data.Connections[new] = new.MouseButton2Click:Connect(function()
                        new:Destroy()
                        data.Connections[new]:Disconnect()
                        rawset(data.Connections, new, nil)

                        removefromfilter(v.OrbId, v.Level)
                    end)
                    new.Parent = scroller
                end
            end
        })
        
        defuill:Clone().Parent = apply(gui:AddBasic("ScrollingFrame", UDim2.new(1,0,1,0), nil, gachafilternotif), {Name = "Scroll"})
        
        local notif = gui:GetNotification("RClick = remove")
        insert(data.Connections, gachafilteradd.MouseButton1Click:Connect(function()
            addtofilter(gftype, gflvl)
            notif.funcs.OnOpen(notif.Body)
        end))
    end
    local gachashowfilter = apply(gui:AddBasic("TextButton", UDim2.new(0,120,0,20), UDim2.new(0,245,0,50), gachafiltertab), {
        Text = "Show Filter",
        TextSize = 12,
        BackgroundColor3 = dark
    })
    gachashowfilter.MouseButton1Click:Connect(function()
        gui:ToggleNotification("RClick = remove", true)
    end)

end


menu_playerstats = gui:AddMenu("Players", unpackc3(options.MenuColors.Players) or Color3.fromRGB(252, 81, 152), 0, 370)
do
    local plrpicktab = gui:AddBasic("ScrollingFrame", UDim2.new(0,150,0, 225), UDim2.new(0,10,0,10), menu_playerstats.Frame)
    local defuill = apply(defuill:Clone(), {SortOrder = "Name"})
    defuill:Clone().Parent = plrpicktab
    local plrbloxtab = gui:AddBasic("ScrollingFrame", UDim2.new(0,380,0,240), UDim2.new(0,10,0,500), menu_playerstats.Frame) --plr (150), damage (70), blox (70), br diff(45), weekly br diff(45)
    apply(defuill:Clone(), {Parent = plrbloxtab, SortOrder = "LayoutOrder", FillDirection = "Horizontal"})

    local tablestaticdescriptions = gui:AddBasic("Frame", UDim2.new(0,229,0,20), UDim2.new(0,161,0,479), menu_playerstats.Frame)
    apply(defuill:Clone(), {Parent = tablestaticdescriptions, SortOrder = "LayoutOrder", FillDirection = "Horizontal"})
    local plrbloxnamesection = gui:Name(gui:AddBasic("Frame", UDim2.new(0,150,1), nil, plrbloxtab), "Name")

    local plrbloxdamagesection = gui:Name(gui:AddBasic("Frame", UDim2.new(0,70,1),nil,plrbloxtab), "Damage")
    apply(gui:AddBasic("TextLabel", plrbloxdamagesection.Size,nil, tablestaticdescriptions), {
        TextSize = 12,
        Text = "Damage"
    })
    local plrbloxexpsection = gui:Name(gui:AddBasic("Frame", UDim2.new(0,70,1), nil, plrbloxtab), "Bloxxer")
    apply(gui:AddBasic("TextLabel", plrbloxexpsection.Size,nil, tablestaticdescriptions), {
        TextSize = 12,
        Text = "Blox"
    })
    local plrbloxbrsection = gui:Name(gui:AddBasic("Frame", UDim2.new(0,45,1),nil,plrbloxtab), "Ratio")
    apply(gui:AddBasic("TextLabel", plrbloxbrsection.Size,nil, tablestaticdescriptions), {
        TextSize = 12,
        Text = "+BR"
    })
    local plrbloxweeklybrsection = gui:Name(gui:AddBasic("Frame", UDim2.new(0,45,1),nil,plrbloxtab), "WeeklyRatio")
    apply(gui:AddBasic("TextLabel", plrbloxweeklybrsection.Size,nil, tablestaticdescriptions), {
        TextSize = 12,
        Text = "+WBR"
    })
    for i,v in next, plrbloxtab:GetChildren() do if v:IsA"Frame" then defuill:Clone().Parent = v end end

    local accent = menu_playerstats.Accent
    local accentrich = torichcolor(accent)

    apply(section:Clone(), {
        Parent = maintab,
        Text = "Stats Viewer"
    })
    local defplrbtn = gui:AddImgToText(apply(gui:AddBasic("TextButton", UDim2.new(1,0,0,25)), {Text = "( Player )", TextSize = 12}), '', false) --deplrbtn... .RealText.Text .Icon.Image __newindex
    local defplrlbl = gui:AddImgToText(apply(gui:AddBasic("TextLabel", UDim2.new(1,0,0,25)), {Text = "( Player )", TextSize = 12}), '', false)
    local ttype, tsize = Enum.ThumbnailType.HeadShot, Enum.ThumbnailSize.Size48x48
    
    local updateplayertext --function

    local modes =  {{'blox', 'total survs'} , {'hc blox', 'hc survs'}, {'weekly blox', 'weekly survs'}, {'weekly hc blox', 'weekly hc survs'}}

    local default = rs.Info.Gamemode.Value ~= "Hardcore" and 1 or 2
    local function calcbr(plr, mode)
        mode = mode and modes[mode] or modes[default]

        local blox, survs = getstat(mode[1], plr), getstat(mode[2], plr)
        if not (blox and survs) then return false end
        return tonumber(tostring(blox/max(survs, 1)):match"^%d*%.?%d?%d?")
    end
    
    local plrstatstab = gui:AddBasic("Frame", UDim2.new(0,225,0,465), UDim2.new(0,160, 0, 10), menu_playerstats.Frame)
    local plrnameholder = apply(gui:AddBasic("TextLabel", UDim2.new(1,0,0,25), nil, plrstatstab), {TextSize = 12})
    local plrstatsholder = apply(plrnameholder:Clone(), {
        Size = UDim2.new(1,0,1,0),
        Parent = gui:AddBasic("Frame", UDim2.new(1,0,1,-25), UDim2.new(0,0,0,25), plrstatstab)
    })

    local round = math.round --out of locals oops
    local function commas(num) --only positives Affects the area around your character where you control part physics. Having this set higher will help with physics-based exploits, but can cause performance lag.\n\nWhen off, roblox fluctuates this value to avoid frame-drops.
        if not typeof(num) == 'number' then return "?" end
        local decimal = round(abs(num % 1) * 1e2)
        num = floor(num)
        local result = tostring(num):reverse():gsub("(%d%d%d)", "%1,"):reverse():gsub("^,", "")
        return decimal > 0 and result.."."..round(decimal) or result
    end

    local tracking =  {} --not shared

    local defplrbloxlbl = apply(gui:AddBasic("TextLabel", UDim2.new(1,0,0,25)), {TextSize = 12, Text = ""})
    local nameformat = "<font color="..accentrich..">%s</font> <font size=\"10\">@%s</font>"
    
    local startingbloxes = shareddata.StartingBloxes or {}
    shareddata.StartingBloxes = startingbloxes

    local sessionbloxpopups = {}
    local function updatesessionblox(plr, dmgoff)
        local blox, popup = tracking[plr] and tracking[plr].LastBlox, sessionbloxpopups[plr]
        if not (blox and popup) then return end
        local stuff = startingbloxes[plr]
        popup.Text = (popup.Text:gsub("[%?%d,]+", "%%s")):format(commas(stuff.Damage + (dmgoff or 0)), commas(stuff.Blox))
    end
    local function addplrinfo(player)
        if plrstatstab:FindFirstChild(player.Name) then warn("Had already found player "..tostring(player)) return end
        local pname = player.Name
        local new = defplrbtn:Clone()
        new.Name = pname
        new.RealText.Text = nameformat:format(player.DisplayName, pname)
        data.Connections[new] = new.MouseButton1Click:Connect(function()
            updateplayertext(player)
        end)
        new.Parent = plrpicktab

        local newpblox = defplrlbl:Clone()
        newpblox.Name = pname
        newpblox.RealText.Text = nameformat:format(player.DisplayName, pname)
        newpblox.Parent = plrbloxnamesection

        local defbloxinput = defplrbloxlbl:Clone()
        defbloxinput.Name = pname
        for i,v in next, plrbloxtab:GetChildren() do
            if v:IsA"Frame" and v ~= plrbloxnamesection then defbloxinput:Clone().Parent = v end
        end
        

        tracking[player] = {
            DamageDealtAfterRoundStart = 0,
            LastBlox = getstat(modes[default][1], player) or 0, --use modes[deafult] instead
            LastBr = calcbr(player, default) or 0,
            LastWklyBr = calcbr(player, default+2) or 0
        }
        sessionbloxpopups[player] = gui:MakePopup(newpblox, apply(gui:DefaultPopup("Session Damage: ?\nSession Blox: ?"), { BackgroundTransparency = settings.Looks.PopupTransparency, Size = UDim2.new(0,120,0,50) }), { FollowMouse = true })
        startingbloxes[player] = startingbloxes[player] or { Blox = 0, Damage = 0 }
        updatesessionblox(player)
        

        local icon = plrs:GetUserThumbnailAsync(player.UserId, ttype, tsize) --yields
        new.Icon.Image = icon
        newpblox.Icon.Image = icon
        
    end
    local function remplrinfo(player)
        local pdata = tracking[player]
        if pdata then
            rawset(tracking, player, nil)
            rawset(startingbloxes, player, nil)
            trash(pdata)
        end
        local name = player.Name
        for i,v in next, plrbloxtab:GetChildren() do
            local try = v:FindFirstChild(name)
            if try then try:Destroy() end
        end
        local info = plrpicktab:FindFirstChild(name)
        if not info then return end
        data.Connections[info]:Disconnect()
        rawset(data.Connections, info, nil)
        info:Destroy()
    end

    
    local function getwinratio(player)
        local total = getstat('total rounds', player)
        local s1, s2 = getstat('total survs', player), getstat('hc survs', player)
        if not (player and s1 and s2) then return -0.69 end
        return (s1+s2)/total
    end
    
    local defaulttxt = [[
        
<font size="14">All-Time:</font>
<font color="rgb(252, 81, 152)">Total Rounds</font>: %s : %s%%
<font color="rgb(252, 81, 152)">Standard Survivals</font>: %s
<font color="rgb(252, 81, 152)">Hardcore Survivals</font>: %s
<font color="rgb(252, 81, 152)">LOS</font>: %s

<font color="rgb(252, 81, 152)">Total Coins Earned</font>: %s
<font color="rgb(252, 81, 152)">Total Memos Collected</font>: %s
<font color="rgb(252, 81, 152)">Total Gachapon Rolls</font>: %s

<font color="rgb(252, 81, 152)">Best Streak (Standard)</font>: %s
<font color="rgb(252, 81, 152)">Best Streak (Hardcore)</font>: %s
<font color="rgb(252, 81, 152)">Best Streak (Standard, Paci)</font>: %s
<font color="rgb(252, 81, 152)">Best Streak (Hardcore, Paci)</font>: %s
            
<font color="rgb(252, 81, 152)">Standard Bloxxer</font>: %s : %s
<font color="rgb(252, 81, 152)">Hardcore Bloxxer</font>: %s : %s
<font color="rgb(252, 81, 152)">Current Standard SR</font>: %s (%s pb)
<font color="rgb(252, 81, 152)">Current Hardcore SR</font>: %s (%s pb)

<font size="14">Weekly:</font>
<font color="rgb(252, 81, 152)">Standard Survivals</font>: %s
<font color="rgb(252, 81, 152)">Hardcore Survivals</font>: %s
<font color="rgb(252, 81, 152)">Best Streak (Standard)</font>: %s
<font color="rgb(252, 81, 152)">Best Streak (Hardcore)</font>: %s
<font color="rgb(252, 81, 152)">Best Streak (Standard, Paci)</font>: %s
<font color="rgb(252, 81, 152)">Best Streak (Hardcore, Paci)</font>: %s

<font color="rgb(252, 81, 152)">Standard Bloxxer</font>: %s : %s
<font color="rgb(252, 81, 152)">Hardcore Bloxxer</font>: %s : %s
]]
    defaulttxt = defaulttxt:gsub('"rgb%(252, 81, 152%)"', torichcolor(accent))
    plrstatsholder.TextYAlignment = "Top"
    updateplayertext = function(plr)
        plrnameholder.Text = plrpicktab[plr.Name].RealText.Text
        plrstatsholder.Text = (defaulttxt):format(
    commas(getstat('total rounds', plr)),
    floor(getwinratio(plr) * 100),
    commas(getstat('total survs', plr)),
    commas(getstat('hc survs', plr)),
    commas(getstat('los', plr)),
    commas(getstat('total coins', plr)),
    commas(getstat('memos', plr)),
    commas(getstat("gambles", plr)),
    commas(getstat("pb", plr)),
    commas(getstat("hc pb", plr)),
    commas(getstat('paci pb', plr)),
    commas(getstat('hc paci pb', plr)),
    commas(getstat('blox', plr)),
    calcbr(plr, 1) or "?",
    commas(getstat('hc blox', plr)),
    calcbr(plr, 2) or "?",
    commas(getstat('sr', plr)),
    commas(getstat('pb sr', plr)),
    commas(getstat("hc sr", plr)),
    commas(getstat("pb hc sr", plr)),
    commas(getstat("weekly survs", plr)),
    commas(getstat("weekly hc survs", plr)),
    commas(getstat("weekly pb", plr)),
    commas(getstat("weekly hc pb", plr)),
    commas(getstat("weekly paci pb", plr)),
    commas(getstat("weekly hc paci pb", plr)),
    commas(getstat("weekly blox", plr)),
    calcbr(plr, 3) or "?",
    commas(getstat("weekly hc blox", plr)),
    calcbr(plr, 4) or "?"
)
    end
    insert(data.Functions, {stepper:Add(plrs, "PlayerAdded", "OnPlayerJoinStatAdd", addplrinfo)})
    insert(data.Functions, {stepper:Add(plrs, "PlayerRemoving", "OnPlayerJoinStatRem", remplrinfo)})
    for i,v in next, plrs:GetPlayers() do delay(0, addplrinfo, v) end

    delay(0.2, updateplayertext, lp)

    local gold = Color3.fromRGB(250, 181, 7)
    local function setsectionmvp(section, plr)
        plr = tostring(plr)
        for i,v in next, plrbloxtab[section]:GetChildren() do
            if v:IsA"TextLabel" then v.BackgroundColor3 = tostring(v) == plr and gold or light  end
        end
    end
    local function resetbloxview()
        for i,v in next, plrbloxdamagesection:GetChildren() do if v:IsA"TextLabel" then v.BackgroundColor3 = light v.Text = '0' end end
        for i,v in next, plrbloxexpsection:GetChildren() do if v:IsA"TextLabel" then v.BackgroundColor3 = light v.Text = '' end end
        for i,v in next, plrbloxbrsection:GetChildren() do if v:IsA"TextLabel" then v.BackgroundColor3 = light v.Text = '' end end
        for i,v in next, plrbloxweeklybrsection:GetChildren() do if v:IsA"TextLabel" then v.BackgroundColor3 = light v.Text = '' end end
    end
    local function updatebloxsection(section, plr, num, treatAsDifference) --treatasdifference will use colors and +/- indicator
        local path = plrbloxtab[section]:FindFirstChild(tostring(plr))
        if not path then return end
        local negative = num < 0 
        local nonzero = num ~= 0
        num = commas(abs(num))
        if treatAsDifference then
            if negative then
                path.TextColor3 = redc3
                path.Text = "-"..num
                return
            elseif nonzero then
                path.TextColor3 = greenc3
                path.Text = "+"..num
                return
            end
        end
        path.TextColor3 = white
        path.Text = num
        return
    end
    local inf = 1/0
    insert(data.Functions, {stepper:Add(rs.Info.Running, "Changed", "RoundAnalysis", function(value)
        if value then --new round
            for i,v in next, tracking do
                v.DamageDealtAfterRoundStart = 0
            end
            resetbloxview()
            return
        end
        wait(3) --give server a little bit of time to update (rather wait arbitrarily than make 8*18 .Changed connections (blox+survs for std,hc,week std, week hc))
        local topeach = {
            Damage = lp,
            Bloxxer = lp,
            Ratio = lp, -- highest br (not biggest diff)
            WeeklyRatio = lp -- highest br
        }
        local topeachnumcache = {
            BloxDiff = -inf,
            BrDiff = -inf,
            WeeklyBrDiff = -inf
        }
        
        for i,v in next, tracking do
            local session = startingbloxes[i]

            local newblox = getstat(modes[default][1], i) or 0
            local bdiff = newblox - v.LastBlox
            session.Blox = session.Blox + bdiff
            session.Damage = session.Damage + v.DamageDealtAfterRoundStart
            updatesessionblox(i)

            if bdiff > topeachnumcache.BloxDiff then
                topeach.Bloxxer = i
                topeachnumcache.BloxDiff = newblox - v.LastBlox
            end
            
            updatebloxsection("Bloxxer", i, newblox - v.LastBlox, false) --last param docolors t/f
            v.LastBlox = newblox
            --
            local newbr = calcbr(i, default) or 0
            if newbr - v.LastBr > topeachnumcache.BrDiff then
                topeach.Ratio = i
                topeachnumcache.BrDiff = newbr - v.LastBr
            end

            updatebloxsection("Ratio", i, newbr - v.LastBr, true)
            v.LastBr = newbr
            --
            local newwklybr = calcbr(i, default+2) or 0
            if newwklybr - v.LastWklyBr > topeachnumcache.WeeklyBrDiff then
                topeach.WeeklyRatio = i
                topeachnumcache.WeeklyBrDiff = newwklybr - v.LastWklyBr
            end

            updatebloxsection("WeeklyRatio", i, newwklybr - v.LastWklyBr, true)
            v.LastWklyBr = newwklybr
            --
            if v.DamageDealtAfterRoundStart > tracking[topeach.Damage].DamageDealtAfterRoundStart then topeach.Damage = i end
        end
        foreachin(topeach, setsectionmvp)
        trash(topeach)
        trash(topeachnumcache)
    end)})
    insert(data.Functions, { stepper:Add(rs.Info.Timer, "Changed", "DamageUpdate", function()
        for i,v in next, tracking do
            updatebloxsection("Damage", i, v.DamageDealtAfterRoundStart, false)
            updatesessionblox(i, v.DamageDealtAfterRoundStart)
        end
    end) })
    insert(data.Functions, { stepper:Add(disasters, "DescendantAdded", "DamageGet", function(d)
        if not (d:IsA"ObjectValue" and d.Parent and d.Parent:IsA"Humanoid") then
            return
        end
        local player = d.Value and tracking[d.Value]
        if not player then --mightve been an npc
            --warn("No tracked entry for player: "..tostring(player))
            return
        end
        player.DamageDealtAfterRoundStart = player.DamageDealtAfterRoundStart + tonumber(tostring(d))
    end, nil, true)})
end


menu_cycle = gui:AddMenu("Cycle", unpackc3(options.MenuColors.Cycle) or Color3.fromRGB(209, 237, 50), 0, 65)
do
    local accent = menu_cycle.Accent
    local accentrich = torichcolor(accent)

    local fdata = {}
    data.Functions.Gears = fdata
    
    local gendata = {}
    fdata.General = gendata

    local cycletracker = require("bell/sd2/cycle", true)
    cycletracker.NotifyCycleReset = options.NotifyCycleReset
    local trackcyclenotify = apply(defbutton:Clone(), {
        Parent = menu_cycle.Frame,
        Position = UDim2.new(0.5,-84,0,10),
        Size = UDim2.new(0,168.75,0,20),
        Name = 'NotifyCycleReset'
    })
    gui:MakePopup(apply(popupbox:Clone(), { Parent = trackcyclenotify }), apply(gui:DefaultPopup"Tracks what disasters have 'passed' in the server's list of possible disasters", { BackgroundTransparency = settings.Looks.PopupTransparency, Size = UDim2.new(0,140,0,30) }), { FollowMouse = true })
    apply(trackcyclenotify.RealText, {
        Text = "<font color="..blue..">  Notify Cycle Reset</font>",
        TextSize = 13,
        Size = UDim2.new(1, -20, 0, 20) --upd for button
    })
    gendata.NotifyCycleReset = {
        On = function()
            options.NotifyCycleReset = true
            cycletracker.NotifyCycleReset = true
            trackcyclenotify.Button.BackgroundColor3 = accent
        end,
        Off = function()
            options.NotifyCycleReset = false
            cycletracker.NotifyCycleReset = false
            trackcyclenotify.Button.BackgroundColor3 = dark
        end
    }
    gui:BindToggleClick(trackcyclenotify.Button, gendata.NotifyCycleReset, options.NotifyCycleReset)

    cycletracker.Body.Position = UDim2.new(0,50,0,35)
    cycletracker.Body.Parent = menu_cycle.Frame
end
menu_miscellaneous = gui:AddMenu("Miscellaneous", unpackc3(options.MenuColors.Miscellaneous) or Color3.fromRGB(213, 48, 50))
do
    local maintab = gui:AddBasic("Frame", UDim2.new(0,187.5,0, 140), UDim2.new(0,10,0,10), menu_miscellaneous.Frame)
    local righttab = gui:AddBasic("Frame", UDim2.new(0,187.5,0, 215), UDim2.new(1,-197.5,0,85), menu_miscellaneous.Frame)
    local accent = menu_miscellaneous.Frame:FindFirstChild"Accent".Value

    local colorkey = gui:AddBasic("Frame", UDim2.new(0,187.5,0,70), UDim2.new(1,-197.5,0,10), menu_miscellaneous.Frame)
    apply(gui:AddBasic("TextLabel", UDim2.new(0.95,0,1, -25), UDim2.new(0.05,0,0,25), colorkey), {TextSize = 12, BorderSizePixel = 0, TextXAlignment = "Left", TextYAlignment = "Top",
        Text = ("<font color=%s> Red</font> - Tracers<font color=%s>\nGreen</font> - Specialized\n<font color=%s>Blue</font> - Other"):format(red, green, blue)
    })
    
    section:Clone().Parent = colorkey
    apply(section:Clone(), {
        Parent = maintab,
        Text = "Miscellaneous"
    })
    
    apply(section:Clone(), {
        Parent = righttab,
        Text = "Disasters"
    })
    local miscdata = {}
    data.Functions.Miscellaneous = miscdata
    local mischolder = apply(gui:AddBasic("Frame", UDim2.new(0.9,0,0,100), UDim2.new(0.05,0,0,25), maintab), {
        Name = "Miscellaneous",
        --BorderColor3 = white
    })
    defuill:Clone().Parent = mischolder
    
    local minimapper = apply(defbutton:Clone(), {
        Parent = mischolder,
        Name = 'Minimap'
    })
    gui:MakePopup(apply(popupbox:Clone(), { Parent = minimapper }), apply(gui:DefaultPopup"Generates a minimap of the world", { BackgroundTransparency = settings.Looks.PopupTransparency, Size = UDim2.new(0,90,0,35) }), { FollowMouse = true })

    apply(minimapper.RealText, {
        Text = "<font color="..blue..">  Minimap</font>",
        Size = UDim2.new(1, -40, 0, 20) --upd for button
    })
    
    miscdata.Minimapper = {
        On = function()
            options.Minimapper = true
            minimap:Start()
            minimapper.Button.BackgroundColor3 = accent
        end,
        Off = function()
            options.Minimapper = false
            minimap:Stop()
            minimapper.Button.BackgroundColor3 = dark
        end
    }
    gui:BindToggleClick(minimapper.Button, miscdata.Minimapper, options.Minimapper)
    local mmcommandassign = {
        You = "None"
    }
    gui:AddRadioButtons(
        {Parent = minimapper, Position = UDim2.new(0,21,0,21), Size = UDim2.new(1,-21,0,40)},
        {Size = UDim2.new(0.5,0,0,20), StartsFrom = nil, Background = medium, Default = options.MinimapperFilter or 1, RightSide = false, TextSize = 12, SortingOpt = apply(Instance.new"UIGridLayout", { SortOrder = "LayoutOrder", CellSize = UDim2.new(0.5,0,0,20), CellPadding = UDim2.new()})},
        {
            "All",
            "You",
            "Players",
            "NPCs"
        },
        function(type, index)
            options.MinimapperFilter = index
            minimap:Track(mmcommandassign[type] or type)
        end)
        
    gui:AddBasic("Frame", UDim2.new(0.8,0,0,40), nil, mischolder).BackgroundTransparency = 1
    local autofarm = apply(defbutton:Clone(), {
        Parent = mischolder,
        Name = 'Autofarm'
    })
    gui:MakePopup(apply(popupbox:Clone(), { Parent = autofarm }), apply(gui:DefaultPopup"An autofarm.\n If you have pizza purchased, it will eat it.", { BackgroundTransparency = settings.Looks.PopupTransparency, Size = UDim2.new(0,140,0,35) }), { FollowMouse = true })

    apply(autofarm.RealText, {
        Text = "<font color="..green..">  Autofarm</font>",
        Size = UDim2.new(1, -40, 0, 20) --upd for button
    })
    local afk = loadfile("bell/sd2/autofarm.lua")
    local unafk = function()
        pcall(game.Destroy, workspace:FindFirstChild"afker")
    end
     
    insert(data.Functions, {stepper:Add(lp, "CharacterAdded", "AutofarmPizza", function(c)
        if not (options.Autofarm and wait(2) and lp.Backpack:WaitForChild("Pizza", 5)) then return end
        lp.Backpack["Pizza"].Parent = c
    end, nil, true)} )
    local overridemedkitfireparams = {Name = 'Begin'}
    insert(data.Functions, {stepper:Add(game["Run Service"], "Heartbeat", "AutoFarmPizzaEat", function()
        if not getgenv().lol2 then
            if not options.Autofarm then return end
            local pizza = lp.Character and lp.Character:FindFirstChild"Pizza"
            if not pizza then return end
        end
        if getgenv().lol then getgenv().lol.Value = true end
        overridemedkitfire(nil, overridemedkitfireparams)--pizza:Activate()
        options.EnableSwordReach = true
        options.SwordReachRadius = 200
    end, 0.1)} )

    local wrap = coroutine.wrap
    miscdata.Autofarm = {
        On = function()
            if dbautofarm then return else dbautofarm = true end
            wrap(afk)()
            
            options.Autofarm = true
            autofarm.Button.BackgroundColor3 = accent

            wait(5)
            dbautofarm = false
        end,
        Off = function()
            if dbautofarm then return else dbautofarm = true end
            unafk()

            options.Autofarm = false
            autofarm.Button.BackgroundColor3 = dark

            wait(1)
            dbautofarm = false
        end
    }
    gui:BindToggleClick(autofarm.Button, miscdata.Autofarm, options.Autofarm)

    local legacyexplode = apply(defbutton:Clone(), {
        Parent = mischolder,
        Name = 'LegacyExplode'
    })
    gui:MakePopup(apply(popupbox:Clone(), { Parent = legacyexplode }), apply(gui:DefaultPopup"Enables smoke-rings on explosions (why were they removed?)", { BackgroundTransparency = settings.Looks.PopupTransparency, Size = UDim2.new(0,140,0,35) }), { FollowMouse = true })

    apply(legacyexplode.RealText, {
        Text = "<font color="..green..">  Legacy Explosions</font>",
        TextSize = 13,
        Size = UDim2.new(1, -30, 0, 20) --upd for button
    })
    
    local smokeunion = lp.PlayerScripts:WaitForChild("ObjectsRender"):WaitForChild("ExplosionOld"):WaitForChild("Smoke")
    local defexptinfo, defexptweens = TweenInfo.new(5, Enum.EasingStyle.Linear), {[true] = { Orientation = Vector3.new(0,180,0)}, [false] = { Orientation = Vector3.new()}}
    insert(data.Functions, { stepper:Add(workspace, "ChildAdded", "LegacyExplosions", function(c)
        if not (options.LegacyExplode and c.Name == 'Explosion' and c:IsA"Model") then return end
        
        local size = c:WaitForChild("Sphere", 3)
        if not size then return end
        local new = smokeunion:Clone()
        new.Size = size.Size * 1.1
        new.Position = size.Position
        new.Parent = c

        tweenservice:Create(new, TweenInfo.new(0.015 * size.Size.X, Enum.EasingStyle.Linear), {Transparency = 1}):Play()
        local alternate
        while new.Parent and new.Transparency < 1 do
            alternate = not alternate
            local new = tweenservice:Create(new, defexptinfo, defexptweens[alternate])
            new:Play()
            new.Completed:Wait()
        end
    end)})
    
    miscdata.LegacyExplode = {
        On = function()
            options.LegacyExplode = true
            legacyexplode.Button.BackgroundColor3 = accent
            --stepper:Enable(workspace, "ChildAdded", "LegacyExplosions")
        end,
        Off = function()
            options.LegacyExplode = false
            legacyexplode.Button.BackgroundColor3 = dark
            --stepper:Disable(workspace, "ChildAdded", "LegacyExplosions")
        end
    }
    gui:BindToggleClick(legacyexplode.Button, miscdata.LegacyExplode, options.LegacyExplode)

    local miscdisholder = apply(gui:AddBasic("Frame", UDim2.new(0.9,0,0,120), UDim2.new(0.05,0,0,25), righttab), {
        Name = "Disasters",
        --BorderColor3 = white
    })
    defuill:Clone().Parent = miscdisholder

    local autorocketexplode = apply(defbutton:Clone(), {
        Parent = miscdisholder,
        Name = 'LegacyExplode'
    })
    gui:MakePopup(apply(popupbox:Clone(), { Parent = autorocketexplode }), apply(gui:DefaultPopup"Missiles from disasters will automatically explode (Rocket Noobs, Killbots).\nMr. Happy and Missile Launcher use raycasting and will not explode.", { BackgroundTransparency = settings.Looks.PopupTransparency, Size = UDim2.new(0,180,0,60) }), { FollowMouse = true })

    apply(autorocketexplode.RealText, {
        Text = "<font color="..green..">  Disarm Rockets</font>",
        TextSize = 13,
        Size = UDim2.new(1, -30, 0, 20) --upd for button
    })
    
    local enemyrockets = shareddata.EnemyRockets
    insert(data.Functions, { stepper:Add(game["Run Service"], "Heartbeat", "DisarmRockets", function(c)
        if not options.DisarmRockets then return end
        for i,v in next, enemyrockets do
            if not v.Parent then rawset(enemyrockets, v, nil) else
                touch(v)
            end
        end
    end, 0.15) })
    miscdata.DisarmRockets = {
        On = function()
            options.DisarmRockets = true
            autorocketexplode.Button.BackgroundColor3 = accent
            --stepper:Enable(workspace, "ChildAdded", "LegacyExplosions")
        end,
        Off = function()
            options.DisarmRockets = false
            autorocketexplode.Button.BackgroundColor3 = dark
            --stepper:Disable(workspace, "ChildAdded", "LegacyExplosions")
        end
    }
    gui:BindToggleClick(autorocketexplode.Button, miscdata.DisarmRockets, options.DisarmRockets)

end
menu_settings = gui:AddMenu("Settings", unpackc3(options.MenuColors.Settings) or Color3.fromRGB(255, 255, 255))
do
    local maintab = gui:AddBasic("Frame", UDim2.new(0,187.5,0, 145), UDim2.new(0,10,0,10), menu_settings.Frame)
    local rightmaintab = gui:AddBasic("Frame", UDim2.new(0,187.5, 0, 230), UDim2.new(1,-197.5,0,10), menu_settings.Frame)
    local accent = menu_settings.Frame:FindFirstChild"Accent".Value

    apply(section:Clone(), {
        Parent = maintab,
        Text = "General"
    })
    
    
    local gendata = {}
    data.Functions.Miscellaneous = gendata
    local genholder = apply(gui:AddBasic("Frame", UDim2.new(0.9,0,0,80), UDim2.new(0.05,0,0,25), maintab), {
        Name = "Miscellaneous",
        BorderColor3 = white
    })
    defuill:Clone().Parent = genholder

    local savedb = tick() - 1
    insert(data.Connections, apply(gui:AddBasic("TextButton", UDim2.new(1,0,0,20), nil, genholder), {
        Text =  "Save Settings",
        BackgroundColor3 =  medium
    }).MouseButton1Click:Connect(function()
        if tick() - savedb < 2 then return end
        savedb = tick()
        notify{Title = "Settings", Text = "Successfully saved settings for future execution", Duration = 2}
        savesettings()
    end))

    local reloaddb = tick() - 1
    insert(data.Connections, apply(gui:AddBasic("TextButton", UDim2.new(1,0,0,20), nil, genholder), {
        Text =  "Load Last Save",
        BackgroundColor3 =  medium
    }).MouseButton1Click:Connect(function()
        if tick() - reloaddb < 2 then
            return
        end
        reloaddb = tick()
        local options = datasaver.GetSave"bell/sd2/options"
        if not options then
            return notify{Title = "Load Fail", Text = "No previous save found!", Duration = 2}
        end
        data.Options = options
        loadfile"bell/sd2/main.lua"""
    end))

    local reload2db = tick() - 1
    insert(data.Connections, apply(gui:AddBasic("TextButton", UDim2.new(1,0,0,20), nil, genholder), {
        Text =  "Reload Script",
        BackgroundColor3 =  medium
    }).MouseButton1Click:Connect(function()
        if tick() - reload2db < 2 then
            return
        end
        reload2db = tick()
        loadfile"bell/sd2/main.lua"""
    end))

    local unloading
    insert(data.Connections, apply(gui:AddBasic("TextButton", UDim2.new(1,0,0,20), nil, genholder), {
        Text =  "Unload Script",
        BackgroundColor3 =  dark
    }).MouseButton1Click:Connect(function()
        if unloading then return end
        unloading = true
        data.Unloaded = true

        notify{Title = "Unloading", Text = "Goodbye!", Duration = 1}
        shared.sdata.Queued = true

        sdata.Guis.sd2:cleanup()
        local d = sdata.Data.sd2
        for i,v in next, d.Functions do
            local x = v[1]
            if not typeof(x) == 'string' then continue end
            if not v:find"|" then
                stepper:RemoveContext(v)
            else
                stepper:Remove(unpack(v))
            end
        end
        for i,v in next, d.Connections do v:Disconnect() end
        for i,v in next, d.Tracers do for section, entry in next, v do entry:Destroy() end end

        if sdata.Connections.Mapper then
            for i,v in next, sdata.Connections.Mapper do
                if v[1] then stepper:Remove(unpack(v)) end
            end -- {InstDebugId|ConName, FuncName}
        end
        if sdata.Guis.Mapper then sdata.Guis.Mapper:cleanup() end 

        pcall(game.Destroy, workspace:FindFirstChild"afker")
        sdata.Queued = false
    end))

    apply(gui:AddBasic("Frame", UDim2.new(1,0,0,10), nil, genholder), {
        BackgroundTransparency = 1
    })
    local autoloader = apply(defbutton:Clone(), {
        Parent = genholder,
        Name = 'AutoLoad',
        Size = UDim2.new(1,0,0,20)
    })
    apply(autoloader.RealText, {
        Text = "  Always Load Save",
        Size = UDim2.new(1, -20, 0, 20) --upd for button
    })
    gui:MakePopup(apply(popupbox:Clone(), { Parent = autoloader }), apply(gui:DefaultPopup"When first loading the script, will automatically apply last-saved settings. Does not apply to script reloading.", { BackgroundTransparency = settings.Looks.PopupTransparency, Size = UDim2.new(0,160,0,50) }), { FollowMouse = true })
    
    gendata.AutoLoad = {
        On = function()
            autoloader.Button.BackgroundColor3 = accent
            writefile("bell/sd2/autoload", "")
        end,
        Off = function()
            autoloader.Button.BackgroundColor3 = dark
            pcall(delfile, "bell/sd2/autoload")
        end
    }
    gui:BindToggleClick(autoloader.Button, gendata.AutoLoad, isfile"bell/sd2/autoload")

    local colorthemeholder = apply(gui:AddBasic("ScrollingFrame", UDim2.new(0.9,0,0,160), UDim2.new(0.05,0,0,30), rightmaintab), { Name = 'MenuColors' })
    defuill:Clone().Parent = colorthemeholder
    gui:MakePopup(apply(popupbox:Clone(), { Parent = apply(section:Clone(), {
        Size = UDim2.new(0.6,0,0,20),
        Parent = rightmaintab,
        Text = "Menu Accents"
    }) }), apply(gui:DefaultPopup("Please reload the script and save settings (if necessary) for changes to take effect."), { BackgroundTransparency = settings.Looks.PopupTransparency, Size = UDim2.new(0,130,0,50) }), { FollowMouse = true })
    
    local defaultcolentry = apply(gui:AddBasic("Frame", UDim2.new(1,0,0,55)), {BackgroundColor3 = dark})
    apply(gui:AddBasic("TextLabel", UDim2.new(0.9,0,0,20), UDim2.new(0.05,0,0,5), defaultcolentry), {
        Name = "Named",
        Text = "Menu Name",
        TextStrokeTransparency = 0,
        BackgroundColor3 = Color3.new(1,1,1),
        BorderColor3 = Color3.new()
    })
    do
        
        local x = apply(gui:AddBasic("Frame", UDim2.new(0.25,0,0,15), UDim2.new(0.075,0,0,30), defaultcolentry), {
            Name = "R",
            BorderSizePixel = 0
        })
        apply(gui:AddBasic("TextLabel", UDim2.new(0.35,0,1), nil, x), {
            Name = "Label",
            Text = "R",
            TextSize = 10,
            BackgroundColor3 = dark,
            BorderSizePixel = 0
        })
        apply(gui:AddBasic("TextBox", UDim2.new(0.65,0,1), UDim2.new(0.35), x), {
            Text = "",
            PlaceholderText = '0',
            Name = 'Input',
            TextSize = 10,
            BorderSizePixel = 0,
        })
        apply(gui:AddBasic("Frame", UDim2.new(1,0,0,5), UDim2.new(0,0,1), x), {
            Name = "Color",
            BackgroundColor3 = Color3.new(1,1,1),
            BorderSizePixel = 0
        })
        local y = apply(x:Clone(), {
            Name = "G",
            Position = UDim2.new(0.375,0,0,30),
            Parent = defaultcolentry
        })
        y.Label.Text = "G"
        
        local z = apply(x:Clone(), {
            Name = "B",
            Position = UDim2.new(0.675,0,0,30),
            Parent = defaultcolentry
        })
        z.Label.Text = "B"
    end
    for i,v in next, gui:GetMenus() do
        local new = defaultcolentry:Clone()

        local accent = gui:GetMenu(v).Frame.Accent
        local accentval = accent.Value
        local r,g,b = round(accentval.R * 255), round(accentval.G * 255), round(accentval.B * 255)
        local name = new.Named
        new.Name, name.Text = v, v
        new.Named.BackgroundColor3 = accentval
        new.Parent = colorthemeholder

        local nr, ng, nb = new.R, new.G, new.B
        local inputr, inputg, inputb = nr.Input, ng.Input, nb.Input
        inputr.PlaceholderText, inputr.Text, new.R.Color.BackgroundColor3 = r, r, Color3.fromRGB(r)
        inputg.PlaceholderText, inputg.Text, new.G.Color.BackgroundColor3 = g, g, Color3.fromRGB(0,g)
        inputb.PlaceholderText, inputb.Text, new.B.Color.BackgroundColor3 = b, b, Color3.fromRGB(0,0,b)

        local cdata = options.MenuColors[v] or {r, g, b}
        options.MenuColors[v] = cdata

        local baseR, baseG, baseB = r,g,b
        insert(data.Connections, inputr:GetPropertyChangedSignal"Text":Connect(function()
            local msg = inputr.Text:gsub("[^%d]", "")
            if #msg ~= 0 then
                local num = tonumber(msg:sub(1,3))
                r = num and clamp(num, 0, 255) or r
                msg = num and r or msg
            else
                r = baseR
            end
            inputr.Text = msg

            local newcol = Color3.fromRGB(r, g, b)
            name.BackgroundColor3, nr.Color.BackgroundColor3 = newcol, Color3.fromRGB(r,0,0)
        end))
        insert(data.Connections, inputg:GetPropertyChangedSignal"Text":Connect(function()
            local msg = inputg.Text:gsub("[^%d]", "")
            if #msg ~= 0 then
                local num = tonumber(msg:sub(1,3))
                g = num and clamp(num, 0, 255) or g
                msg = num and g or msg
            else
                g = baseG
            end
            inputg.Text = msg

            local newcol = Color3.fromRGB(r, g, b)
            name.BackgroundColor3, ng.Color.BackgroundColor3 = newcol, Color3.fromRGB(0,g,0)
        end))
        insert(data.Connections, inputr.FocusLost:Connect(function()
            local msg = inputr.Text
            if #msg == 0 then
                inputr.Text = baseR
            else
                inputr.PlaceholderText = r
                baseR = r
                cdata[1] = r
            end
        end))
        insert(data.Connections, inputg:GetPropertyChangedSignal"Text":Connect(function()
            local msg = inputg.Text:gsub("[^%d]", "")
            if #msg ~= 0 then
                local num = tonumber(msg:sub(1,3))
                g = num and clamp(num, 0, 255) or g
                msg = num and g or msg
            else
                g = baseG
            end
            inputg.Text = msg

            local newcol = Color3.fromRGB(r, g, b)
            name.BackgroundColor3, ng.Color.BackgroundColor3 = newcol, Color3.fromRGB(0,g,0)
        end))
        insert(data.Connections, inputg.FocusLost:Connect(function()
            local msg = inputg.Text
            if #msg == 0 then
                inputg.Text = baseG
            else
                inputg.PlaceholderText = g
                baseG = g
                cdata[2] = g
            end
        end))
        insert(data.Connections, inputb:GetPropertyChangedSignal"Text":Connect(function()
            local msg = inputb.Text:gsub("[^%d]", "")
            if #msg ~= 0 then
                local num = tonumber(msg:sub(1,3))
                b = num and clamp(num, 0, 255) or b
                msg = num and b or msg
            else
                b = baseB
            end
            inputb.Text = msg

            local newcol = Color3.fromRGB(r, g, b)
            name.BackgroundColor3, nb.Color.BackgroundColor3 = newcol, Color3.fromRGB(0,0,b)
        end))
        insert(data.Connections, inputb.FocusLost:Connect(function()
            local msg = inputb.Text
            if #msg == 0 then
                inputb.Text = baseB
            else
                inputb.PlaceholderText = b
                baseB = b
                cdata[3] = b
            end
        end))
    end
    
    local resetaccents = apply(gui:AddBasic("TextButton", UDim2.new(0.9,0,0,20), UDim2.new(0.05,0,0,200), rightmaintab), {
        Text =  "Reset Accents",
        BackgroundColor3 =  medium
    })
    insert(data.Connections, resetaccents.MouseButton2Click:Connect(function()
        options.MenuColors = {}
        loadfile"bell/sd2/main.lua"""
    end))
    gui:MakePopup(resetaccents, apply(gui:DefaultPopup"Right-click me to reset all colors to their defaults.", { BackgroundTransparency = settings.Looks.PopupTransparency, Size = UDim2.new(0,120,0,40) }), { FollowMouse = true })
    
end

local f = gui.Gui.Frame
registerkeybind({
    Info = "ToggleMenuVisiblity",
    Key = "Semicolon",
    Ctrl = false,
    Alt = false,
    Repetitions = 1
}, function()
    if settings.Panicked then return end
    f.Visible = not f.Visible
end, true)
local iterates = {
    "Humanoids",
    'Buttons',
    'Touchables',
    'OrbBillboards',
    'DemobilizerCache',
    'Medkits',
    'Rockets',
    'ShurikontrolConnected',
    'HumanoidsFrozenFix',
    'EnemyRockets'
}
insert(data.Functions, { stepper:Add(game["Run Service"], "Heartbeat", "HelpCleanupInCase", function()
    local counter =  0
    for i,v in next, iterates do
        local cur = shareddata[v]
        for a,x in next, cur do
            if not a.Parent then
                pcall(firesignal, a.AncestryChanged)
                rawset(cur, a, nil)
                counter = counter + 1
            end
        end
    end
    --print('found '..counter..' extra instances being held onto')
end, 30)})
gui:SwitchTo"Miscellaneous"
gui:Enable()
setfpscap(0)
sdata.Queued = false