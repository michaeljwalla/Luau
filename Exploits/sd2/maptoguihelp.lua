local function require(d, recache)
    shared.requirecache = shared.requirecache or {}
    if (typeof(d) ~= 'string') then return getfenv().require(d) end
    if d:find"^http" then return loadstring(game:HttpGet(d))()
    else
        if not recache and shared.requirecache[d] then return shared.requirecache[d] end
        local n, a = pcall(readfile, d..".lua") --loadfile lol
        assert(n, "No local module '"..d.."'")
        local chunk = loadstring(a)
        assert(chunk, "Error in local: "..d)
        shared.requirecache[d] = chunk()
        return shared.requirecache[d]
    end
end
local insert = table.insert
local map = workspace.Map
local clamp = math.clamp
local stepper = require("bell/stepper")
local fetcher = require("bell/DataSaver")
local function getmap()
    return map:FindFirstChildWhichIsA"Model"
end
local terrains = {}
local function inssortparts(tbl) --insertion best for almost-sorted lists
    for i = 2, #tbl do
        local key = tbl[i]
        local mover = i - 1
        while mover >= 1 and key.Position.Y < tbl[mover].Position.Y do
            tbl[mover+1] = tbl[mover]
            mover = mover - 1
        end
        tbl[mover+1] = key
    end
end
local function assignplace(part)
    if not (part:IsA"BasePart") then return end
    terrains[#terrains+1] = part
    inssortparts(terrains)
end
local function round(n)
    return tonumber(tostring(math.round(n*1000)/1000):match"%-?%d+%.?%d?%d?%d?")
end
local function prepareforsave(fname)
    local data = {}
    for i,v in next, terrains do
        local upfactor = clamp(v.Position.Y/100, -0.2, 0.2) - 0.1 --kind of like topographical lines (higher = brighter)
        --local inverter = math.abs(math.cos(v.Orientation.Y * math.pi/180))
        local entry = {
            P = {
                X = round(v.Position.X/400 + 0.5), --0.5 bc its -200, 200
                Y = round(v.Position.Z/400 + 0.5)
            },
            S = {
                X = round(v.Size.X/400), --0.5 bc its -200, 200
                Y = round(v.Size.Z /400)
            },
            T = round(v.Transparency),
            C = {
                R = round(clamp(v.Color.R + upfactor, 0, 1)),
                G = round(clamp(v.Color.G + upfactor, 0, 1)),
                B = round(clamp(v.Color.B + upfactor, 0, 1))
            },
            --Tx = v:FindFirstChild"Texture" and "s"..tostring(v.Texture.Texture):match"%d+" or nil,
            R = v.Orientation.Y,
            O = i --just in case?
        }
        entry.P.X = entry.P.X - entry.S.X/2
        entry.P.Y = entry.P.Y - entry.S.Y/2
        data[#data+1] = entry
    end
    fetcher.SetSave("bell/sd2/minimap/"..fname, data)
end


--stepper:Add(map, "DescendantAdded", "Mapping", assignplace)
for i,v in next, workspace.Map:GetDescendants() do assignplace(v) end
--for i,v in next, terrains do print(v.Position.Y) end

prepareforsave("Winterville")
--local x = fetcher.GetSave("bell/sd2/minimap/Sleepy Swamp")
